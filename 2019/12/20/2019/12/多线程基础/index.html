<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="线程安全收集, Weslyxl">
    <meta name="description" content="什么是线程安全转载于 团长
不是线程的安全面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。
论语中有句话叫 “学而优则仕”，相信很多人都觉得是 “学习好了可以做官”。然而，这样理解却是错的。切记望文生义。

同理，“线程">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>线程安全收集 | Weslyxl</title>
    <link rel="icon" type="image/png" href="/favicon_w.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo_w.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">Weslyxl</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo_w.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Weslyxl</div>
        <div class="logo-desc">
            
            想全是问题，做才有答案。寻找产品与技术的融合。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/zhijianshusheng" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

    <div class="social-link">


    <a href="mailto:weslywxl@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>




</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/zhijianshusheng" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/10.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        线程安全收集
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/并发/" target="_blank">
                                <span class="chip bg-color">并发</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/服务端/" class="post-category" target="_blank">
                                服务端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-12-20
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        9k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        32 分
                    </div>
                    
                
				
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h1><p><a href="https://zhuanlan.zhihu.com/p/67905621" target="_blank" rel="noopener">转载于 团长</a></p>
<h2 id="不是线程的安全"><a href="#不是线程的安全" class="headerlink" title="不是线程的安全"></a><strong>不是线程的安全</strong></h2><p>面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。</p>
<p>论语中有句话叫 “学而优则仕”，相信很多人都觉得是 “学习好了可以做官”。然而，这样理解却是错的。切记望文生义。</p>
<blockquote>
<p>同理，“线程安全” 也不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。</p>
</blockquote>
<p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</p>
<p><strong>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）</strong>。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p>
<p>假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。</p>
<blockquote>
<p>比如把你住的小区看作一个进程，小区里的道路 / 绿化等就属于公共区域。你拿 1 万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。</p>
</blockquote>
<p>因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。</p>
<p>所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。</p>
<p>即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程 “破坏”。</p>
<p>那我们该怎么办呢？解决问题的过程其实就是一个取舍的过程，不同的解决方案有不同的侧重点。</p>
<h3 id="明白一些基本的"><a href="#明白一些基本的" class="headerlink" title="明白一些基本的"></a>明白一些基本的</h3><p>我们只有一个地址总线，一个内存。即使是在多线程的环境下，也不可能存在两个线程<strong>同时</strong>访问同一块内存区域的场景，<strong>内存的访问一定是通过一个地址总线串行排队访问的，所以在继续后续之前，我们先要明确几个结论</strong>：</p>
<p><strong>结论一</strong>：内存的访问是串行的，并不会导致内存数据的错乱或者应用的 crash。</p>
<p><strong>结论二</strong>：如果读写（load or store）的内存长度小于等于<strong>地址总线的长度</strong>，那么读写的操作是原子的，一次完成。比如 bool，int，long 在 64 位系统下的单次读写都是原子操作。</p>
<h2 id="私有的东西就不该让别人知道"><a href="#私有的东西就不该让别人知道" class="headerlink" title="私有的东西就不该让别人知道"></a><strong>私有的东西就不该让别人知道</strong></h2><p>现实中很多人都会把 1 万块钱藏着掖着，不让无关的人知道，所以根本不可能扔到大马路上。因为这钱是你的私有物品。</p>
<p>在程序中也是这样的，所以操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。这也是由操作系统保障的。</p>
<p>如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。较为常见的就是局部变量。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">double</span> <span class="token function">avgScore</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> score <span class="token operator">:</span> scores<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> score<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> scores<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">double</span> avg <span class="token operator">=</span> sum <span class="token operator">/</span> count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> avg<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的变量 sum，count，avg 都是局部变量，它们都会被分配在线程栈内存中。</p>
<p>假如现在 A 线程来执行这个方法，这些变量会在 A 的栈内存分配。与此同时，B 线程也来执行这个方法，这些变量也会在 B 的栈内存中分配。</p>
<p>也就是说这些局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。</p>
<p>就像每个人的家只属于自己，其他人不能进来。所以你把 1 万块钱放到家里，其他人是不会知道的。且一般还会放到某个房间里，而不是仍在客厅的桌子上。</p>
<p>所以把自己的东西放到自己的私人地盘，是安全的，因为其他人无法知道。而且越隐私的地方越好。</p>
<h2 id="大家不要抢，人人有份"><a href="#大家不要抢，人人有份" class="headerlink" title="大家不要抢，人人有份"></a><strong>大家不要抢，人人有份</strong></h2><p>相信聪明的你已经发现，上面的解决方案是基于 “位置” 的。因为你放东西的 “位置” 只有你自己知道（或能到达），所以东西是安全的，因此这份安全是由 “位置” 来保障的。</p>
<blockquote>
<p>在程序里就对应于方法的局部变量。局部变量之所以是安全的，就是因为定义它的 “位置” 是在方法里。这样一来安全是达到了，但是它的使用范围也就被限制在这个方法里了，其它方法想用也不用了啦。</p>
</blockquote>
<p>现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的 “位置” 就不能在方法里面了，而应该在方法外面。即从（方法的）局部变量变为（类的）成员变量，其实就是 “位置” 发生了变化。</p>
<p>那么按照主流编程语言的规定，类的成员变量不能再分配在线程的栈内存中，而应该分配在公共的堆内存中。其实也就是变量在内存中的 “位置” 发生了变化，由一个私有区域来到了公共区域。因此潜在的安全风险也随之而来。</p>
<blockquote>
<p>那怎么保证在公共区域的东西安全呢？答案就是，大家不要抢，人人有份。设想你在街头免费发放矿泉水，来了 1 万人，你却只有 1 千瓶水，结果可想而知，一拥而上，场面失守。但如果你有 10 万瓶水，大家一看，水多着呢，不用着急，一个个排着队来，因为肯定会领到。</p>
</blockquote>
<p>东西多了，自然就不值钱了，从另一个角度来说，也就安全了。大街上的共享单车，现在都很安全，因为太多了，到处都是，都长得一样，所以连搞破坏的人都放弃了。因此要让一个东西安全，就疯狂的 copy 它吧。</p>
<p>回到程序里，要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。相信你已经猜到了，我要表达的就是 ThreadLocal 类了。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">StudentAssistant</span> <span class="token punctuation">{</span>

    ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> realName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ThreadLocal<span class="token operator">&lt;</span>Double<span class="token operator">></span> totalScore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    String <span class="token function">determineDegree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">double</span> score <span class="token operator">=</span> totalScore<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"A"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"B"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">70</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"C"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"D"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">"E"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">double</span> <span class="token function">determineOptionalcourseScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">double</span> score <span class="token operator">=</span> totalScore<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">70</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">30</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">>=</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">40</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个学生助手类有两个成员变量，realName 和 totalScore，都是 ThreadLocal 类型的。每个线程在运行时都会拷贝一份存储到自己的本地。</p>
<p>A 线程运行的是 “张三” 和“90”，那么这两个数据 “张三” 和“90”是存储到 A 线程对象（Thread 类的实例对象）的成员变量里去了。假设此时 B 线程也在运行，是 “李四” 和“85”，那么 “李四” 和“85”这两个数据是存储到了 B 线程对象（Thread 类的实例对象）的成员变量里去了。</p>
<blockquote>
<p>线程类（Thread）有一个成员变量，类似于 Map 类型的，专门用于存储 ThreadLocal 类型的数据。从逻辑从属关系来讲，这些 ThreadLocal 数据是属于 Thread 类的成员变量级别的。从所在 “位置” 的角度来讲，这些 ThreadLocal 数据是分配在公共区域的堆内存中的。</p>
</blockquote>
<p>说的直白一些，就是把堆内存中的一个数据复制 N 份，每个线程认领 1 份，同时规定好，每个线程只能玩自己的那份，不准影响别人的。</p>
<p>需要说明的是这 N 份数据都还是存储在公共区域堆内存里的，经常听到的 “线程本地”，是从逻辑从属关系上来讲的，这些数据和线程一一对应，仿佛成了线程自己“领地” 的东西了。其实从数据所在 “位置” 的角度来讲，它们都位于公共的堆内存中，只不过被线程认领了而已。这一点我要特地强调一下。</p>
<p>其实就像大街上的共享单车。原来只有 1 辆，大家抢着骑，老出问题。现在从这 1 辆复制出 N 辆，每人 1 辆，各骑各的，问题得解。共享单车就是数据，你就是线程。骑行期间，这辆单车从逻辑上来讲是属于你的，从所在位置上来讲还是在大街上这个公共区域的，因为你发现每个小区大门口都贴着 “共享单车，禁止入门”。哈哈哈哈。</p>
<blockquote>
<p>共享单车是不是和 ThreadLocal 很像呀。再重申一遍，ThreadLocal 就是，把一个数据复制 N 份，每个线程认领一份，各玩各的，互不影响。</p>
</blockquote>
<h2 id="只能看，不能摸"><a href="#只能看，不能摸" class="headerlink" title="只能看，不能摸"></a><strong>只能看，不能摸</strong></h2><p>放在公共区域的东西，只是存在潜在的安全风险，并不是说一定就不安全。有些东西虽然也在公共区域放着，但也是十分安全的。比如你在大街上放一个上百吨的石头雕像，就非常安全，因为大家都弄不动它。</p>
<p>再比如你去旅游时，经常发现一些珍贵的东西，会被用铁栅栏围起来，上面挂一个牌子，写着 “只能看，不能摸”。当然可以国际化一点，“only look，don’t touch”。这也是很安全的，因为光看几眼是不可能看坏的。</p>
<p>回到程序里，这种情况就属于，只能读取，不能修改<strong>。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了</strong>。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">StudentAssistant</span> <span class="token punctuation">{</span>

    <span class="token keyword">final</span> <span class="token keyword">double</span> passScore <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>比如把及格分数设定为 60 分，在前面加上一个 final，这样所有线程都动不了它了。这就很安全了。</p>
<p><strong>小节一下</strong>：以上三种解决方案，其实都是在 “耍花招”。</p>
<p>第一种，找个只有自己知道的地方藏起来，当然安全了。</p>
<p>第二种，每人复制 1 份，各玩各的，互不影响，当然也安全了。</p>
<p>第三种，更狠了，直接规定，只能读取，禁止修改，当然也安全了。</p>
<blockquote>
<p>是不是都在 “避重就轻” 呀。如果这三种方法都解决不了，该怎么办呢？Don’t worry，just continue reading。</p>
</blockquote>
<h2 id="没有规则，那就先入为主"><a href="#没有规则，那就先入为主" class="headerlink" title="没有规则，那就先入为主"></a><strong>没有规则，那就先入为主</strong></h2><p>前面给出的三种方案，有点 “理想化” 了。现实中的情况其实是非常混乱嘈杂的，没有规则的。</p>
<p>比如在中午高峰期你去饭店吃饭，进门后发现只剩一个空桌子了，你心想先去点餐吧，回来就坐这里吧。当你点完餐回来后，发现已经被别人捷足先登了。</p>
<p>因为桌子是属于公共区域的物品，任何人都可以坐，那就只能谁先抢到谁坐。虽然你在人群中曾多看了它一眼，但它并不会记住你容颜。</p>
<p>解决方法就不用我说了吧，让一个人在那儿看着座位，其它人去点餐。这样当别人再来的时候，你就可以理直气壮的说，“不好意思，这个座位，我，已经占了”。</p>
<blockquote>
<p>我再次相信聪明的你已经猜到了我要说的东西了，没错，就是（互斥）锁。</p>
</blockquote>
<p>回到程序里，如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。</p>
<p>假设一个线程来到数据跟前一看，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据，干了一会活，累了，就去休息了。</p>
<p>这时，又来了一个线程，发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待，或放弃，转而去干别的。</p>
<p>第一个线程之所以敢大胆的去睡觉，就是因为它手里拿着锁呢，其它线程是不可能操作数据的。当它回来后继续把数据操作完，就可以把锁给释放了。锁再次回到空闲状态，其它线程就可以来抢这把锁了。还是谁先抢到锁谁操作数据。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ClassAssistant</span> <span class="token punctuation">{</span>

    <span class="token keyword">double</span> totalScore <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">addScore</span><span class="token punctuation">(</span><span class="token keyword">double</span> score<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        totalScore <span class="token operator">+=</span> score<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">subScore</span><span class="token punctuation">(</span><span class="token keyword">double</span> score<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        totalScore <span class="token operator">-=</span> score<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假定一个班级的初始分数是 60 分，这个班级抽出 10 名学生来同时参加 10 个不同的答题节目，每个学生答对一次为班级加上 5 分，答错一次减去 5 分。因为 10 个学生一起进行，所以这一定是一个并发情形。<br>因此加分和减分这两个方法被并发的调用，它们共同操作总分数。为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。</p>
<h2 id="相信世界充满爱，即使被伤害"><a href="#相信世界充满爱，即使被伤害" class="headerlink" title="相信世界充满爱，即使被伤害"></a><strong>相信世界充满爱，即使被伤害</strong></h2><p>再回到一开始的例子，假如你往地上仍 1 万块钱，是不是一定会丢呢？这要看情况了，如果是在人来人往的都市，可以说肯定会丢的。如果你跑到无人区扔地上，可以说肯定不会丢。<br>可以看到，都是把东西无保护的放到公共区域里，结果却相差很大。这说明安全问题还和公共区域的环境状况有关系。<br>比如我把数据放到公共区域的堆内存中，但是始终都只会有 1 个线程，也就是单线程模型，那这数据肯定是安全的。<br>再者说，2 个线程操作同一个数据和 200 个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有 1 个线程，那不安全概率就是 0，也就是安全的。</p>
<p>可能你又猜到了我想表达的内容了，没错，就是 CAS。可能大家觉得既然锁可以解决问题，那就用锁得了，为啥又冒出了个 CAS 呢？</p>
<blockquote>
<p>那是因为锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。<br>针对这种 “地广人稀” 的情况，专门提出了一种方法，叫 CAS（Compare And Swap）。<strong>就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用 CAS</strong>。</p>
</blockquote>
<p>假如一个线程操作数据，干了一半活，累了，想要去休息。（貌似今天的线程体质都不太好）。于是它记录下当前数据的状态（就是数据的值），回家睡觉了。<br>醒来后打算继续接着干活，但是又担心数据可能被修改了，于是就把睡觉前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明自己在睡觉期间，数据没有被人动过（当然也有可能是先被改成了其它，然后又改回来了，这就是 ABA 问题了），那就接着继续干。如果不一样，说明数据已经被修改了，那之前做的那些操作其实都白瞎了，就干脆放弃，从头再重新开始处理一遍。</p>
<p>所以 CAS 这种方式适用于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，你的数据一定会被修改，每次都要放弃，然后从头再来，这样反而花费的代价更大了，还不如直接加锁呢。</p>
<blockquote>
<p>这里再解释下 ABA 问题，假如你睡觉前数据是 5，醒来后数据还是 5，并不能肯定数据没有被修改过。可能数据先被修改成 8 然后又改回到 5，只是你不知道罢了。对于这个问题，其实也很好解决，再加一个版本号字段就行了，并规定只要修改数据，必须使版本号加 1。</p>
</blockquote>
<p>这样你睡觉前数据是 5 版本号是 0，醒来后数据是 5 版本号是 0，表明数据没有被修改。如果数据是 5 版本号是 2，表明数据被改动了 2 次，先改为其它，然后又改回到 5。</p>
<blockquote>
<p>我再次相信聪明的你已经发现了，这里的 CAS 其实就是乐观锁，上一种方案里的获取锁和释放锁其实就是悲观锁。乐观锁持乐观态度，就是假设我的数据不会被意外修改，如果修改了，就放弃，从头再来。悲观锁持悲观态度，就是假设我的数据一定会被意外修改，那干脆直接加锁得了。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前两种属于隔离法，一个是位置隔离，一个是数据隔离。<br>然后两种是标记法，一个是只读标记，一个是加锁标记。<br>最后一种是大胆法，先来怼一把试试，若不行从头再来。</p>
<p>对于大胆法，还是有必要尝试的。有人曾说过，“梦想还是要有的，万一实现了呢”。</p>
<h1 id="iOS-多线程到底不安全在哪里？"><a href="#iOS-多线程到底不安全在哪里？" class="headerlink" title="iOS 多线程到底不安全在哪里？"></a>iOS 多线程到底不安全在哪里？</h1><p><a href="https://zhuanlan.zhihu.com/p/23998703" target="_blank" rel="noopener">转载于Peak</a></p>
<blockquote>
<p>数据类型长度、地址总线，一次读一个</p>
</blockquote>
<p>iOS 多线程安全的概念在很多地方都会遇到，为什么不安全，不安全又该怎么去定义，其实是个值得深究的话题。</p>
<p>共享状态，多线程共同访问某个对象的 property，在 iOS 编程里是很普遍的使用场景，我们就从 Property 的多线程安全说起。</p>
<h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><p>当我们讨论 property 多线程安全的时候，很多人都知道给 property 加上 atomic attribute 之后，可以一定程度的保障多线程安全，类似：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">@property (atomic, strong) NSString*                 userName;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>事情并没有看上去这么简单，要分析 property 在多线程场景下的表现，需要先对 property 的类型做区分。</p>
<p>我们可以简单的将 property 分为值类型和对象类型，值类型是指 primitive type，包括 int, long, bool 等非对象类型，另一种是对象类型，声明为指针，可以指向某个符合类型定义的内存区域。</p>
<p>上述代码中 userName 明显是个对象类型，当我们访问 userName 的时候，访问的有可能是 userName 本身，也有可能是 userName 所指向的内存区域。</p>
<p>比如：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">self.userName = @"peak";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是在对指针本身进行赋值。而</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">[self.userName rangeOfString:@"peak"];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是在访问指针指向的字符串所在的内存区域，这二者并不一样。</p>
<p>所以我们可以大致上将 property 分为三类：</p>
<p><img src="https://pic1.zhimg.com/v2-a9ebf61f92ee5f038ce226fe610abed8_r.jpg" alt="img"></p>
<p>分完类之后，我们需要明白这三类 property 的内存模型。</p>
<h3 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h3><p>当我们讨论多线程安全的时候，其实是在讨论多个线程同时访问一个内存区域的安全问题。针对同一块区域，我们有两种操作，读（load）和写（store），读和写同时发生在同一块区域的时候，就有可能出现多线程不安全。所以展开讨论之前，先要明白上述三种 property 的内存模型，可用如下图示：</p>
<p><img src="https://pic2.zhimg.com/v2-be811753fdd06db8d45a3aecb9d611f1_r.jpg" alt="img"></p>
<p>以 64 位系统为例，指针 NSString * 是 8 个字节的内存区域，int count 是个 4 字节的区域，而 @“Peak” 是一块根据字符串长度而定的内存区域。</p>
<p>当我们访问 property 的时候，实际上是访问上图中三块内存区域。</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">self.userName = @"peak";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是修改第一块区域。</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">self.count = 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是在修改第二块区域。</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">[self.userName rangeOfString:@"peak"];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是在读取第三块区域。</p>
<h3 id="不安全的定义"><a href="#不安全的定义" class="headerlink" title="不安全的定义"></a>不安全的定义</h3><p>明白了 property 的类型以及他们对应的内存模型，我们再来看看不安全的定义。Wikipedia 如是说：</p>
<blockquote>
<p>A piece of code is <strong>thread-safe</strong> if it manipulates shared data structures only in a manner that guarantees safe execution by multiple threads at the same time</p>
</blockquote>
<p>这段定义看起来还是有点抽象，我们可以将多线程不安全解释为：<strong>多线程访问时出现意料之外的结果</strong>。这个意料之外的结果包含几种场景，不一定是指 crash，后面再一一分析。</p>
<p>先来看下多线程是如何同时访问内存的。不考虑 CPU cache 对变量的缓存，内存访问可以用下图表示：</p>
<p><img src="https://pic3.zhimg.com/v2-247e40b69c6542339485569665f9111e_r.jpg" alt="img"></p>
<p>从上图中可以看出，我们只有一个地址总线，一个内存。即使是在多线程的环境下，也不可能存在两个线程<strong>同时</strong>访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的，所以在继续后续之前，我们先要明确几个结论：</p>
<p><strong>结论一</strong>：内存的访问时串行的，并不会导致内存数据的错乱或者应用的 crash。</p>
<p><strong>结论二</strong>：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如 bool，int，long 在 64 位系统下的单次读写都是原子操作。</p>
<p>接下来我们根据上面三种 property 的分类逐一看下多线程的不安全场景。</p>
<h4 id="值类型-Property"><a href="#值类型-Property" class="headerlink" title="值类型 Property"></a>值类型 Property</h4><p>先以 BOOL 值类型为例，当我们有两个线程访问如下 property 的时候：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">@property (nonatomic, assgin) BOOL    isDeleted;

//thread 1
bool isDeleted = self.isDeleted;

//thread 2
self.isDeleted = false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>线程 1 和线程 2，一个读 (load)，一个写 (store)，对于 BOOL isDeleted 的访问可能有先后之分，但一定是串行排队的。而且由于 BOOL 大小只有 1 个字节，64 位系统的地址总线对于读写指令可以支持 8 个字节的长度，所以对于 BOOL 的读和写操作我们可以认为是原子的，所以当我们声明 BOOL 类型的 property 的时候，从原子性的角度看，使用 atomic 和 nonatomic 并没有实际上的区别（当然如果重载了 getter 方法就另当别论了）。</p>
<p>如果是 int 类型呢？</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">@property (nonatomic, assgin) int    count;

//thread 1
int curCount = self.count;

//thread 2
self.count = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同理 int 类型长度为 4 字节，读和写都可以通过一个指令完成，所以理论上读和写操作都是原子的。从访问内存的角度看 nonatomic 和 atomic 也并没有什么区别。</p>
<p>atomic 到底有什么用呢？据我所知，用处有二：</p>
<p><strong>用处一：生成原子操作的 getter 和 setter。</strong></p>
<p><strong>设置 atomic 之后，默认生成的 getter 和 setter 方法执行是原子的。也就是说，当我们在线程 1 执行 getter 方法的时候（创建调用栈，返回地址，出栈），线程 B 如果想执行 setter 方法，必须先等 getter 方法完成才能执行。</strong></p>
<blockquote>
<p>举个例子，在 32 位系统里，如果通过 getter 返回 64 位的 double，地址总线宽度为 32 位，从内存当中读取 double 的时候无法通过原子操作完成，如果不通过 atomic 加锁，有可能会在读取的中途在其他线程发生 setter 操作，从而出现异常值。如果出现这种异常值，就发生了<strong>多线程不安全</strong>。</p>
</blockquote>
<p><strong>用处二：设置 Memory Barrier</strong>——防止指令重排序</p>
<p>对于 Objective C 的实现来说，几乎所有的加锁操作最后都会设置 memory barrier，atomic 本质上是对 getter，setter 加了锁，所以也会设置 memory barrier。官方文档表述如下：</p>
<blockquote>
<p><strong>Note:</strong> Most types of locks also incorporate a memory barrier to ensure that any preceding load and store instructions are completed before entering the critical section.</p>
</blockquote>
<p>memory barrier 有什么用处呢？</p>
<p>memory barrier 能够保证内存操作的顺序，按照我们代码的书写顺序来。听起来有点不可思议，事实是编译器会对我们的代码做优化，在它认为合理的场景改变我们代码最终翻译成的机器指令顺序。也就是说如下代码：</p>
<pre class="line-numbers language-java"><code class="language-java">self<span class="token punctuation">.</span>intA <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//line 1</span>
self<span class="token punctuation">.</span>intB <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//line 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>编译器可能在一些场景下先执行 line2，再执行 line1，因为它认为 A 和 B 之间并不存在依赖关系，虽然在代码执行的时候，在另一个线程 intA 和 intB 存在某种依赖，必须要求 line1 先于 line2 执行。</p>
<p>如果设置 property 为 atomic，也就是设置了 memory barrier 之后，就能够保证 line1 的执行一定是先于 line2 的，当然这种场景非常罕见，一则是出现变量跨线程访问依赖，二是遇上编译器的优化，两个条件缺一不可。这种极端的场景下，atomic 确实可以让我们的代码更加多线程安全一点，但我写 iOS 代码至今，还未遇到过这种场景，较大的可能性是编译器已经足够聪明，在我们需要的地方设置 memory barrier 了。</p>
<p><strong>是不是使用了 atomic 就一定多线程安全呢？</strong>我们可以看看如下代码：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">@property (atomic, assign)    int       intA;

//thread A
for (int i = 0; i < 10000; i ++) {
    self.intA = self.intA + 1;
    NSLog(@"Thread A: %d\n", self.intA);
}

//thread B
for (int i = 0; i < 10000; i ++) {
    self.intA = self.intA + 1;
    NSLog(@"Thread B: %d\n", self.intA);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使我将 intA 声明为 atomic，最后的结果也不一定会是 20000。原因就是因为 self.intA = self.intA + 1; 不是原子操作，虽然 intA 的 getter 和 setter 是原子操作，但当我们使用 intA 的时候，整个语句并不是原子的，这行赋值的代码至少包含读取 (load)，+1(add)，赋值(store) 三步操作，当前线程 store 的时候可能其他线程已经执行了若干次 store 了，导致最后的值小于预期值。这种场景我们也可以称之为<strong>多线程不安全</strong>。</p>
<h4 id="指针-Property"><a href="#指针-Property" class="headerlink" title="指针 Property"></a>指针 Property</h4><p>指针 Property 一般指向一个对象，比如：</p>
<pre><code>@property (atomic, strong) NSString*                 userName;</code></pre><blockquote>
<p>无论 iOS 系统是 32 位系统还是 64 位，一个指针的值都能通过一个指令完成 load 或者 store。但和 primitive type 不同的是，对象类型还有内存管理的相关操作。在 MRC 时代，系统默认生成的 setter 类似如下：</p>
</blockquote>
<pre><code>- (void)setUserName:(NSString *)userName {
    if(_uesrName != userName) {
        [userName retain];
        [_userName release];
        _userName = userName;
    }
}</code></pre><p>不仅仅是赋值操作，还会有 retain，release 调用。如果 property 为 nonatomic，上述的 setter 方法就不是原子操作，我们可以假设一种场景，线程 1 先通过 getter 获取当前_userName，之后线程 2 通过 setter 调用 [_userName release];，线程 1 所持有的_userName 就变成无效的地址空间了，如果再给这个地址空间发消息就会导致 crash，出现<strong>多线程不安全</strong>的场景。</p>
<p>到了 ARC 时代，Xcode 已经替我们处理了 retain 和 release，绝大部分时候我们都不需要去关心内存的管理，但 retain，release 其实还是存在于最后运行的代码当中，atomic 和 nonatomic 对于对象类的 property 声明理论上还是存在差异，不过我在实际使用当中，将 NSString * 设置为 nonatomic 也从未遇到过上述多线程不安全的场景，极有可能 ARC 在内存管理上的优化已经将上述场景处理过了，所以我个人觉得，如果只是对对象类 property 做 read，write，atomic 和 nonatomic 在多线程安全上并没有实际差别。</p>
<h4 id="指针-Property-指向的内存区域"><a href="#指针-Property-指向的内存区域" class="headerlink" title="指针 Property 指向的内存区域"></a>指针 Property 指向的内存区域</h4><blockquote>
<p>这一类多线程的访问场景是我们很容易出错的地方，即使我们声明 property 为 atomic，依然会出错。因为我们访问的不是 property 的指针区域，而是 property 所指向的内存区域。可以看如下代码：</p>
</blockquote>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">@property (atomic, strong) NSString*                 stringA;

//thread A
for (int i = 0; i < 100000; i ++) {
    if (i % 2 == 0) {
        self.stringA = @"a very long string";
    }
    else {
        self.stringA = @"string";
    }
    NSLog(@"Thread A: %@\n", self.stringA);
}

//thread B
for (int i = 0; i < 100000; i ++) {
    if (self.stringA.length >= 10) {
        NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];
    }
    NSLog(@"Thread B: %@\n", self.stringA);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然 stringA 是 atomic 的 property，而且在取 substring 的时候做了 length 判断，线程 B 还是很容易 crash，因为在前一刻读 length 的时候 self.stringA = @”a very long string”;，下一刻取 substring 的时候线程 A 已经将 self.stringA = @”string”;，立即出现 out of bounds 的 Exception，crash，<strong>多线程不安全</strong>。</p>
<p>同样的场景还存在对集合类操作的时候，比如：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">@property (atomic, strong) NSArray*                 arr;

//thread A
for (int i = 0; i < 100000; i ++) {
    if (i % 2 == 0) {
        self.arr = @[@"1", @"2", @"3"];
    }
    else {
        self.arr = @[@"1"];
    }
    NSLog(@"Thread A: %@\n", self.arr);
}

//thread B
for (int i = 0; i < 100000; i ++) {
    if (self.arr.count >= 2) {
        NSString* str = [self.arr objectAtIndex:1];
    }
    NSLog(@"Thread B: %@\n", self.arr);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同理，即使我们在访问 objectAtIndex 之前做了 count 的判断，线程 B 依旧很容易 crash，原因也是由于前后两行代码之间 arr 所指向的内存区域被其他线程修改了。</p>
<blockquote>
<p>所以你看，真正需要操心的是这一类内存区域的访问，即使声明为 atomic 也没有用，我们平常 App 出现莫名其妙难以重现的多线程 crash 多是属于这一类，一旦在多线程的场景下访问这类内存区域的时候，要提起十二分的小心。如何避免这类 crash 后面会谈到。</p>
</blockquote>
<h4 id="Property-多线程安全小结："><a href="#Property-多线程安全小结：" class="headerlink" title="Property 多线程安全小结："></a>Property 多线程安全小结：</h4><p>简而言之，atomic 的作用只是给 getter 和 setter 加了个锁，<strong>atomic 只能保证代码进入 getter 或者 setter 函数内部时是安全的，一旦出了 getter 和 setter，多线程安全只能靠程序员自己保障了</strong>。所以 atomic 属性和使用 property 的多线程安全并没什么直接的联系。另外，atomic 由于加锁也会带来一些性能损耗，所以我们在编写 iOS 代码的时候，一般声明 property 为 nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。</p>
<h3 id="如何做到多线程安全？"><a href="#如何做到多线程安全？" class="headerlink" title="如何做到多线程安全？"></a>如何做到多线程安全？</h3><p>讨论到这里，其实怎么做到多线程安全也比较明朗了，<strong>关键字是 atomicity（原子性），只要做到原子性，小到一个 primitive type 变量的访问，大到一长段代码逻辑的执行，原子性能保证代码串行的执行，能保证代码执行到一半的时候，不会有另一个线程介</strong>入。</p>
<p>原子性是个相对的概念，它所针对的对象，粒度可大可小。</p>
<p>比如下段代码：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">if (self.stringA.length >= 10) {
    NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>是非原子性的。</p>
<p>但加锁以后：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">//thread A
[_lock lock];
for (int i = 0; i < 100000; i ++) {
    if (i % 2 == 0) {
        self.stringA = @"a very long string";
    }
    else {
        self.stringA = @"string";
    }
    NSLog(@"Thread A: %@\n", self.stringA);
}
[_lock unlock];

//thread B
[_lock lock];
if (self.stringA.length >= 10) {
    NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];
}
[_lock unlock];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整段代码就具有原子性了，就可以认为是多线程安全了。</p>
<p>再比如：</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">if (self.arr.count >= 2) {
    NSString* str = [self.arr objectAtIndex:1];
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>是非原子性的。</p>
<p>而</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">//thread A
[_lock lock];
for (int i = 0; i < 100000; i ++) {
    if (i % 2 == 0) {
        self.arr = @[@"1", @"2", @"3"];
    }
    else {
        self.arr = @[@"1"];
    }
    NSLog(@"Thread A: %@\n", self.arr);
}
[_lock unlock];

//thread B
[_lock lock];
if (self.arr.count >= 2) {
    NSString* str = [self.arr objectAtIndex:1];
}
[_lock unlock];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是具有原子性的。注意，<strong>读和写都需要加锁</strong>。</p>
<p>这也是为什么我们在做多线程安全的时候，并不是通过给 property 加 atomic 关键字来保障安全，而是将 property 声明为 nonatomic（nonatomic 没有 getter，setter 的锁开销），然后自己加锁。</p>
<p><strong>如何使用哪种锁？</strong></p>
<p>iOS 给代码加锁的方式有很多种，常用的有：</p>
<ul>
<li>@synchronized(token)</li>
<li>NSLock</li>
<li>dispatch_semaphore_t</li>
<li>OSSpinLock</li>
</ul>
<p>这几种锁都可以带来原子性，性能的损耗从上至下依次更小。</p>
<p>我个人建议是，在编写应用层代码的时候，除了 OSSpinLock 之外，哪个顺手用哪个。相较于这几个锁的性能差异，代码逻辑的正确性更为重要。而且这几者之间的性能差异对用户来说，绝大部分时候都感知不到。</p>
<p>当然我们也会遇到少数场景需要追求代码的性能，比如编写 framework，或者在多线程读写共享数据频繁的场景，我们需要大致了解锁带来的损耗到底有多少。</p>
<p>官方文档有个数据，使用 Intel-based iMac with a 2 GHz Core Duo processor and 1 GB of RAM running OS X v10.5 测试，获取 mutex 有大概 0.2ms 的损耗，我们可以认为锁带来的损耗大致在 ms 级别。</p>
<p><strong>Atomic Operations</strong></p>
<p>其实除了各种锁之外，iOS 上还有另一种办法来获取原子性，使用 Atomic Operations，相比锁的损耗要小一个数量级左右，在一些追求高性能的第三方 Framework 代码里可以看到这些 Atomic Operations 的使用。这些 atomic operation 可以在 / usr/include/libkern/OSAtomic.h 中查到：</p>
<p><img src="https://pic2.zhimg.com/v2-2f1251d8a688342687f0406db19331c5_r.jpg" alt="img"></p>
<p>比如</p>
<pre class="line-numbers language-c++"><code class="language-c++">_intA ++;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是非原子性的。</p>
<p>而</p>
<pre class="line-numbers language-objective-c"><code class="language-objective-c">OSAtomicIncrement32(&(_intA));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是原子性的，多线程安全的。</p>
<blockquote>
<p>Atomic Operation 只能应用于 32 位或者 64 位的数据类型，在多线程使用 NSString 或者 NSArray 这类对象的场景，还是得使用锁。</p>
</blockquote>
<p>大部分的 Atomic Operation 都有 OSAtomicXXX，OSAtomicXXXBarrier 两个版本，Barrier 就是前面提到的 memory barrier，在多线程多个变量之间存在依赖的时候使用 Barrier 的版本，能够保证正确的依赖顺序。</p>
<p>对于平时编写应用层多线程安全代码，我还是建议大家多使用 @synchronized，NSLock，或者 dispatch_semaphore_t，<strong>多线程安全</strong>比<strong>多线程性能</strong>更重要，应该在前者得到充分保证，犹有余力的时候再去追求后者。</p>
<h3 id="尽量避免多线程的设计"><a href="#尽量避免多线程的设计" class="headerlink" title="尽量避免多线程的设计"></a>尽量避免多线程的设计</h3><p>无论我们写过多少代码，都必须要承认多线程安全是个复杂的问题，作为程序员我们应该尽可能的避免多线程的设计，而不是去追求高明的使用锁的技能。</p>
<p>后面我会写一篇文章，介绍函数式编程及其核心思想，即使我们使用非函数式的编程语言，比如 Objective C，也能极大的帮助我们避免多线程安全的问题。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>iOS 下多线程不安全的分析至此结束了，如何编写多线程安全的代码，说到底还是在于对 <strong>memory layout</strong> 和<strong>原子性</strong>的理解，也希望这篇文章将 atomic 和 nonatomic 的真正区别解释清楚了。</p>

            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://www.wxlong.tech" class="b-link-green">Weslyxl</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/12/20/2019/12/多线程基础/" class="b-link-green">线程安全收集</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/12/22/2019/12/MySql VIP/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/29.jpg" class="responsive-img" alt="Mysql VIP视频笔记">
                        
                        <span class="card-title">Mysql VIP视频笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">InnoDB局部性原理：页为单位去取,，一页16KB

一行最多存65535KB，
行格式的区别，Dynamic，Compressd，Compact除以行溢出的方式不同。
索引页的查找逻辑

页目录，目录页。——》归根结底就是快速查找


</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-12-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/数据库/" class="post-category" target="_blank">
                                    数据库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/视频笔记/" target="_blank">
                        <span class="chip bg-color">视频笔记</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/12/19/2019/12/Java并发常见代码/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="《实战java高并发程序设计》一些笔记">
                        
                        <span class="card-title">《实战java高并发程序设计》一些笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Java并发常见代码一些基本概念
同步与异步：会不会阻塞当前线程
并发与并行：一段时间与同一时间点
临界区：公共资源，共享数据
阻塞、非阻塞：线程是否挂起
死锁、饥饿、活锁：饥饿比如在非公平锁中一直拿不到锁就是饥饿，一直得不到执行

重点说</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-12-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java/" class="post-category" target="_blank">
                                    java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/并发/" target="_blank">
                        <span class="chip bg-color">并发</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('40')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Weslyxl<br />'
            + '作者: weslyxl<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者wesly所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
             Copyright  ©️2019  Wesly
            <!-- 本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">492.9k</span>
            

            
			 -->
        </div>
        <div class="col s12 m4 l4 social-link ">


    <a href="mailto:weslywxl@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>




</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input" autofocus="">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics --><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</body>
</html>