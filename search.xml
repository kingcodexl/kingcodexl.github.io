<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot自动装配原理详解</title>
      <link href="/2019/11/26/2019/11/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/26/2019/11/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>Spring自动装配主要就是基于注解。我们只需要使用<code>@SpringBootApplication</code>这样一个注解就就能够完全启动一个项目了。它是由下面三个注解完成</p><p>SpringBootApplication 注解详情</p><ul><li><code>@SpringBootConfiguration</code>：我们点进去以后可以发现底层是 <strong>Configuration</strong> 注解，说白了就是支持 <strong>JavaConfig</strong> 的方式来进行配置 (<strong>使用 Configuration 配置类等同于 XML 文件</strong>)。</li><li><code>@EnableAutoConfiguration</code>：开启<strong>自动配置</strong>功能，后面详细介绍，自动装配的核心</li><li><code>@ComponentScan</code>：这个注解，学过 Spring 的同学应该对它不会陌生，就是<strong>扫描</strong>注解，<strong>默认是扫描当前类下的 package</strong>。将<code>@Controller/@Service/@Component/@Repository</code>等注解加载到 IOC 容器中。</li></ul><p>我们先从一个异常开始入手</p><h1 id="从一个异常谈起"><a href="#从一个异常谈起" class="headerlink" title="从一个异常谈起"></a>从一个异常谈起</h1><p>刚接触springboot的时候踩过这样一个坑：在pom文件中不小心加了db相关的依赖，比如</p><pre class="line-numbers language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后项目就启动不了</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9amlurlwlj20m705oaak.jpg" alt="1574679886185.png"></p><p>看报错中框出来的部分——数据源没有指定url。what？这个pom依赖只是我不小心加的啊，它怎么就自动给我配了一个数据源，还由于没配url这些数据源相关的配置导致报错了。</p><p>再回想起我们之前搭ssm框架的时候是如何配置datasource的呢？</p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token comment" spellcheck="true">&lt;!-- - - - -数据源配置 - - - - - --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxxx.ComboPooledDataSource<span class="token punctuation">"</span></span>          <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${driverClass}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${jdbcUrl}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${user}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在spring配置xml中配置一个datasource的bean，注册进ioc容器。那么，我们是否可以猜想，springboot由于我们加了<code>spring-boot-starter-jdbc</code>依赖，<strong>所以它自动帮我们往ioc容器里注入了一个datasource的bean</strong>？</p><blockquote><p>这个报错可以在springboot启动类中排除datasource自动配置类来解决，原因后文会讲到。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> DataSourceAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>springboot的自动配置，会自动将一些配置类的bean注册进ioc容器，我们可以需要的地方使用@autowired或者@resource等注解来使用它。</p><blockquote><p>“自动”的表现形式就是我们只需要引我们想用功能的包，相关的配置我们完全不用管，springboot会自动注入这些配置bean，我们直接使用这些bean即可。</p><p>具体来讲就是在配置文件中，我们输入spring，会有很多配置提示，这些配置提示就是自动装配bean属性：</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9amm2p741j20ep0awgmq.jpg" alt="1574680258702.png"></p></blockquote><p>其实这就是根据下面自动装配类来得，它的路径——<code>C:\Users\Administrator\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\2.1.3.RELEASE\spring-boot-autoconfigure-2.1.3.RELEASE.jar!\org\springframework\boot\autoconfigure\data\redis\RedisProperties.class</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> database <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String url<span class="token punctuation">;</span>    <span class="token keyword">private</span> String host <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">6379</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> ssl<span class="token punctuation">;</span>    <span class="token keyword">private</span> Duration timeout<span class="token punctuation">;</span>    <span class="token keyword">private</span> RedisProperties<span class="token punctuation">.</span>Sentinel sentinel<span class="token punctuation">;</span>    <span class="token keyword">private</span> RedisProperties<span class="token punctuation">.</span>Cluster cluster<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> RedisProperties<span class="token punctuation">.</span>Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisProperties<span class="token punctuation">.</span>Jedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> RedisProperties<span class="token punctuation">.</span>Lettuce lettuce <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisProperties<span class="token punctuation">.</span>Lettuce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意一下<code>autoconfigure\data\redis</code></p><h1 id="源码分析自动配置是如何实现"><a href="#源码分析自动配置是如何实现" class="headerlink" title="源码分析自动配置是如何实现"></a>源码分析自动配置是如何实现</h1><p>我们都知道springboot最核心的注解 <code>@SpringBootApplication</code>等于<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 、<code>@ComponentScan</code>等注解的作用，顾名思义，<code>@EnableAutoConfiguration</code> 显然就是springboot实现自动配置的核心所在。</p><h1 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="EnableAutoConfiguration"></a>EnableAutoConfiguration</h1><p>简单来说，这个注解可以帮助我们<strong>自动载入</strong>应用程序所需要的所有<strong>默认配置</strong>。</p><p>我们点进去看一下，发现有<strong>两个</strong>比较重要的注解</p><p>EnableAutoConfiguration 注解详情</p><ul><li><code>@AutoConfigurationPackage</code>：自动配置包</li><li><code>@Import</code>：给 IOC 容器导入组件</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token comment" spellcheck="true">//扫描</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//装配</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    String ENABLED_OVERRIDE_PROPERTY <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="AutoConfigurationPackage"></a>AutoConfigurationPackage</h2><p>网上将这个<code>@AutoConfigurationPackage</code>注解解释成<strong>自动配置包</strong>，我们也看看<code>@AutoConfigurationPackage</code>里边有什么。也是用<code>@import</code>导入的</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Registrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AutoConfigurationPackage</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>继续看Register里面是什么</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Registrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span><span class="token punctuation">,</span> DeterminableImports <span class="token punctuation">{</span>        <span class="token function">Registrar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            AutoConfigurationPackages<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Set<span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token function">determineImports</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutoConfigurationPackages<span class="token punctuation">.</span>PackageImport</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心的就是<code>registerBeanDefinitions</code>。</p><p>表示的含义就是在<strong>默认</strong>的情况下就是将：主配置类 (<code>@SpringBootApplication</code>) 的所在包及其子包里边的组件扫描到 Spring 容器中。</p><ul><li>看完这句话，会不会觉得，这不就是 ComponentScan 的功能吗？这俩不就重复了吗？</li></ul><p>我开始也有这个疑问，直到看到文档的这句话：</p><blockquote><p>it will be used when scanning for code @Entity classes.<br>It is generally recommended that you place EnableAutoConfiguration (if you’re<br>not using  @SpringBootApplication) in a root package so that all sub-packages<br>and classes can be searched.</p></blockquote><p>比如说，你用了 Spring Data JPA，可能会在实体类上写<code>@Entity</code>注解。这个<code>@Entity</code>注解由<code>@AutoConfigurationPackage</code>扫描并加载，而我们平时开发用的<code>@Controller/@Service/@Component/@Repository</code>这些注解是由<code>ComponentScan</code>来扫描并加载的。</p><blockquote><p>简单理解：这二者<strong>扫描的对象是不一样</strong>。</p></blockquote><h1 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h1><p>点进去看一下，便得到</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> NO_IMPORTS<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            AutoConfigurationMetadata autoConfigurationMetadata <span class="token operator">=</span> AutoConfigurationMetadataLoader<span class="token punctuation">.</span><span class="token function">loadMetadata</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry autoConfigurationEntry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>autoConfigurationMetadata<span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> StringUtils<span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">protected</span> AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>AutoConfigurationMetadata autoConfigurationMetadata<span class="token punctuation">,</span> AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> EMPTY_ENTRY<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            AnnotationAttributes attributes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取候选配置</span>            configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移除重复的配置</span>            Set<span class="token operator">&lt;</span>String<span class="token operator">></span> exclusions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//移除exclude修饰的那些配置</span>            configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到方法名<code>getCandidateConfigurations</code>，获取候选配置，由此我们可以猜想这一步就是springboot获取所有用<code>@Configuration</code>注解修饰的配置类的名称，那么为什么叫做“候选”配置呢？往下看，根据方法名，我们就能知道方法做了什么，接下来就是从这里获取的候选配置的list里，剔除重复部分，再剔除一开始我们<code>@SpringbootApplication</code> 注解里exclude掉的配置，最终才得到配置类名集合。</p><p>接下来看看getCandidateConfigurations 里面的内容</p><h2 id="getCandidateConfigurations"><a href="#getCandidateConfigurations" class="headerlink" title="getCandidateConfigurations"></a>getCandidateConfigurations</h2><p>内容</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">protected</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span> AnnotationAttributes attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> SpringFactoriesLoader<span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> <span class="token string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> configurations<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 SpringFactoriesLoader 来加载</p><p>这里包装了一层，我们看到的只是通过 SpringFactoriesLoader 来加载，还没看到关键信息，继续进去</p><p><code>loadFactoryNames</code></p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String factoryClassName <span class="token operator">=</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token function">loadSpringFactories</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最终来到<code>loadSpringFactories</code>。<code>public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MultiValueMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token punctuation">(</span>MultiValueMap<span class="token punctuation">)</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 类加载器对象存在则用这个加载器获取上面说的常量路径里的资源，不存在则用系统类加载器去获取</span>                <span class="token comment" spellcheck="true">//当前classloader是appclassloader，getResources能获取所有依赖jar里面的META-INF/spring.factories的完整路径</span>            ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> classLoader <span class="token operator">!=</span> null <span class="token operator">?</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token string">"META-INF/spring.factories"</span><span class="token punctuation">)</span> <span class="token operator">:</span> ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span><span class="token string">"META-INF/spring.factories"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                LinkedMultiValueMap result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedMultiValueMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 遍历上述返回的url集合</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    URL url <span class="token operator">=</span> <span class="token punctuation">(</span>URL<span class="token punctuation">)</span>urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// URL类可以获取来自流，web，甚至jar包里面的资源</span>                    UrlResource resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>                    Properties properties <span class="token operator">=</span> PropertiesLoaderUtils<span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>                    Iterator var6 <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>var6<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> entry <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token punctuation">)</span>var6<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 解析spring.factories</span>                        String factoryClassName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        String<span class="token punctuation">[</span><span class="token punctuation">]</span> var9 <span class="token operator">=</span> StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> var10 <span class="token operator">=</span> var9<span class="token punctuation">.</span>length<span class="token punctuation">;</span>                        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var11 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var11 <span class="token operator">&lt;</span> var10<span class="token punctuation">;</span> <span class="token operator">++</span>var11<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            String factoryName <span class="token operator">=</span> var9<span class="token punctuation">[</span>var11<span class="token punctuation">]</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// spring.facories中配置的不仅仅有自动配置相关的内容，还有其他比如                                 // ApplicationContextInitializer等等各种springboot启动的时候，初始化spring环                     // 境需要的配置,自动配置只是其中一项。这个cache也是在springboot启动阶段就赋值的</span>                            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">,</span> factoryName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var13<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unable to load factories from location [META-INF/spring.factories]"</span><span class="token punctuation">,</span> var13<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单梳理：</p><ul><li><code>FACTORIES_RESOURCE_LOCATION</code>的值是<code>META-INF/spring.factories</code></li><li>Spring 启动的时候会扫描所有 jar 路径下的<code>META-INF/spring.factories</code>，将其文件包装成 Properties 对象</li><li>从 Properties 对象获取到 key 值为<code>EnableAutoConfiguration</code>的数据，然后添加到容器里边。</li></ul><p><code>C:\Users\Administrator\.m2\repository\org\springframework\spring-beans\5.1.5.RELEASE\spring-beans-5.1.5.RELEASE\META-INF\spring.factories</code></p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9am8r6chjj20fo07bwju.jpg" alt="5611237-72a9e12a2d4c9df3.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>springboot自身的autoconfigure包里有大量的java配置类，我们也可以在自己的工程中写这些配置类，这些配置类需要在相应的<code>META-INF/spring.facotries</code>文件中配置好，如下</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9am8r6chjj20fo07bwju.jpg" alt="5611237-72a9e12a2d4c9df3.png"></p><p>这样就会因为在<code>@EnableAutoConfiguration</code>注解的存在，这些配置类里面的bean被注册进ioc容器，不过也是有条件的,条件注解<code>ConditionOnxxx</code>。下面列一些常用的Condition注解：</p><p>@ConditionalOnBean（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）<br>@ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean）<br>@ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean）<br>@ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean）<br>@ConditionalOnNotWebApplication（不是web应用）</p><p>@ConditionalOnClass（当注解在方法上，某个class位于类路径上，才会实例化一个Bean）<br>@ConditionalOnClass (当注解于类上, 某个class位于类路径上，否则不解析该注解修饰的配置类)</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="配置bean以及注册bean的几种方式"><a href="#配置bean以及注册bean的几种方式" class="headerlink" title="配置bean以及注册bean的几种方式"></a>配置bean以及注册bean的几种方式</h2><p>复习一下springboot的配置类和把配置类注册进ioc容器的几种方式。springboot的优点之一就是近乎零配置，我们可以抛弃繁杂的xml，使用代码来配置bean。</p><p>定义一个bean</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Service或者-Component等注解"><a href="#Service或者-Component等注解" class="headerlink" title="@Service或者@Component等注解"></a><code>@Service</code>或者<code>@Component</code>等注解</h2><p>在上面的配置类上加<code>@Service</code>或者<code>@Component</code>等注解，springboot会扫描启动类所在的包下面所有带有这些注解的类，实例化bean加到ioc容器。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//@Service</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Configuration和-Bean"><a href="#Configuration和-Bean" class="headerlink" title="@Configuration和@Bean"></a><code>@Configuration</code>和<code>@Bean</code></h2><p>使用<code>@Configuration</code>和<code>@Bean</code>注解来配置bean到ioc容器,这个类也需要在springboot启动类所在的包或者子包下面，否则无法扫到。</p><p>定义一个BeanConfig，并用@Bean配置容器</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用-Import注解"><a href="#使用-Import注解" class="headerlink" title="使用@Import注解"></a>使用<code>@Import</code>注解</h2><p>使用<code>@Import</code>注解：相信很多人对<code>@EnableScheduling</code> 、<code>@EnableCaching</code>等@Enablexxxx系列的注解都不陌生，它们就是使用的是@Import注解来实现开启xx功能的。比如说我们熟悉的<code>@EnableScheduling</code> 注解。这些注解是在AutoConfigurationPackage扫描到的。</p><p>在springboot启动类上加一行代码<code>@Import(Person.class)</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token punctuation">(</span>exclude <span class="token operator">=</span> DataSourceAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoConfDemoApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>AutoConfDemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们依然可以把我们自定义的ClockService实例化一个bean加到ioc容器</p><blockquote><p><strong>注意</strong> ：1.2点其实是可以给bean设置名称的，比如说@Bean(name=“xx”),这样在一个类型多个实例bean的时候可以按名称注入（<code>@Autowire</code>是默认按类型注入，但可以用<code>Qualifier</code>注解来指定bean的名称; <code>@Resource</code>是按名称注入），第3点只适用于一个类只有一个实例bean的情况下。</p><p>ps:<code>@Import</code>注解其实并不是只能导入@Configuration修饰的配置类，还有很多更强大的功能</p></blockquote><h2 id="安装上面分析的，使用自动装配"><a href="#安装上面分析的，使用自动装配" class="headerlink" title="安装上面分析的，使用自动装配"></a>安装上面分析的，使用自动装配</h2><p>后面再写…..</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://www.jianshu.com/p/7eb0c2b214a7" target="_blank" rel="noopener">Spring Import 三种用法与源码解读</a></p><p><a href="https://blog.csdn.net/sunxy24/article/details/82801508#commentBox" target="_blank" rel="noopener">springboot自动配置以及原理分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot零配置原理详解</title>
      <link href="/2019/11/25/2019/11/SpringBoot%E9%9B%B6%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/25/2019/11/SpringBoot%E9%9B%B6%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在正式开始讲解原理之前，着重说明一下如何去学习一门技术。</p><blockquote><p>学习一门新技术，最好的方式就是阅读官网文档、跟着官方文档例子一步一步走。当然如果是为了先感受一下技术的效果，建议先找个例子跑起来，感受感受。</p></blockquote><p><a href="https://spring.io/projects" target="_blank" rel="noopener">Spring官网</a></p><h2 id="Spring、SpringMVC、SpringBoot三者之间的关系"><a href="#Spring、SpringMVC、SpringBoot三者之间的关系" class="headerlink" title="Spring、SpringMVC、SpringBoot三者之间的关系"></a>Spring、SpringMVC、SpringBoot三者之间的关系</h2><ul><li><strong>Spring</strong>：Spring 是一个开源框架，起初是为解决企业应用开发的复杂性而创建，但是现在已经不止于企业应用。Spring的核心就是提供一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。</li><li><strong>Spring MVC</strong>：Spring MVC可以理解为<strong>Spring和MVC</strong>结合的一种开发架构，Spring的概念可以参阅上面所述。MVC是一种将数据业务、显示逻辑和控制逻辑进行分层的设计模式。SpringMVC是用于Web程序的通用框架。</li><li><strong>SpringBoot</strong><br>SpringBoot是用来简化Spring框架应用初始化搭建以及开发的全新框架，比如通过自动化配置省去了大量繁琐的配置文件，因此SpringBoot可以理解成，一个通过简化配置文件来服务于框架的框架。</li></ul><p>Spring是最为基础的部分,，提供容器；SpringMVC基于Spring，只是在Spring上面加上了MVC的思想；SpringBoot则是对SpringMVC的简化。</p><h1 id="从SpringMVC谈起"><a href="#从SpringMVC谈起" class="headerlink" title="从SpringMVC谈起"></a>从SpringMVC谈起</h1><p>上古时代使用SpringMVC的时候都是基于web.xml那种开发方式。常见的几个开发配置文件有</p><ol><li>web.xml</li><li>applicationContext.xml</li><li>spingMVC.xml</li></ol><p>下面分别来说说它们的作用，接下来再尝试一个一个去删掉，最终达到SpringBoot零配置的目的。</p><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><p>当需要载入多个spring相关的配置文件时<strong>，首先加载ContextLoaderListener类</strong>，再指定<code>context-param</code>中指定多个spring配置文件，使用逗号分别隔开各个文件。为了使用方便可以将配置文件进行MVC式的分解，配置控制器Bean的配置文件放置在一个xml文件中，server的Bean放在service.xml文件中。</p><p>Spring分为多个文件进行分别的配置，其中在<code>servlet-name</code>中如果没有指定<code>init-param</code>属性，那么系统自动寻找的spring配置文件为<code>[servlet-name]-servlet.xml</code>。</p><p><code>&lt;servlet-mapping&gt;</code>指定的该servlet接管的url的行为，此处为了简便起见使用<em>.</em>,则表示在URL只要是在本机使用的任何request都是由该dispatchServlet来处理。</p><p>加载顺序如下:</p><ol><li><p>配置<code>&lt;listener&gt;</code>，当web容器（tomcat）启动之后，这里监听就会得到触发。然后初始化Spring环境。而初始化环境就需要确定Spring需要加载哪些东西，通过<code>context-param</code>指定加载的东西。——&gt;什么是初始化环境，就是初始化一个对象。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:spring/applicationContext.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置servlet，也就是springmvc前端控制器。</p></li></ol><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token comment" spellcheck="true">&lt;!-- springmvc前端控制器 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:spring/springmvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于web.xml中要初始化Spring容器，初始化容器里面需要有applicationcontxt.xml所以我们要配置applicationcontxt.xml，其实整个web.xml有很多配置的我只要了这两段，因为剩下的是没必要。</p></blockquote><h2 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h2><p>在appcliationContext.xml中，其实只有一行就可以了（不需要连接数据库，仅仅用于测试SpringMVC）</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置Service扫描 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.service<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个配置的作用是扫描你的项目的业务类，比如说这里的servce。</p><blockquote><p>这个配置的作用是扫描你的项目的业务类，比如说这里的servce。</p></blockquote><h2 id="springMVC-xml"><a href="#springMVC-xml" class="headerlink" title="springMVC.xml"></a>springMVC.xml</h2><p>因为Web.xml要初始化MVC的前端控制器所以我们还需要配置一个springMVC.xml。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置Controller扫描 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.xxx.controller<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 配置注解驱动 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token punctuation">/></span></span>     <span class="token comment" spellcheck="true">&lt;!-- 对静态资源放行  --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/<span class="token punctuation">"</span></span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/**<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 视图解释器 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/WEB-INF/jsp/<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个配置文件中其实只有<code>配置Controller扫描、配置注解驱动</code>有用，它的作用是用来扫描<code>controller</code>的，<strong>下面这一大段东西其实也是可要可不要的</strong>，为什么呢，因为下面这一段是视图解析器，假设来写一个不用返回视图的controller：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test Index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样不需要返回JSP，假设我的项目中都没有其他方法了，如果我的整个controller里就这一个方法的话，那就不需要这个视图解析器了</p><blockquote><p>所以换言之，配置文件里的配置视图解析器这一段代码就可以省去了。</p><p>于是得出结论整个SpringMVC.xml中他主要做了一件事情就是扫描controller。</p></blockquote><h1 id="Tomcat与web-xml的关系"><a href="#Tomcat与web-xml的关系" class="headerlink" title="Tomcat与web.xml的关系"></a>Tomcat与web.xml的关系</h1><p>我们知道web应用程序中，我们没有写任何main方法，只把对应的war包放到web容器中就可以运行。而在非web应用程序中，要运行程序必须定义一个main方法入口。那么web程序又是怎么调用的呢？</p><p>这里用tomcat举例。在使用tomcat的时候，我们需要定义一个web.xml文件，就如上面使用springmvc一样。前面在讲<code>web.xml</code>的时候提到<code>Listener</code>的作用就是用来加载Spring环境的。</p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>Tomcat是由java开发的，那么它必然就有一个main方法。举个例子，Tomcat的启动方式是不是点击Tomcat.exe（java开发也同样可以编译成exe,以jar为例都是一个意思）或者<strong>点击编译器上面的启动按钮</strong>？你点击Tomcat.exe或者编译器上的启动按钮时，就会运行Tomcat的main方法。</p><p>要初始化Spring容器是不是要放在Tomcat的main方法里启动？</p><p>因为Tomcat的main方法里会去读取或者parse（解析）web.xml（读取你的那段初始化spring环境的那段配置——listener），这个就无需开发者担心了因为这个是标准的模式，他会找到并解析你项目里的web.xml，而且会找到xml里的一个标签叫 listener，它找到一个类叫ContextLoaderListener的某个方法里面执行下面这行代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//init spring context new bean(初始化Spring容器)</span>AnnotationConfigApplicationContext ac<span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>Appconfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以想象为，当tomcat启动的时候，就会自动的调用这里的ContextLoaderListener，进而实现Spring 环境的初始化。</p></blockquote><p>下面介绍tomcat启动流程</p><h2 id="Tomcat启动流程"><a href="#Tomcat启动流程" class="headerlink" title="Tomcat启动流程"></a>Tomcat启动流程</h2><p>tomcat启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取<code>&lt;listener&gt;</code>和<code>&lt;context-param&gt;</code>两个结点。</p><p>紧接着，容器创建一个<code>ServletContext</code>（servlet上下文，全局的），这个web项目的所有部分都将共享这个上下文。可以把ServletContext看成是一个Web应用的服务器端组件的共享内存，在ServletContext中可以存放共享数据。ServletContext对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问</p><p>容器将<code>&lt;context-param&gt;</code>转换为键值对，并交给servletContext。</p><p>容器创建<code>&lt;listener&gt;</code>中的类实例，创建监听器。  listener中ContextLoaderListener监听器的作用就是启动Web容器时，监听servletContext对象的变化，获取servletContext对象的<code>&lt;context-param&gt;</code>，来自动装配ApplicationContext的配置信息<strong>。（即加载applicationContext.xml文件）</strong></p><h1 id="SpringMVC官网的写法"><a href="#SpringMVC官网的写法" class="headerlink" title="SpringMVC官网的写法"></a>SpringMVC官网的写法</h1><p>讲了这么久，我们去看看官网的写法，因为非常精简。接下来我们也是跟着官网的写法将xml文件一个一个去掉。</p><blockquote><p>对应的解释：The following example of the Java configuration registers and initializes the <code>DispatcherServlet</code>, which is auto-detected by the Servlet container (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-container-config" target="_blank" rel="noopener">Servlet Config</a>):</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWebApplicationInitializer</span>  <span class="token keyword">implements</span> <span class="token class-name">WebApplicationInitializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletCxt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Load Spring web application configuration</span>        AnnotationConfigWebApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigWebApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ac<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ac<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Create and register the DispatcherServlet</span>        DispatcherServlet servlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServletRegistration<span class="token punctuation">.</span>Dynamic registration <span class="token operator">=</span> servletCxt<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/app/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官网的代码只需要上面这点代码就能实现web.xml、applicationContext.xml、springMVC.xml的功能。</p><p>下面一步一步来分析</p><h1 id="去掉web-xml"><a href="#去掉web-xml" class="headerlink" title="去掉web.xml"></a>去掉web.xml</h1><h2 id="去掉listenser"><a href="#去掉listenser" class="headerlink" title="去掉listenser"></a>去掉listenser</h2><p>我们知道web.xml的作用就是通过listener在tomcat启动的时候，初始化spring环境。如果可以不通过web.xml来初始化环境，那么就可以不用web.xml。</p><p>官网的推荐写法中直接通过<code>AnnotationConfigWebApplicationContext</code>来初始化Spring环境，所以这里的web.xml我们是可以去掉的。</p><h2 id="去掉dispathservlet"><a href="#去掉dispathservlet" class="headerlink" title="去掉dispathservlet"></a>去掉dispathservlet</h2><p>DispatcherServlet我们可以通过注解来取代xml的方式。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以说这个web.xml这个servlet的配置也是可以去掉的。</p><blockquote><p>但其实Spring的源码做法不是如此，我们要把这个Servlet注册给容器(Tomcat)。——&gt;关于内嵌tomcat，后面会介绍</p><p>假设某一天我能得到这个Tomcat对象（SpringBoot就是这样做的），我就调用Tomcat的一个方法比如说是.addServlet（new DispatcherServlet）不就也等于完成了注册这件事情吗？</p></blockquote><p>根据官网的代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Create and register the DispatcherServlet</span>        DispatcherServlet servlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServletRegistration<span class="token punctuation">.</span>Dynamic registration <span class="token operator">=</span> servletCxt<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/app/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>registration.setLoadOnStartup(1)</code>的意思就相当于web.xml中<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>。</p><h1 id="去掉applicationContext-xml"><a href="#去掉applicationContext-xml" class="headerlink" title="去掉applicationContext.xml"></a>去掉applicationContext.xml</h1><p>按照我们刚刚的分析，这个<code>applicationContext.xml</code>就做了一个事情：扫描业务类。</p><p>那我们看看官方文档是怎么去扫描的：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// Load Spring web application configuration</span>        AnnotationConfigWebApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigWebApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ac<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ac<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>核心的就是这句<code>ac.register(AppConfig.class);</code>。</p><p>假设这类的<code>Appconfig</code>内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"com.test"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>官方文档中的例子是：把AppConfig注册给我们的ApplicationContext对象，他就可以在appconfig里面配置信息拿到包名，然后去扫描，于是我们的applicationcontxt.xml也可以删掉了。</p></blockquote><h1 id="去掉springMVCxml"><a href="#去掉springMVCxml" class="headerlink" title="去掉springMVCxml"></a>去掉springMVCxml</h1><p>前面我们讲过spring.mvc只有<code>配置Controller扫描、配置注解驱动</code>有用，它的作用是用来扫描<code>controller</code>的，<strong>下面这一大段东西其实也是可要可不要的。</strong></p><p>所以我们同样可以在<code>AppConfig</code>类中实现扫描注解。</p><p>那么和applicationContext.xml完全可以配在一起，为什么不配在一起要分开配置呢？</p><blockquote><p>因为都放在一起的话，老版本会导致事务失效，其实也有办法去解决让他们放在一起不会事物失效，那为什么现在大家还是在分在两个配置文件用呢？因为很多这种网上所讲的配置都是很老的文章了，<strong>大概是Spring2.5左右的版本了（那个时候是没办法解决这个问题的）</strong>现在是Spring5.X这个问题早就解决了，我们现在如果要配置的话无需分开配置不会导致事物失效。</p></blockquote><p>下面顺便提一下如何解决</p><h2 id="老版spring事务失效原因及解决办法"><a href="#老版spring事务失效原因及解决办法" class="headerlink" title="老版spring事务失效原因及解决办法"></a>老版spring事务失效原因及解决办法</h2><blockquote><p>现在的版本已经不会有这个问题了。</p></blockquote><p>其实Spring和SpringMVC俩个容器为父子关系，Spring为父容器，而SpringMVC为子容器。</p><p>也就是说<code>application.xml</code>中应该负责扫描除<code>@Controller</code>的注解如<code>@Service</code>，而SpringMVC的配置文件应该只负责扫描<code>@Controller</code>，否则会产生重复扫描导致Spring容器中配置的事务失效。 </p><blockquote><p>也就是说spring先扫描要添加事务的包或者类然后再由springMVC扫描的话加上的事务就会失效。</p><p>解决方法就是在扫描配置中加上过滤。</p></blockquote><p>Spring的配置文件：application.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.xxx.redis<span class="token punctuation">"</span></span> <span class="token attr-name">use-default-filters</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 排除含@Controller注解的类 --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>exclude-filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>annotation<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.xxxx.controller.UserController<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>SpringMVC的配置文件：springmvc.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 只扫描含@Controller注解的包,避免重复扫描 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.xx.controller<span class="token punctuation">"</span></span> <span class="token attr-name">use-default-filters</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>component-scan</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在spring配置文件中用过滤器排除扫描加过@Controller的类然后springMVC配置文件中只扫描带@Controller的类排除@Service注解的类. </p><h1 id="配置都去掉"><a href="#配置都去掉" class="headerlink" title="配置都去掉"></a>配置都去掉</h1><p>综上这三个xml都可以去掉，于是我们再次证明了官方文档上面的那一段代码确实可以完成SpringMVC。</p><p>再来回顾一下官网启动SpringMVC的代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyWebApplicationInitializer</span>  <span class="token keyword">implements</span> <span class="token class-name">WebApplicationInitializer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletCxt<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Load Spring web application configuration</span>        AnnotationConfigWebApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigWebApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去掉web.xml中的listener节点</span>        ac<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//去掉包扫描的applicationContext.xml,sprngmvc.xml</span>        ac<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Create and register the DispatcherServlet</span>        DispatcherServlet servlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServletRegistration<span class="token punctuation">.</span>Dynamic registration <span class="token operator">=</span> servletCxt<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去掉web.xml中的servlet几点</span>        registration<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registration<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/app/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前还剩下一个问题：内嵌的Tomcat如何启动？</p><h1 id="内嵌Tomcat"><a href="#内嵌Tomcat" class="headerlink" title="内嵌Tomcat"></a>内嵌Tomcat</h1><p>Tomcat可以利用依赖直接new tomcat start，并且版本没啥要求。</p><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat.embed<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>tomcat-embed-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>9.0.14<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且要初始化Spring环境</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeslyxlApplication</span> <span class="token keyword">implements</span> <span class="token class-name">WebApplicationInitializer</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//测试Spring环境初始化是否成功</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tomcat-----init-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化 spring context环境(Spring环境)</span>        AnnotationConfigWebApplicationContext acweb                 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigWebApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当你这段代码执行完成之后他就会去完成扫描，你整个项目当中的bean都有了</span>        <span class="token comment" spellcheck="true">//就相当于你的Spring已经准备好了，它帮你那些类new好，把bean扫描出来，这就是初始化Spring环境。</span>        acweb<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建和注册DispatcherServlet</span>        DispatcherServlet servlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span>acweb<span class="token punctuation">)</span><span class="token punctuation">;</span>        ServletRegistration<span class="token punctuation">.</span>Dynamic ds <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ds<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/app/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面有Tomcat依赖，接下来就是初始化Tomcat</p><p>首先写一个run方法，因为Springboot就是run方法启动的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringApplication</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//实例化tomcat对象</span>        Tomcat tomcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tomcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//端口号设置</span>        tomcat<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tomcat<span class="token punctuation">.</span><span class="token function">addWebapp</span><span class="token punctuation">(</span>contextPath<span class="token operator">:</span><span class="token string">"/"</span><span class="token punctuation">,</span>docBase<span class="token operator">:</span><span class="token string">"d:\\test\\"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            tomcat<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Tomcat启动方法</span>            tomcat<span class="token punctuation">.</span><span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Tomcat阻塞方法,保证不退出</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">LifecycleException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个Tomcat就是前面引入的依赖来的，底层操作就是Tomcat去new一个tomcat</p><ul><li><p>contextPath是设置你的访问路径，如：localhost:9090/ 这个/就是设置的访问根路径。</p></li><li><p>docBase:则是你的工作空间地址。</p></li></ul><p>Tomcat需要阻塞的原因是如果不加这个方法的话，Tomcat整个主线程完成结束之后Tomcat也会跟着结束，调用这个await()方法就是把Tomcat阻塞在这里，等待用户请求，所以在启动Tomcat的时候你会发现Tomcat并没有结束就是这个原因。</p><p>接下来写测试验证一下</p><p>controller:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/index"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"xxxxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写一个测试类Test去测试你的这些代码能否成功:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终就会在终端打印——System.out.println(“tomcat—–init——-“);</p><h1 id="Servlet标准"><a href="#Servlet标准" class="headerlink" title="Servlet标准"></a>Servlet标准</h1><p>这个跟Java的一种标准有关，Tomcat可以作为java的web容器，Nginx不行，Nginx只能做静态服务器，只有Jetty和Tomcat可以，<strong>是因为Tomcat和Jetty都实现了一种Java标准就是Servlet标准，同理只要实现了Servlet标准，才能作为Java的Web容器</strong>。</p><p>我们会觉得很奇怪，为什么<code>onStartup</code>就会自动调用。</p><p>Servlet的标准有两个很重要的两个版本一个是2.5一个是3.1，一般的培训机构和论坛教程都是使用的Servlet2.5，如果你的Tomcat是6的版本，Tomcat6对应的Servlet版本就是2.5的版本，那么2.5的版本的Servlet是没有<strong>@WebServlet的这个注解</strong>。</p><p>这个注解也其实同样是个类，我们装好Tomcat6的时候，它的lib里有很多jar包其中有一个jar包叫Servlet-api，<strong>如果版本是Tomcat6那么Servlet的版本可能是2.5甚至之前的版，2.5以前的版本根本就没有这个类，即使在项目编译时期能够编译过去，但是一旦放到Tomcat6上面运行就会<code>不识别这个注解就</code>会报错</strong>。我印象当中从Tomcat7或者8以后就开始支持3.1的Servlet标准了。</p><h2 id="Servlet标准3-1"><a href="#Servlet标准3-1" class="headerlink" title="Servlet标准3.1"></a>Servlet标准3.1</h2><p>Spring-web是相当于一个jar包放在我们的项目中来的，那么这个jar包里的东西就相当我们项目文件中的一部分，会把jar包里面的项目复制到我们的项目当中去。</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9agqmi3e9j20cb03d3yc.jpg" alt="2019-11-25_164059.png"></p><p>里面的内容就是：<code>org.springframework.web.SpringServletContainerInitializer</code></p><p>Servlet3.1标准规定在你的meta-inf文件下面如果提供了一个service文件夹并且在这个文件夹里提供了一个文件名叫javax-servlet-ServletContainerlnitializer的文件（注意：Spring-web到meta-inf到service到这个文件都是不可以变的Java规定要这样写），这个文件里面又提供了一个类``SpringServletContainerInitializer`，而这个类又实现了ServletainerIitializer这个接口，<strong>那么任何容器启动时都要调用这个onStartup()方法</strong>。</p><blockquote><p>也就是说tomcat7或者8启动的时候，如果用户真的去写了javax-servlet-ServletContainerlnitializer并在里面配了一个类的话Tomcat7-8必须要去无条件的调用这个类的onStartup();方法。这就是Servlet3.1的标准。<strong>也就是所谓的SPI扩容技术，所以Spring利用了Servlet3.1这个标准来完成了他的一个0配置原理</strong>。</p></blockquote><h1 id="零配置原理"><a href="#零配置原理" class="headerlink" title="零配置原理"></a>零配置原理</h1><p>2个方面来说Spring的0配置原理：</p><h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><p>我们为什么能把Xml文件去掉还可以一样的达到Xml的效果是因为我们使用了注解，<strong>所有的Spring注解统称Java config</strong>。</p><p>官网的那句话:</p><pre><code>The following example of the Java configuration registers and initializes the DispatcherServlet, which is auto-detected by the Servlet container (see Servlet Config):</code></pre><p>所以是Java config+Servlet3.1的新特性完成的我们零配置原理（0 XML文件）</p><blockquote><p>注意零配置并不代表自动装配。自动装配由注解实现的，换句话说就是自动装配是针对于去掉xml而言。关于自动装配的原理，后面会单独介绍，核心也是用注解。</p></blockquote><h2 id="Servlet3-1标准"><a href="#Servlet3-1标准" class="headerlink" title="Servlet3.1标准"></a>Servlet3.1标准</h2><p>上面介绍了tomcat启动的时候就必须无条件的调用ServletContainerlnitializer的onstartup方法。但会发现文中说的Tomcat启动要找一个类实现ServletainerIitializer这个接口，但是示例代码里却又是实现的WebApplicationInitializer它不一样。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeslyxlApplication</span> <span class="token keyword">implements</span> <span class="token class-name">WebApplicationInitializer</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//测试Spring环境初始化是否成功</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tomcat-----init-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化 spring context环境(Spring环境)</span>        AnnotationConfigWebApplicationContext acweb                 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigWebApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当你这段代码执行完成之后他就会去完成扫描，你整个项目当中的bean都有了</span>        <span class="token comment" spellcheck="true">//就相当于你的Spring已经准备好了，它帮你那些类new好，把bean扫描出来，这就是初始化Spring环境。</span>        acweb<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 创建和注册DispatcherServlet</span>            DispatcherServlet servlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispatcherServlet</span><span class="token punctuation">(</span>acweb<span class="token punctuation">)</span><span class="token punctuation">;</span>            ServletRegistration<span class="token punctuation">.</span>Dynamic ds <span class="token operator">=</span> servletContext<span class="token punctuation">.</span><span class="token function">addServlet</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">,</span> servlet<span class="token punctuation">)</span><span class="token punctuation">;</span>            ds<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ds<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/app/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二个标准"><a href="#第二个标准" class="headerlink" title="第二个标准"></a>第二个标准</h2><p>除了上面提到的这个标准，还有第二个标准：如果是在第一个标准成立的前提下，在service文件夹里的那个javax文件里提供的那个实现了ServletainerIitializer接口的类上方<strong>加一个@HandlesTpes这个注解，在容器回调这个onStartup这个方法的时候，它会传一个Set集合给，这个set集合表示加在这个注解里面的所有的接口的实现类。</strong></p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9ah9a4obnj213a0c5aai.jpg" alt="2019-11-25_184626.png"></p><p>在这里断点断住可以看到这是springframework第一次被执行的地方。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@HandlesTypes</span><span class="token punctuation">(</span><span class="token punctuation">{</span>WebApplicationInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringServletContainerInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContainerInitializer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">SpringServletContainerInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStartup</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> webAppInitializerClasses<span class="token punctuation">,</span> ServletContext servletContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>WebApplicationInitializer<span class="token operator">></span> initializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator var4<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>webAppInitializerClasses <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            var4 <span class="token operator">=</span> webAppInitializerClasses<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>var4<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> waiClass <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span>var4<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>waiClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isAbstract</span><span class="token punctuation">(</span>waiClass<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> WebApplicationInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>waiClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        initializers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>WebApplicationInitializer<span class="token punctuation">)</span>waiClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var7<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">"Failed to instantiate WebApplicationInitializer class"</span><span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initializers<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            servletContext<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"No Spring WebApplicationInitializer types detected on classpath"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            AnnotationAwareOrderComparator<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>            servletContext<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Spring WebApplicationInitializers detected on classpath: "</span> <span class="token operator">+</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>            var4 <span class="token operator">=</span> initializers<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>var4<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                WebApplicationInitializer initializer <span class="token operator">=</span> <span class="token punctuation">(</span>WebApplicationInitializer<span class="token punctuation">)</span>var4<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                initializer<span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以会得到这个<code>WebApplicationInitializer</code>，这个<code>WebApplicationInitializer</code>有个实现类就是我们的<code>WeslyxlApplication</code>这个类。Spring5的操作方法是拿到这个集合之后会做一次for循环，把集合里面的实现类给实例化出来，实例化出来之后再放到：</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>WebApplicationInitializer<span class="token operator">></span> initializers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当中，然后循环这个list依次调用onStartup方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span>（WebApplicationInitializer initializer <span class="token operator">:</span>initializers）<span class="token punctuation">{</span>       initializer<span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础中易忽略的几点</title>
      <link href="/2019/11/24/2019/11/java%E5%9F%BA%E7%A1%80%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9/"/>
      <url>/2019/11/24/2019/11/java%E5%9F%BA%E7%A1%80%E6%98%93%E5%BF%BD%E7%95%A5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-正确使用-equals-方法"><a href="#1-1-正确使用-equals-方法" class="headerlink" title="1.1. 正确使用 equals 方法"></a>1.1. 正确使用 equals 方法</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><p>举个例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span>String str <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"SnailClimb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token string">"SnailClimb"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p></blockquote><pre><code>Objects.equals(null,&quot;SnailClimb&quot;);// false</code></pre><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object a<span class="token punctuation">,</span> Object b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894" target="_blank" rel="noopener">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如i<strong>nt默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值</strong>。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h2 id="1-2-整型包装类值的比较"><a href="#1-2-整型包装类值的比较" class="headerlink" title="1.2. 整型包装类值的比较"></a>1.2. 整型包装类值的比较</h2><blockquote><p>所有整型包装类对象值的比较必须使用equals方法。</p></blockquote><p>先看下面这个例子：</p><pre class="line-numbers language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>Integer y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。</strong>所以上述代码中，x和y引用的是相同的Integer对象。</p><p><strong>注意：</strong>如果你的IDE(IDEA/Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 ==的话会报错提示，推荐安装一个这个插件，很不错。</p><h2 id="1-3-BigDecimal"><a href="#1-3-BigDecimal" class="headerlink" title="1.3. BigDecimal"></a>1.3. BigDecimal</h2><h3 id="1-3-1-BigDecimal-的用处"><a href="#1-3-1-BigDecimal-的用处" class="headerlink" title="1.3.1. BigDecimal 的用处"></a>1.3.1. BigDecimal 的用处</h3><blockquote><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">-</span> <span class="token number">0.9f</span><span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">0.9f</span> <span class="token operator">-</span> <span class="token number">0.8f</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0.100000024</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0.099999964</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><pre class="line-numbers language-java"><code class="language-java">BigDecimal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"0.8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal x <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0.1</span>BigDecimal y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0.1</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2-BigDecimal-的大小比较"><a href="#1-3-2-BigDecimal-的大小比较" class="headerlink" title="1.3.2. BigDecimal 的大小比较"></a>1.3.2. BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示小于，0 表示 等于， 1表示 大于。</p><pre class="line-numbers language-java"><code class="language-java">BigDecimal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"java0.9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-3-BigDecimal-保留几位小数"><a href="#1-3-3-BigDecimal-保留几位小数" class="headerlink" title="1.3.3. BigDecimal 保留几位小数"></a>1.3.3. BigDecimal 保留几位小数</h3><blockquote><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p></blockquote><pre class="line-numbers language-java"><code class="language-java">BigDecimal m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.255433"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>BigDecimal n <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">setScale</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>BigDecimal<span class="token punctuation">.</span>ROUND_HALF_DOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1.255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-4-BigDecimal-的使用注意事项"><a href="#1-3-4-BigDecimal-的使用注意事项" class="headerlink" title="1.3.4. BigDecimal 的使用注意事项"></a>1.3.4. BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，<strong>推荐使用它的 BigDecimal(String) 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</strong></p><p><a href="https://camo.githubusercontent.com/b1c115758fbdca06d975ccb2ea9d948184d8478f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f426967446563696d616c2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b1c115758fbdca06d975ccb2ea9d948184d8478f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f426967446563696d616c2e706e67" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></a></p><h3 id="1-3-5-总结"><a href="#1-3-5-总结" class="headerlink" title="1.3.5. 总结"></a>1.3.5. 总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h2 id="1-4-基本数据类型与包装数据类型的使用标准"><a href="#1-4-基本数据类型与包装数据类型的使用标准" class="headerlink" title="1.4. 基本数据类型与包装数据类型的使用标准"></a>1.4. 基本数据类型与包装数据类型的使用标准</h2><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用<strong>包装数据类型</strong>。</li><li>【强制】RPC 方法的返回值和参数必须<strong>使用包装数据类型</strong>。</li><li>【推荐】所有的局部变量<strong>使用基本数据类型</strong>。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score<strong>,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样</strong>。</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h1><h2 id="2-1-Arrays-asList-使用指南"><a href="#2-1-Arrays-asList-使用指南" class="headerlink" title="2.1. Arrays.asList()使用指南"></a>2.1. Arrays.asList()使用指南</h2><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples" target="_blank" rel="noopener">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1. 简介"></a>2.1.1. 简介</h3><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><pre class="line-numbers language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span> <span class="token punctuation">}</span>； List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面两个语句等价于下面一条语句</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">,</span><span class="token string">"Banana"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>JDK 源码对于这个方法的说明：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。 */</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-2-《阿里巴巴Java-开发手册》对其的描述"><a href="#2-1-2-《阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="2.1.2. 《阿里巴巴Java 开发手册》对其的描述"></a>2.1.2. 《阿里巴巴Java 开发手册》对其的描述</h3><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><a href="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" alt="阿里巴巴Java开发手-Arrays.asList()方法"></a></p><h3 id="2-1-3-使用时的注意事项总结"><a href="#2-1-3-使用时的注意事项总结" class="headerlink" title="2.1.3. 使用时的注意事项总结"></a>2.1.3. 使用时的注意事项总结</h3><blockquote><p>传递的数组必须是对象数组，而不是基本类型。</p></blockquote><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组地址值</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//报错：ArrayIndexOutOfBoundsException</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> myList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p><strong>我们使用包装类型数组就可以解决这个问题</strong>。</p><pre class="line-numbers language-java"><code class="language-java">Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong></p></blockquote><pre class="line-numbers language-java"><code class="language-java">List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行时报错：UnsupportedOperationException</span>myList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行时报错：UnsupportedOperationException</span>myList<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行时报错：UnsupportedOperationException</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p></blockquote><pre class="line-numbers language-java"><code class="language-java">List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myList<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//class java.util.Arrays$ArrayList</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable    <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span>UnaryOperator<span class="token operator">&lt;</span>E<span class="token operator">></span> operator<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><pre><code>public E remove(int index) {    throw new UnsupportedOperationException();}</code></pre><p>可以用myList创建一个新的List，然后就可以在新的List中使用add。<strong>就是下面将的如何正确将数组转为ArrayList</strong></p><h3 id="2-1-4-如何正确的将数组转换为ArrayList"><a href="#2-1-4-如何正确的将数组转换为ArrayList" class="headerlink" title="2.1.4. 如何正确的将数组转换为ArrayList?"></a>2.1.4. 如何正确的将数组转换为ArrayList?</h3><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW" target="_blank" rel="noopener">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//JDK1.5+</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">arrayToList</span><span class="token punctuation">(</span><span class="token keyword">final</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> l <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> T s <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    l<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Integer <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">arrayToList</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//class java.util.ArrayList</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 最简便的方法(推荐)</strong></p><pre class="line-numbers language-java"><code class="language-java">List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><pre class="line-numbers language-java"><code class="language-java">Integer <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>myArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> myArray2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>List myList <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>myArray2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="noopener"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="noopener"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="noopener"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> il <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token string">"elements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// from varargs</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> il <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>aStringArray<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// from array</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="noopener"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="noopener"><code>newArrayList()</code></a>工厂方法：</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> l1 <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>anotherListOrCollection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// from collection</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> l2 <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span>aStringArray<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// from array</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> l3 <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token string">"or"</span><span class="token punctuation">,</span> <span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token string">"elements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// from varargs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>5. 使用 Apache Commons Collections</strong></p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#2-2-Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="2.2. Collection.toArray()方法使用的坑&amp;如何反转数组"></a>2.2. Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><pre class="line-numbers language-java"><code class="language-java">String <span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token string">"lazy"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"over"</span><span class="token punctuation">,</span> <span class="token string">"jumps"</span><span class="token punctuation">,</span> <span class="token string">"fox"</span><span class="token punctuation">,</span> <span class="token string">"brown"</span><span class="token punctuation">,</span> <span class="token string">"quick"</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//没有指定类型的话会报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<strong><code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型</strong>。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="noopener">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p></blockquote><h2 id="2-3-不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#2-3-不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="2.3. 不要在 foreach 循环里进行元素的 remove/add 操作"></a>2.3. 不要在 foreach 循环里进行元素的 remove/add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove</code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><a href="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对JVM一些理解</title>
      <link href="/2019/11/22/2019/11/%E7%9C%8B%E7%9C%8BJVM/"/>
      <url>/2019/11/22/2019/11/%E7%9C%8B%E7%9C%8BJVM/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 服务端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx基础总结</title>
      <link href="/2019/11/21/2019/11/Nginx%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/21/2019/11/Nginx%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>Nginx是lgor Sysoev为俄罗斯访问量第二的rambler.ru站点设计开发的。从2004年发布至今，凭借开源的力量，已经接近成熟与完善。</p><p>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。</p><p>Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p><p>Nginx进程模型模型为：<strong>1个主进程，n个工作进程</strong>，主进程负责配置和工作进程的管理，实际的请求由工作进程进行处理。Nginx是基于事件驱动和多路复用的工作模型。</p><blockquote><p>说了这么多，无非就是想表达——Nginx牛逼！！</p></blockquote><ul><li><a href="http://www.nginx.org/" target="_blank" rel="noopener">Nginx官网</a></li><li><a href="https://trac.nginx.org/nginx/browser" target="_blank" rel="noopener">Nginx源码地址</a></li></ul><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><p>做服务端经常用到Nginx做web服务器、反向代理、负载均衡，Web缓存。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。正向代理用得不是很多。</p><p>Nginx在做反向代理时，提供性能稳定，并<strong>且能够提供配置灵活的转发功能</strong>。Nginx可以根据不同的正则匹配，采取不同的转发策略，<strong>比如图片文件结尾的走文件服务器，动态页面走web服务器，只要你正则写的没问题</strong>，又有相对应的服务器解决方案，你就可以随心所欲的玩。并且Nginx对返回结果进行错误页跳转，异常判断等。<strong>如果被分发的服务器存在异常，他可以将请求重新转发给另外一台服务器，然后自动去除异常服务器</strong>。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。</p><p>内置策略为<strong>轮询，加权轮询，Ip hash</strong>。</p><p>扩展策略，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，自己实现，想做什么就做什么。</p><p>下面通过一些图示来说明：</p><p>轮询</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g98411tplqj20yt06ktdy.jpg" alt="398358-20160202133753382-1863657242.jpg"></p><p>加权轮询</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g98430qy8uj20yt06ktdy.jpg" alt="398358-20160202133753382-1863657242-1574501849494.jpg"></p><p><code>IP Hash</code>算法，对<strong>客户端请求的ip进行hash操作</strong>，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，<strong>可以解决session不共享的问题</strong>。——特别用途，解决sessoin不共享</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9843bfa4aj20yn0cxjzi.jpg" alt="398358-20160201162405944-676557632.jpg"></p><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p>web缓存平时用的不多。</p><p>Nginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持<strong>FastCGI_Cache</strong>，主要用于对FastCGI的动态程序进行缓存。配合着第三方的<strong>ngx_cache_purge</strong>，对制定的URL缓存内容可以的进行增删管理。</p><p>没用过不做过多介绍</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><blockquote><p>这里以window环境为例</p></blockquote><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">下载地址</a></p><ol><li>下载完成后，解压缩，运行cmd，使用命令进行操作，<strong>不要直接双击nginx.exe，不要直接双击nginx.exe，不要直接双击nginx.exe</strong></li></ol><blockquote><p>一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程，再启动才可以</p></blockquote><ol start="2"><li>使用命令到达nginx的加压缩后的目录</li></ol><pre><code>cd c:\nginx-1.15.2</code></pre><ol start="3"><li>启动nginx服务，启动时会一闪而过是正常的</li></ol><pre><code>start nginx</code></pre><ol start="4"><li>查看任务进程是否存在，dos或打开任务管理器都行</li></ol><pre><code>tasklist /fi &quot;imagename eq nginx.exe&quot;</code></pre><ol start="5"><li>修改配置文件，进入解压缩目录</li></ol><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9843mvt34j207h04b0sk.jpg" alt="172889-20180802095633765-1785964210.png"></p><ol start="6"><li><p>在conf目录下找到nginx.conf使用txt文本打开即可，找到server这个节点，修改端口号，如果有需求可以修改主页目录没有就不用修改.</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9843wrt4ij20i009x3yq.jpg" alt="172889-20180802100320730-1241848371.png"></p></li></ol><p>修改完成后保存，使用以下命令检查一下配置文件是否正确，后面是nginx.conf文件的路径，successful就说明正确了</p><pre><code>nginx -t -c /nginx-1.15.2/conf/nginx.conf</code></pre><ol start="7"><li><p>如果程序没启动就直接start nginx启动，如果已经启动了就使用以下命令重新加载配置文件并重启</p><pre><code>nginx -s reload</code></pre></li><li><p>关闭nginx服务使用以下命令，同样也是一闪而过是正常的，看一下是否进程已消失即可</p><p>快速停止</p><pre><code>nginx -s stop</code></pre><p>完整有序的关闭</p><pre><code>nginx -s quit</code></pre></li></ol><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><p>整个Nginx配置文件是按照全局块，event块，http块（http全局块，server块…）这样的顺序排列的</p><p>如下：</p><pre><code>...              #全局块events {         #events块   ...}http      #http块{    ...   #http全局块    server        #server块    {         ...       #server全局块        location [PATTERN]   #location块        {            ...        }        location [PATTERN]         {            ...        }    }    server    {      ...    }    ...     #http全局块}</code></pre><p>它们分别代表</p><p>1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，<strong>nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数</strong>等。</p><p>2、events块：配置影响nginx服务器或与用户的网络连接。<strong>有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化</strong>等。</p><p>3、http块：<strong>可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</strong>。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p><p>4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。</p><p>5、location块：配置请求的路由，以及各种页面的处理情况。</p><h2 id="完整事例"><a href="#完整事例" class="headerlink" title="完整事例"></a>完整事例</h2><p>上面我们只是改了一下端口，还有很多可以自定义配置。下面是结合完整的注释给给了一个完整的配置清单</p><pre><code>#user  nobody;#==工作进程数，一般设置为cpu核心数worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    #==最大连接数，一般设置为cpu*2048    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    #==客户端链接超时时间    keepalive_timeout  65;    #gzip  on;    #当配置多个server节点时，默认server names的缓存区大小就不够了，需要手动设置大一点    server_names_hash_bucket_size 512;    #server表示虚拟主机可以理解为一个站点，可以配置多个server节点搭建多个站点    #每一个请求进来确定使用哪个server由server_name确定    server {        #站点监听端口        listen       8800;        #站点访问域名        server_name  localhost;        #编码格式，避免url参数乱码        charset utf-8;        #access_log  logs/host.access.log  main;        #location用来匹配同一域名下多个URI的访问规则        #比如动态资源如何跳转，静态资源如何跳转等        #location后面跟着的/代表匹配规则        location / {            #站点根目录，可以是相对路径，也可以使绝对路径            root   html;            #默认主页            index  index.html index.htm;            #转发后端站点地址，一般用于做软负载，轮询后端服务器            #proxy_pass http://10.11.12.237:8080;            #拒绝请求，返回403，一般用于某些目录禁止访问            #deny all;            #允许请求            #allow all;            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;            add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;            add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#39;;            #重新定义或者添加发往后端服务器的请求头            #给请求头中添加客户请求主机名            proxy_set_header Host $host;            #给请求头中添加客户端IP            proxy_set_header X-Real-IP $remote_addr;            #将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #给请求头中添加客户端的Cookie            proxy_set_header Cookie $http_cookie;            #将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。            proxy_redirect off;            #浏览器对 Cookie 有很多限制，如果 Cookie 的 Domain 部分与当前页面的 Domain 不匹配就无法写入。            #所以如果请求 A 域名，服务器 proxy_pass 到 B 域名，然后 B 服务器输出 Domian=B 的 Cookie，            #前端的页面依然停留在 A 域名上，于是浏览器就无法将 Cookie 写入。　　         #不仅是域名，浏览器对 Path 也有限制。我们经常会 proxy_pass 到目标服务器的某个 Path 下，            #不把这个 Path 暴露给浏览器。这时候如果目标服务器的 Cookie 写死了 Path 也会出现 Cookie 无法写入的问题。            #设置“Set-Cookie”响应头中的domain属性的替换文本，其值可以为一个字符串、正则表达式的模式或一个引用的变量            #转发后端服务器如果需要Cookie则需要将cookie domain也进行转换，否则前端域名与后端域名不一致cookie就会无法存取　　　　　　  #配置规则：proxy_cookie_domain serverDomain(后端服务器域) nginxDomain(nginx服务器域)            proxy_cookie_domain localhost .testcaigou800.com;            #取消当前配置级别的所有proxy_cookie_domain指令            #proxy_cookie_domain off;            #与后端服务器建立连接的超时时间。一般不可能大于75秒；            proxy_connect_timeout 30;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }　　#当需要对同一端口监听多个域名时，使用如下配置，端口相同域名不同，server_name也可以使用正则进行配置　　#但要注意server过多需要手动扩大server_names_hash_bucket_size缓存区大小　　server {　　　　listen 80;　　　　server_name www.abc.com;　　　　charset utf-8;　　　　location / {　　　　　　proxy_pass http://localhost:10001;　　　　}　　}　　server {　　　　listen 80;　　　　server_name aaa.abc.com;　　　　charset utf-8;　　　　location / {　　　　　　proxy_pass http://localhost:20002;　　　　}　　}}</code></pre><h1 id="静态Web服务器"><a href="#静态Web服务器" class="headerlink" title="静态Web服务器"></a>静态Web服务器</h1><p><strong>关键配置</strong>：<strong>root</strong></p><p>Web server很重要一部分工作就是提供静态页面的访问<strong>（做http服务器，提供服务）</strong>，例如images, html page。nginx可以通过不同的配置，根据request请求，从本地的<strong>目录</strong>（由<strong>root</strong>指定，<strong>当配置了proxy_pass代理时候，nginx将不再直接提供服务，而只做请求转发）提供不同的文件返回给客户端</strong>。 </p><p>打开安装目录下的nginx.conf文件，默认配置文件已经在http指令块中创建了一个空的server块，在nginx-1.8.0中的http块中已经创建了一个默认的server块。内容如下：</p><pre><code>server {        listen       80;        server_name  localhost;        location / {            root   html;#指定访问的静态目录            index  index.html index.htm;        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        } }  </code></pre><h1 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h1><p>就是在一台服务器启动多个网站。<strong>一个server就是一个虚拟主机。</strong></p><p>如何区分不同的网站：</p><p>1、域名不同</p><p>2、端口不同</p><h2 id="通过端口区分不同虚拟机"><a href="#通过端口区分不同虚拟机" class="headerlink" title="通过端口区分不同虚拟机"></a>通过端口区分不同虚拟机</h2><p>一个server节点的虚拟主机</p><pre><code> #一个server节点就是一个虚拟主机    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {　　　　　　　#Html是nginx安装目录下的html目录(静态页面存放的位置,也可以使用绝对路径)            root   html;            index  index.html index.htm;        }    }</code></pre><p>多个server节点的虚拟主机，注意端口不同</p><pre><code>server {        listen       80;        server_name  localhost;(域名)        #charset koi8-r;        #access_log  logs/host.access.log  main;        Location / {            root   html;            index  index.html index.htm;        }    }    server {        listen       81;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-81;            index  index.html index.htm;        }    }</code></pre><p>当配置完之后，如果想要生效，必须重新加载配置文件</p><pre><code>nginx -s reload</code></pre><h2 id="通过域名区分虚拟主机"><a href="#通过域名区分虚拟主机" class="headerlink" title="通过域名区分虚拟主机"></a>通过域名区分虚拟主机</h2><p><strong>一个域名对应一个ip地址，一个ip地址可以被多个域名绑定。</strong></p><p>本地测试可以修改hosts文件。</p><blockquote><p>修改window的hosts文件：（C:\Windows\System32\drivers\etc）</p></blockquote><p>可以配置域名和ip的映射关系，如果hosts文件中配置了域名和ip的对应关系，不需要走dns服务器。</p><p>配置内容，注意这里的servername,root不一样。</p><pre><code>server {        listen       80;        server_name  www.taobao.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-taobao;            index  index.html index.htm;        }    }    server {        listen       80;        server_name  www.baidu.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-baidu;            index  index.html index.htm;        }    }</code></pre><p>在host配置ip映射的域名</p><pre><code>127.0.0.1 www.taobao.com127.0.0.1 www.baidu.com</code></pre><h1 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h1><p><strong>正向代理</strong>——结果返回给客户端</p><p><strong>（代理客户端）接收到客户端，替代客户端去完成上网，将获得的结果返回给客户端。</strong></p><p> <img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9844az1ahj20nm0b00t8.jpg" alt="1020536-20180702103303641-1782281937.png"></p><p><strong>反向代理：代理服务端）</strong>——请求转发</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g9844k14djj20ml0cbdgd.jpg" alt="1020536-20180702103410027-2005818715.png"></p><p><strong>反向代理服务器决定哪台服务器提供服务</strong>。</p><p><strong>返回代理服务器不提供服务器。只是请求的转发。</strong></p><p>一个简单的配置</p><pre><code>server {    location / {        proxy_pass http://localhost:8080/;    }    location ~ \.(gif|jpg|png)$ {        root /data/images;    }}</code></pre><p>意思就是：所有URI中以.gif, .jpg, .png结尾的请求都会被映射到/data/images本地磁盘目录，把所有其他的URI请求都传给配置的<strong>被代理的server</strong>: <a href="http://localhost:8080/。" target="_blank" rel="noopener">http://localhost:8080/。</a></p><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>该指令是反向代理的基本指令，用于设置代理服务器的协议和地址；对于一个client的请求，proxy_pass指令通过以下方式进行uri的转发： </p><ul><li>如果proxy_pass指令的参数没有URI，那么请求的URI会被原样的传递给internal server。</li><li>如果proxy_pass指令的参数含有URI，client请求的URI匹配该location的部分将会被proxy_pass的path参数替换。</li><li>例如：请求为127.0.0.1/name/index.html 会被转发为：127.0.0.1/remote/index.html</li></ul><h3 id="proxy-pass-header"><a href="#proxy-pass-header" class="headerlink" title="proxy_pass_header"></a>proxy_pass_header</h3><p>field参数是http所有的header名字，具体可以参考： [HTTP/1.1协议][1] P100 chapter14关于HTTP协议所有header field的定义。</p><h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h3><p>该指令用于将client传递给proxy server的request header重新定义或者添加字段。Value可以是文本，变量和两者结合。 如果set 的header field的值为空，那么这个header是不会传递给proxy server的</p><h2 id="一个实际的例子"><a href="#一个实际的例子" class="headerlink" title="一个实际的例子"></a>一个实际的例子</h2><p>两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。</p><p>两个域名是<a href="http://www.sian.com.cn和www.sohu.com" target="_blank" rel="noopener">www.sian.com.cn和www.sohu.com</a></p><p>nginx服务器使用虚拟机本机地址</p><p>第一步：安装两个tomcat，分别运行在8080和8081端口。</p><p>第二步：启动两个tomcat。</p><p><strong>第三步：反向代理服务器的配置</strong></p><p>复制一个server节点,<strong>将<code>root</code>改成proxy_pass，配置了proxy_pass之后服务器不提供服务器，只是请求的转发。</strong></p><h3 id="配置upstream"><a href="#配置upstream" class="headerlink" title="配置upstream"></a><strong>配置upstream</strong></h3><pre><code>    upstream tomcat1 {         server 192.168.25.148:8080;    }    server {        listen       80;        server_name  www.sina.com.cn;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            proxy_pass   http://tomcat1;            index  index.html index.htm;        }    }    upstream tomcat2 {         server 192.168.25.148:8081;    }    server {        listen       80;        server_name  www.sohu.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            proxy_pass   http://tomcat2;            index  index.html index.htm;        }    }</code></pre><h3 id="nginx重新加载配置文件"><a href="#nginx重新加载配置文件" class="headerlink" title="nginx重新加载配置文件"></a>nginx重新加载配置文件</h3><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>在hosts文件中添加域名和ip的映射关</p><p>127.0.0.1 <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></p><p>127.0.0.1 <a href="http://www.sohu.com" target="_blank" rel="noopener">www.sohu.com</a></p><h1 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡一般是和反向代理结合在一起的。一个服务由多台服务器提供，需要把负载分配到不同的服务器处理。</p><p>在upstream中定义多个服务器</p><pre><code>upstream tomcat2 {      server 192.168.25.148:8081;      server 192.168.25.148:8082;  }</code></pre><p>可以根据服务器的实际情况调整<strong>服务器权重weight</strong>。权重越高分配的请求越多，权重越低，请求越少。<strong>默认是都是1，是轮询机制。</strong></p><pre><code> upstream tomcat2 {          server 192.168.25.148:8081;          server 192.168.25.148:8082 weight=2;   }</code></pre><p>指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。</p><pre><code>   #动态服务器组    upstream dynamic_zuoyu {        ip_hash;    #保证每个访客固定访问一个后端服务器        server 192.168.25.148:8081;              server 192.168.25.148:8082 weight=2;          fail_timeout=20s;  #tomcat 9.0    }</code></pre><h2 id="负载均衡高可用"><a href="#负载均衡高可用" class="headerlink" title="负载均衡高可用"></a>负载均衡高可用</h2><p> nginx作为负载均衡器，所有请求都到了nginx（<strong>对外服务的唯一入口，唯一公网IP</strong>），可见nginx处于非常重点的位置，如果nginx服务器宕机后端web服务将无法提供服务，影响严重。</p><p> 为了屏蔽负载均衡服务器的宕机，需要建立一个备份机。<strong>主服务器和备份机上都运行高可用（High Availability）监控程序</strong>，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就<strong>接管主服务器的服务IP</strong>并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就<strong>释放服务IP地址</strong>，这样的主服务器就开始再次提供负载均衡服务。</p><blockquote><p>分布式中经常用到备份机。比如分布式的注册中心一般也是多台服务器。</p></blockquote><p>通常说的双机热备是指两台机器都在运行，但并不是两台机器都同时在提供服务。<br>当提供服务的一台出现故障的时候，另外一台会马上自动接管并且提供服务，而且切换的时间非常短。</p><blockquote><p>keepalived是集群管理中保证集群高可用的一个服务软件，用来<strong>防止单点故障</strong>。</p></blockquote><p> <strong>Keepalived的作用是检测web服务器的状态（健康监测）</strong>，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有<strong>故障</strong>的web服务器从系统中剔除，当web服务器工作<strong>正常</strong>后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。</p><h2 id="Keepalived软件原理"><a href="#Keepalived软件原理" class="headerlink" title="Keepalived软件原理"></a>Keepalived软件原理</h2><p> keepalived是以<strong>VRRP</strong>协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即<strong>虚拟路由冗余协议</strong>。</p><p> 虚拟路由冗余协议，可以认为是实现路由器高可用的协议，<strong>即将N台提供相同功能的路由器组成一个路由器组</strong>，这个组里面有<strong>一个master和多个backup</strong>，master上面有一个对外提供服务的vip（VIP = Virtual IP Address，<strong>虚拟IP地址</strong>，该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到VRRP包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。</p><p> keepalived主要有三个模块，分别是<strong>core</strong>、<strong>check</strong>和<strong>VRRP</strong>。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。VRRP模块是来实现VRRP协议的。 </p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><pre><code>nginx -s reload     #重新加载配置文件nginx -s reopen     #重新打开log文件nginx -s stop       #快速关闭nginx服务nginx -s quit       #优雅的关闭nginx服务，等待工作进程处理完所有的请求 </code></pre><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>nginx的配置由特定的标识符(指令符)分为多个不同的模块。<br>指令符分为<strong>简单指令</strong>和<strong>块指令</strong>。</p><ul><li>简单指令格式：[name parameters;]</li><li>块指令格式：和简单指令格式有一样的结构，但其结束标识符不是分号，而是大括号{},块指令内部可以包含simple directives 和block directives, 可以称块指令为上下文(e.g. events, http, server, location)</li></ul><p>conf文件中，所有不属于块指令的简单指令都属于main上下文的，http块指令属于main上下文，server块指令http上下文。</p><pre><code>...              #全局块events {         #events块   ...}http      #http块{    ...   #http全局块    server        #server块    {         ...       #server全局块        location [PATTERN]   #location块        {            ...        }        location [PATTERN]         {            ...        }    }    server    {      ...    }    ...     #http全局块}</code></pre><p>　1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</p><p>　　2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</p><p>　　3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</p><p>　　4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。</p><p>　　5、location块：配置请求的路由，以及各种页面的处理情况。</p><h3 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a><strong>一个例子：</strong></h3><pre><code>########### 每个指令必须有分号结束。##################user administrator administrators;  #配置用户或者组，默认为nobody nobody。#worker_processes 2;  #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergevents {    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport    worker_connections  1024;    #最大连接数，默认为512}http {    include       mime.types;   #文件扩展名与文件类型映射表    default_type  application/octet-stream; #默认文件类型，默认为text/plain    #access_log off; #取消服务日志        log_format myFormat &#39;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#39;; #自定义格式    access_log log/access.log myFormat;  #combined为日志格式的默认值    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。    upstream mysvr {         server 127.0.0.1:7878;      server 192.168.10.121:3333 backup;  #热备    }    error_page 404 https://www.baidu.com; #错误页    server {        keepalive_requests 120; #单连接请求上限次数。        listen       4545;   #监听端口        server_name  127.0.0.1;   #监听地址               location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。           #root path;  #根目录           #index vv.txt;  #设置默认页           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表           deny 127.0.0.1;  #拒绝的ip           allow 172.18.5.54; #允许的ip                   }     }} </code></pre><p> <strong>完整的基本配置文件如下：</strong></p><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>#运行用户user www-data;  #启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志及PID文件error_log /var/log/nginx/error.log;pid    /var/run/nginx.pid;#工作模式及连接数上限events {  use  epoll;       #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能  worker_connections 1024;#单个后台worker process进程的最大并发链接数  # multi_accept on; }#设定http服务器，利用它的反向代理功能提供负载均衡支持http {   #设定mime类型,类型由mime.type文件定义  include    /etc/nginx/mime.types;  default_type application/octet-stream;  #设定日志格式  access_log  /var/log/nginx/access.log;  #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，  #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.  sendfile    on;  #tcp_nopush   on;  #连接超时时间  #keepalive_timeout 0;  keepalive_timeout 65;  tcp_nodelay    on;  #开启gzip压缩  gzip on;  gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;  #设定请求缓冲  client_header_buffer_size  1k;  large_client_header_buffers 4 4k;  include /etc/nginx/conf.d/*.conf;  include /etc/nginx/sites-enabled/*;  #设定负载均衡的服务器列表   upstream mysvr {  #weigth参数表示权值，权值越高被分配到的几率越大  #本机上的Squid开启3128端口  server 192.168.8.1:3128 weight=5;  server 192.168.8.2:80 weight=1;  server 192.168.8.3:80 weight=6;  }  server {  #侦听80端口    listen    80;    #定义使用www.xx.com访问    server_name www.xx.com;    #设定本虚拟主机的访问日志    access_log logs/www.xx.com.access.log main;  #默认请求  location / {     root  /root;   #定义服务器的默认网站根目录位置     index index.php index.html index.htm;  #定义首页索引文件的名称     fastcgi_pass www.xx.com;     fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;      include /etc/nginx/fastcgi_params;    }  # 定义错误提示页面  error_page  500 502 503 504 /50x.html;     location = /50x.html {    root  /root;  }  #静态文件，nginx自己处理  location ~ ^/(images|javascript|js|css|flash|media|static)/ {    root /var/www/virtual/htdocs;    #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。    expires 30d;  }  #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.  location ~ \.php$ {    root /root;    fastcgi_pass 127.0.0.1:9000;    fastcgi_index index.php;    fastcgi_param SCRIPT_FILENAME /home/www/www$fastcgi_script_name;    include fastcgi_params;  }  #设定查看Nginx状态的地址  location /NginxStatus {    stub_status      on;    access_log       on;    auth_basic       &quot;NginxStatus&quot;;    auth_basic_user_file conf/htpasswd;  }  #禁止访问 .htxxx 文件  location ~ /\.ht {    deny all;  }   }}</code></pre><h3 id="负载均衡-2"><a href="#负载均衡-2" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>以上是一些基本的配置,使用Nginx最大的好处就是负载均衡</p><p>如果要使用<strong>负载均衡</strong>的话,可以修改配置http节点如下：</p><p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="img"></p><pre><code>#设定http服务器，利用它的反向代理功能提供负载均衡支持http {   #设定mime类型,类型由mime.type文件定义  include    /etc/nginx/mime.types;  default_type application/octet-stream;  #设定日志格式  access_log  /var/log/nginx/access.log;  #省略上文有的一些配置节点  #。。。。。。。。。。  #设定负载均衡的服务器列表   upstream mysvr {  #weigth参数表示权值，权值越高被分配到的几率越大  server 192.168.8.1x:3128 weight=5;#本机上的Squid开启3128端口  server 192.168.8.2x:80 weight=1;  server 192.168.8.3x:80 weight=6;  }  upstream mysvr2 {  #weigth参数表示权值，权值越高被分配到的几率越大  server 192.168.8.x:80 weight=1;  server 192.168.8.x:80 weight=6;  }  #第一个虚拟服务器  server {  #侦听192.168.8.x的80端口    listen    80;    server_name 192.168.8.x;   #对aspx后缀的进行负载均衡请求  location ~ .*\.aspx$ {     root  /root;   #定义服务器的默认网站根目录位置     index index.php index.html index.htm;  #定义首页索引文件的名称     proxy_pass http://mysvr ;#请求转向mysvr 定义的服务器列表     #以下是一些反向代理的配置可删除.     proxy_redirect off;     #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP     proxy_set_header Host $host;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     client_max_body_size 10m;  #允许客户端请求的最大单文件字节数     client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，     proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)     proxy_send_timeout 90;    #后端服务器数据回传时间(代理发送超时)     proxy_read_timeout 90;     #连接成功后，后端服务器响应时间(代理接收超时)     proxy_buffer_size 4k;       #设置代理服务器（nginx）保存用户头信息的缓冲区大小     proxy_buffers 4 32k;        #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置     proxy_busy_buffers_size 64k;  #高负荷下缓冲大小（proxy_buffers*2）     proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传    }   }}</code></pre><h3 id="server指令"><a href="#server指令" class="headerlink" title="server指令"></a>server指令</h3><p>通常情况下，conf文件存在<strong>多个</strong>server块，<strong>一个server就是一个虚拟主机</strong>，通过<strong>listen的端口(默认是80端口)和server_name进行区分, 对不同的请求提供不同的服务</strong>，如下：</p><pre><code>server {    listen      80;    server_name a.example.org;    ...}</code></pre><p><strong>listen指令的参数</strong>：可以是ip, hostname, ip/hostname:port, port, UNIX-domain socket.例如：</p><pre><code>listen 127.0.0.1:8000;listen 127.0.0.1;listen 8000;listen *:8000;listen localhost:8000;listen unix:/var/run/nginx.sock;</code></pre><p> server块内部的listen和server_name不能和其他server块的完全相同，否则启动加载配置的时候会出错：</p><p>当nginx决定了哪一个server处理客户端请求后，<strong>nginx会解析request header中URI(这里以及后面提到的大部分都是指相对URI)，然后匹配server块中的location指令的参数，</strong>匹配规则下一节会介绍。例如下例：</p><pre><code>server {        listen       80;        server_name  localhost;        location / {            root   html;            index  index.html index.htm;        }}  </code></pre><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote><p>用于匹配client请求uri的path部分，<strong>然后对不同的请求提供不同的静态内容，或者通过反向代理重定向到内部的server</strong>。</p><p>对于client的request， nginx会进行<strong>预处理</strong>，nginx首先对采用 ’%XX’(uri采用%+十六进制格式用于在浏览器和插件中显示非标准的字母和字符) 格式文本编码的uri进行解码。然后处理path中的相对路径符号’.’和‘..’，然后对于含有两个及以上的’/’压缩成一个’/’。 这样处理完后会得到一个<strong>干净的path</strong>，然后会用这个path会在server的location指令的参数进行匹配。</p><pre><code>location 语法：    location [ = | ~ | ~* | ^~ ] uri { ... }    location @name { ... }</code></pre><p>location指令的参数：</p><ul><li><ul><li><p>可以是一个前缀字符串</p><p>，参数修饰符分为： </p><ul><li>无任何修饰符；</li><li>“=” 修饰符：定义一个精确匹配，匹配是精确匹配优先级最高；</li><li>“^~” 修饰符：对应的参数作为最长字符串匹配到后，不会继续去搜索参数为正则表达式的location</li></ul></li><li><p>也可以是一个正则表达式</p><p>，参数修饰符分为： </p><ul><li>”~” 修饰符： location参数部分<strong>大小写敏感</strong>；</li><li>“~*” 修饰符：location参数部分大小写不敏感；</li></ul></li></ul></li></ul></blockquote><p><strong>location块指令会用其参数与客户端请求的URI进行匹配，匹配的URI请求会被定向到root指令定义的特殊本地文件系统目录中，重定向规则</strong>为：<strong>将URI添加到root参数后面，生成一个本地文件路径，即：root参数 + URI请求</strong>。这里示例<strong>参数”/”会匹配所有的请求</strong>，一般都会默认存在。示例定位后的目录为<strong>html/</strong>，默认是定位到安装目录的路径下的html/（<strong>相对路径</strong>）。这里location块指令内部的两个简单指令的含义是：</p><ul><li><strong>root</strong> 指定重定向后uri的资源查找路径，这里html为相对路径，相对于nginx的安装目录。</li><li><strong>index</strong> 指定首页index文件的名称，可以配置多个，参数以空格分开，按配置顺序查找。</li></ul><p>如果有<strong>多个location</strong>指令块<strong>匹配</strong>到，<strong>nginx的选择策略是the longest prefix最长前缀匹配原则</strong>。<br>例如，当上述的server中再增加一个location块，匹配参数为”/htdocs/”，重定向的资源路径为如下配置，</p><pre><code>server {        listen       80;        server_name  localhost;        location / {            root   html;            index  index.html index.htm;        }        location /htdocs {            root   /home/anonymalias;            index  index.html;        }</code></pre><p>高可用具体实现可以参考这里：<a href="https://blog.csdn.net/u012453843/article/details/69668663" target="_blank" rel="noopener">nginx和keepalived实现nginx高可用</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于Nginx在服务端的用法上面基本介绍完了。web静态服务器、反向代理、负载均衡等。</p><p>每个部分其实还可以深入的了解，比如负载均衡中涉及到高可用，Nginx负载均衡中4层代理和7层代理对比等等。这些部分可以同学可以去找相关资料自行学习。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p> <a href="https://blog.csdn.net/qq_29677867/article/details/90112120" target="_blank" rel="noopener">死磕nginx系列–Nginx</a></p><p><a href="https://www.cnblogs.com/arjenlee/p/9243218.html#auto_id_14" target="_blank" rel="noopener">Nginx学习笔记</a></p><p><a href="https://blog.csdn.net/u012453843/article/details/69668663" target="_blank" rel="noopener">nginx和keepalived实现nginx高可用</a></p><p><a href="https://www.cnblogs.com/arjenlee/p/9256835.html" target="_blank" rel="noopener">Nginx负载均衡高可用</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka 的工作原理以及它与 ZooKeeper 的区别</title>
      <link href="/2019/11/20/2019/11/Eureka%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%B8%8E%20ZooKeeper%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/11/20/2019/11/Eureka%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%B8%8E%20ZooKeeper%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Eureka-简介："><a href="#1、Eureka-简介：" class="headerlink" title="1、Eureka 简介："></a><strong>1、Eureka 简介：</strong></h1><p><strong>Eureka 是 Netflix 出品的用于实现服务注册和发现的工具。 Spring Cloud 集成了 Eureka，并提供了开箱即用的支持。其中， Eureka 又可细分为 Eureka Server 和 Eureka Client。</strong></p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g96unc3iscj20hu0b3dir.jpg" alt="1319802-20180413161142132-77449828.png"></p><h1 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h1><p>上图是来自 eureka 的官方架构图，这是基于集群配置的 eureka；</p><ul><li>处于不同节点的 eureka 通过 Replicate 进行数据同步 </li><li>Application Service 为服务提供者 </li><li>Application Client 为服务消费者 </li><li>Make Remote Call 完成一次服务调用</li></ul><p>服务启动后向 Eureka 注册，Eureka Server 会将注册信息向其他 Eureka Server 进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p><p>当服务注册中心 Eureka Server 检测到服务提供者因为宕机、网络原因不可用时，则在服务注册中心将服务置为<code>DOWN</code>状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。</p><p>服务提供者在启动后，周期性（默认 30 秒）向 Eureka Server 发送心跳，以证明当前服务是可用状态。Eureka Server 在一定的时间（默认 90 秒）未收到客户端的心跳，则认为服务宕机，注销该实例。</p><h1 id="2-Eureka-的自我保护机制"><a href="#2-Eureka-的自我保护机制" class="headerlink" title="2.Eureka 的自我保护机制"></a>2.Eureka 的自我保护机制</h1><p>在默认配置中，Eureka Server 在默认 90s 没有得到客户端的心跳，则注销该实例，但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，但是因为网络分区故障时，Eureka Server 注销服务实例则会让大部分微服务不可用，这很危险，因为服务明明没有问题。</p><p>为了解决这个问题，Eureka 有自我保护机制，通过在 Eureka Server 配置如下参数，可启动保护机制</p><pre><code>eureka.server.enable-self-preservation=true</code></pre><p>它的原理是，当 Eureka Server 节点在短时间内丢失过多的客户端时（可能发送了网络故障），那么这个节点将进入自我保护模式，不再注销任何微服务，当网络故障回复后，该节点会自动退出自我保护模式。</p><p>自我保护模式的架构哲学是<code>宁可放过一个，决不可错杀一千</code></p><h1 id="3-作为服务注册中心，Eureka-比-Zookeeper-好在哪里"><a href="#3-作为服务注册中心，Eureka-比-Zookeeper-好在哪里" class="headerlink" title="3. 作为服务注册中心，Eureka 比 Zookeeper 好在哪里"></a>3. 作为服务注册中心，Eureka 比 Zookeeper 好在哪里</h1><p>著名的 CAP 理论指出，一个分布式系统不可能同时满足 C(一致性)、A(可用性) 和 P(分区容错性)。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在 A 和 C 之间进行权衡。在此 Zookeeper 保证的是 CP, 而 Eureka 则是 AP。</p><h2 id="3-1-Zookeeper-保证-CP"><a href="#3-1-Zookeeper-保证-CP" class="headerlink" title="3.1 Zookeeper 保证 CP"></a>3.1 Zookeeper 保证 CP</h2><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接 down 掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是 zk 会出现这样一种情况，当 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举。问题在于，选举 leader 的时间太长，30 ~ 120s, 且选举期间整个 zk 集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得 zk 集群失去 master 节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><h2 id="3-2-Eureka-保证-AP"><a href="#3-2-Eureka-保证-AP" class="headerlink" title="3.2 Eureka 保证 AP"></a>3.2 Eureka 保证 AP</h2><p>Eureka 看明白了这一点，因此在设计时就优先保证可用性。Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka 的客户端在向某个 Eureka 注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台 Eureka 还在，就能保证注册服务可用 (保证可用性)，只不过查到的信息可能不是最新的 (不保证强一致性)。除此之外，Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： </p><ol><li>Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 </li><li>Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上 (即保证当前节点依然可用) </li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ol><p>因此， Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像 zookeeper 那样使整个注册服务瘫痪。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>Eureka 作为单纯的服务注册中心来说要比 zookeeper 更加 “专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。不过 Eureka 目前 1.X 版本的实现是基于 servlet 的 <a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java </a>web 应用，它的极限性能肯定会受到影响。期待正在开发之中的 2.X 版本能够从 servlet 中独立出来成为单独可部署执行的服务。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础备忘录笔记</title>
      <link href="/2019/11/20/2019/11/Sql%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/11/20/2019/11/Sql%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><pre class="line-numbers language-shell"><code class="language-shell"># 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class="line-numbers language-mysql"><code class="language-mysql">-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet (    name VARCHAR(20),    owner VARCHAR(20),    species VARCHAR(20),    sex CHAR(1),    birth DATE,    death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);-- 修改数据UPDATE pet SET name = 'squirrel' where owner = 'Diane';-- 删除数据DELETE FROM pet where name = 'squirrel';-- 删除表DROP TABLE myorder;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user (    id INT,    name VARCHAR(20),    password VARCHAR(20),    PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 建表时创建唯一主键CREATE TABLE user (    id INT,    name VARCHAR(20),    UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user (    id INT,    name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 (    id INT,    name VARCHAR(20),    age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 班级CREATE TABLE classes (    id INT PRIMARY KEY,    name VARCHAR(20));-- 学生表CREATE TABLE students (    id INT PRIMARY KEY,    name VARCHAR(20),    -- 这里的 class_id 要和 classes 中的 id 字段相关联    class_id INT,    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值    FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p><p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 订单表CREATE TABLE myorder (    product_id INT,    customer_id INT,    product_name VARCHAR(20),    customer_name VARCHAR(20),    PRIMARY KEY (product_id, customer_id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p><p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE product (    id INT PRIMARY KEY,    name VARCHAR(20));CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT,    customer_phone VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20),    phone VARCHAR(15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p><h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE, -- 生日    class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE,    profession VARCHAR(20) NOT NULL, -- 职称    department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    t_no VARCHAR(20) NOT NULL, -- 教师编号    -- 表示该 tno 来自于 teacher 表中的 no 字段值    FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score (    s_no VARCHAR(20) NOT NULL, -- 学生编号    c_no VARCHAR(20) NOT NULL, -- 课程号    degree DECIMAL,    -- 成绩    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值    FOREIGN KEY(s_no) REFERENCES student(no),        FOREIGN KEY(c_no) REFERENCES course(no),    -- 设置 s_no, c_no 为联合主键    PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');-- 添加教师表数据INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');-- 添加课程表数据INSERT INTO course VALUES('3-105', '计算机导论', '825');INSERT INTO course VALUES('3-245', '操作系统', '804');INSERT INTO course VALUES('6-166', '数字电路', '856');INSERT INTO course VALUES('9-888', '高等数学', '831');-- 添加添加成绩表数据INSERT INTO score VALUES('103', '3-105', '92');INSERT INTO score VALUES('103', '3-245', '86');INSERT INTO score VALUES('103', '6-166', '85');INSERT INTO score VALUES('105', '3-105', '88');INSERT INTO score VALUES('105', '3-245', '75');INSERT INTO score VALUES('105', '6-166', '79');INSERT INTO score VALUES('109', '3-105', '76');INSERT INTO score VALUES('109', '3-245', '68');INSERT INTO score VALUES('109', '6-166', '81');-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><pre class="line-numbers language-mysql"><code class="language-mysql">-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 "并且"SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree > 60 AND degree < 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class = '95031' or sex = '女';-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 "95031" 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class = '95031';-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);--  排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no = '3-105';SELECT AVG(degree) FROM score WHERE c_no = '3-245';SELECT AVG(degree) FROM score WHERE c_no = '6-166';-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     85.3333 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) >= 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，"%" 是一个通配符，匹配 "3" 后面的任意字符。AND c_no LIKE '3%';-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) >= 2 AND c_no LIKE '3%';+-------+-------------+----------+| c_no  | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 |     85.3333 |        3 || 3-245 |     76.3333 |        3 |+-------+-------------+----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT no, name FROM student;+-----+-----------+| no  | name      |+-----+-----------+| 101 | 曾华      || 102 | 匡明      || 103 | 王丽      || 104 | 李军      || 105 | 王芳      || 106 | 陆军      || 107 | 王尼玛    || 108 | 张全蛋    || 109 | 赵铁柱    |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p><p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后查询 <code>course</code> 表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no = course.no;+------+-----------------+--------+| s_no | c_name          | degree |+------+-----------------+--------+| 103  | 计算机导论      |     92 || 105  | 计算机导论      |     88 || 109  | 计算机导论      |     76 || 103  | 操作系统        |     86 || 105  | 操作系统        |     75 || 109  | 操作系统        |     68 || 103  | 数字电路        |     85 || 105  | 数字电路        |     79 || 109  | 数字电路        |     81 |+------+-----------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p><p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p><p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 课程表SELECT no, name FROM course;+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+-- 由于字段名存在重复，使用 "表名.字段名 as 别名" 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO = score.s_noAND score.c_no = course.no;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p><p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031')GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     82.0000 || 3-245 |     71.5000 || 6-166 |     80.0000 |+-------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p><p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = '3-105'AND degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p><p>首先找到教师编号：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT NO FROM teacher WHERE NAME = '张旭'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 <code>sourse</code> 表找到该教师课程号：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过筛选出的课程号查询成绩表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE t_no = (         SELECT no FROM teacher WHERE NAME = '张旭'     ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p><p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no  | name   |+-----+--------+| 804 | 李诚   || 825 | 王萍   || 831 | 刘冰   || 856 | 张旭   |+-----+--------+SELECT name FROM teacher WHERE no IN (    -- 在这里找到对应的条件);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看和教师编号有有关的表的信息：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no    | name            | t_no |+-------+-----------------+------+| 3-105 | 计算机导论      | 825  || 3-245 | 操作系统        | 804  || 6-166 | 数字电路        | 856  || 9-888 | 高等数学        | 831  |+-------+-----------------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES ('101', '3-105', '90');INSERT INTO score VALUES ('102', '3-105', '91');INSERT INTO score VALUES ('104', '3-105', '89');-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5;+-------+| c_no  |+-------+| 3-105 |+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT t_no FROM course WHERE no IN (    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5);+------+| t_no |+------+| 825  |+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT name FROM teacher WHERE no IN (    -- 最终条件    SELECT t_no FROM course WHERE no IN (        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5    ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p><p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 通过 teacher 表查询所有 `计算机系` 的教师编号SELECT no, name, department FROM teacher WHERE department = '计算机系'+-----+--------+--------------+| no  | name   | department   |+-----+--------+--------------+| 804 | 李诚   | 计算机系     || 825 | 王萍   | 计算机系     |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN (    SELECT no FROM teacher WHERE department = '计算机系');+-------+| no    |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN (    SELECT no FROM course WHERE t_no IN (        SELECT no FROM teacher WHERE department = '计算机系'    ));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 || 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '电子工程系')-- 合并两个集UNIONSELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '计算机系');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = '3-105';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+SELECT * FROM score WHERE c_no = '3-245';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no = '3-105' AND degree > ANY(    SELECT degree FROM score WHERE c_no = '3-245') ORDER BY degree DESC;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 102  | 3-105 |     91 || 101  | 3-105 |     90 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no = '3-105' AND degree > ALL(    SELECT degree FROM score WHERE c_no = '3-245');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     87.6667 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+|     90 ||     91 ||     92 ||     86 ||     85 ||     89 ||     88 ||     75 ||     79 ||     76 ||     68 ||     81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree < (    (SELECT AVG(degree) FROM score b WHERE a.c_no = b.c_no));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name   | department      |+--------+-----------------+| 李诚   | 计算机系        || 王萍   | 计算机系        || 刘冰   | 电子工程系      || 张旭   | 电子工程系      |+--------+-----------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) > 1;+-------+| class |+-------+| 95033 || 95031 |+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- NOT: 取反-- LIKE: 模糊查询mysql> SELECT * FROM student WHERE name NOT LIKE '王%';+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name      | age  |+-----------+------+| 曾华      |   42 || 匡明      |   44 || 王丽      |   43 || 李军      |   43 || 王芳      |   44 || 陆军      |   45 || 王尼玛    |   43 || 张全蛋    |   44 || 赵铁柱    |   45 || 张飞      |   45 |+-----------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01    | 1974-06-03    |+---------------+---------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 110 | 张飞      | 男  | 1974-06-03 | 95038 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 101 | 曾华      | 男  | 1977-09-01 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 102 | 匡明      | 男  | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男');+-------+--------------+------+| no    | name         | t_no |+-------+--------------+------+| 3-245 | 操作系统     | 804  || 6-166 | 数字电路     | 856  |+-------+--------------+------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name = '李军';+-----+| sex |+-----+| 男  |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军');+-----------+-----+| name      | sex |+-----------+-----+| 曾华      | 男  || 匡明      | 男  || 李军      | 男  || 陆军      | 男  || 王尼玛    | 男  || 张全蛋    | 男  || 赵铁柱    | 男  || 张飞      | 男  |+-----------+-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT name, sex, class FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军') AND class = (    SELECT class FROM student WHERE name = '李军');+-----------+-----+-------+| name      | sex | class |+-----------+-----+-------+| 曾华      | 男  | 95033 || 李军      | 男  | 95033 || 王尼玛    | 男  | 95033 |+-----------+-----+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p><p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE name = '计算机导论') AND s_no IN (    SELECT no FROM student WHERE sex = '男');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 104  | 3-105 |     89 || 109  | 3-105 |     76 |+------+-------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE grade (    low INT(3),    upp INT(3),    grade char(1));INSERT INTO grade VALUES (90, 100, 'A');INSERT INTO grade VALUES (80, 89, 'B');INSERT INTO grade VALUES (70, 79, 'C');INSERT INTO grade VALUES (60, 69, 'D');INSERT INTO grade VALUES (0, 59, 'E');SELECT * FROM grade;+------+------+-------+| low  | upp  | grade |+------+------+-------+|   90 |  100 | A     ||   80 |   89 | B     ||   70 |   79 | C     ||   60 |   69 | D     ||    0 |   59 | E     |+------+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p><p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no  | grade |+------+-------+-------+| 101  | 3-105 | A     || 102  | 3-105 | A     || 103  | 3-105 | A     || 103  | 3-245 | B     || 103  | 6-166 | B     || 104  | 3-105 | B     || 105  | 3-105 | B     || 105  | 3-245 | C     || 105  | 6-166 | C     || 109  | 3-105 | C     || 109  | 3-245 | D     || 109  | 6-166 | B     |+------+-------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE DATABASE testJoin;CREATE TABLE person (    id INT,    name VARCHAR(20),    cardId INT);CREATE TABLE card (    id INT,    name VARCHAR(20));INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');SELECT * FROM card;+------+-----------+| id   | name      |+------+-----------+|    1 | 饭卡      ||    2 | 建行卡    ||    3 | 农行卡    ||    4 | 工商卡    ||    5 | 邮政卡    |+------+-----------+INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);SELECT * FROM person;+------+--------+--------+| id   | name   | cardId |+------+--------+--------+|    1 | 张三   |      1 ||    2 | 李四   |      3 ||    3 | 王五   |      6 |+------+--------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<code>card</code> 的整张表被连接到了右边。</p></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      |+------+--------+--------+------+-----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p><p>比如我们的银行转账：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- a -> -100UPDATE user set money = money - 100 WHERE name = 'a';-- b -> +100UPDATE user set money = money + 100 WHERE name = 'b';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p><p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p><h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            1 |+--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p><p>什么是回滚？举个例子：</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE DATABASE bank;USE bank;CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20),    money INT);INSERT INTO user VALUES (1, 'a', 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p><p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 关闭自动提交SET AUTOCOMMIT = 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            0 |+--------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将自动提交关闭后，测试数据回滚：</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO user VALUES (2, 'b', 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO user VALUES (2, 'b', 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>总结</strong></p><ol><li><p><strong>自动提交</strong></p><ul><li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p></li><li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p></li></ul></li><li><p><strong>手动提交</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p></li><li><p><strong>事务回滚</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p></li></ol></blockquote><p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 转账UPDATE user set money = money - 100 WHERE name = 'a';-- 到账UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p><h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p><pre class="line-numbers language-mysql"><code class="language-mysql">BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p><ul><li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li><li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li><li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li><li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li></ul><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p><ol><li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p><p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p></li><li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p><p>只能读取到其他事务<strong>已经提交的数据</strong>。</p></li><li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p><p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p></li><li><p><strong>SERIALIZABLE ( 串行化 )</strong></p><p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p></li></ol><p>查看当前数据库的默认隔离级别：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改隔离级别：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p><pre class="line-numbers language-mysql"><code class="language-mysql">INSERT INTO user VALUES (3, '小明', 1000);INSERT INTO user VALUES (4, '淘宝店', 1000);SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p><h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED                 |+--------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, 'c', 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+|  820.0000  |+------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 小张 - 成都</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 小王 - 北京</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 小张 - 成都</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p><p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span class="token operator">|</span> id <span class="token operator">|</span> name      <span class="token operator">|</span> money <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">a</span>         <span class="token operator">|</span>   <span class="token number">900</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">b</span>         <span class="token operator">|</span>  <span class="token number">1100</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> 小明      <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> 淘宝店    <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">c</span>         <span class="token operator">|</span>   <span class="token number">100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p><p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p><pre class="line-numbers language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE                   |+--------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是拿小张和小王来举例：</p><pre class="line-numbers language-mysql"><code class="language-mysql">-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 ||  6 | d         |  1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, '王小花', 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p><p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot杂记</title>
      <link href="/2019/11/13/2019/11/SpringBoot%E6%9D%82%E8%AE%B0/"/>
      <url>/2019/11/13/2019/11/SpringBoot%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot多环境切换"><a href="#SpringBoot多环境切换" class="headerlink" title="SpringBoot多环境切换"></a>SpringBoot多环境切换</h1><p>SpringBoot的配置文件有两种一种是properties，另一种是yml。这两种都可以实现配置，官方推荐用yml的方式。二者内容都是一样，properties用点语法表示下一级，而yml是用换行，空格来表示下一级。</p><p>properties</p><pre><code>server.port=8888</code></pre><p>ym;</p><pre><code>server:  port: 8088</code></pre><h2 id="非Maven打包"><a href="#非Maven打包" class="headerlink" title="非Maven打包"></a>非Maven打包</h2><p>如果要定义多个环境的切换，需要保留一个根配置，多个子配置。根配置文件是applicatoin.properties（或者application.yml原理都是一样）。子配置是多个，一般有如下几个：</p><ul><li><p>开发环境（dev)：开发环境是指的是咱们本地跑的环境。</p></li><li><p>测试环境(qa)：一般是克隆一份生产环境的配置，qa即test。</p></li><li><p>生产环境（prod）正式提供对外服务的，即是真实环境。</p></li></ul><p>那么就需要创建3个配置文件</p><ol><li>application.properties：根文件，用于确定激活的是哪个配置，通过spring.profiles.active=dev标识，这里的dev就是激活后面带有dev的文件</li><li>application-dev.properties：开发配置</li><li>application-pro.properties：线上配置</li></ol><p>这里的application.properties是根配置，负责确定最终用哪一个环境。如果没有<code>spring.profiles.active</code>这个值。那么默认就是它自己。</p><blockquote><p>一般情况下在application.properties配置所有环境中不变的内容。不同的部分在各个子配置文件里面去实现。</p></blockquote><h2 id="Maven打包时切换"><a href="#Maven打包时切换" class="headerlink" title="Maven打包时切换"></a>Maven打包时切换</h2><p>Maven打包的时候需要将配置添加到pom文件中。具体来讲就是：</p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">></span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>prod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">></span></span>prod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>profile与build同级，<code>activation</code>表示的是可以用这样的命令来触发profile，<code>true</code>表示dev是默认的profile, 这样本地直接ide启动项目的时候就是连接的dev环境。</p><p>还需要添加filter，filter在build内部</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filters</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>        src/main/resources/application-${env}.properties    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filters</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个完整的例子：</p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- Java编译插件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.6.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filters</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>                src/main/resources/application-${env}.properties            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filters</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">></span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>prod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">></span></span>prod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在application.properties中添加<code>spring.profiles.active=@env@</code>。用env表示环境变量。就如同上面在filter中设置的一样。</p><p>接下来使用maven命令打包就可以了</p><pre><code>mvn clean package -P dev -D maven.test.skip=true</code></pre><p>其中<code>-D maven.test.skip=true</code>表示不执行测试用例，也不编译测试用例类。</p><p>这样打出来得jar就是对应环境的jar了。<strong>特别注意要让哪个环境生效就在哪个profile中设置激活即可。</strong></p><h1 id="SpringBoot-自定义Banner"><a href="#SpringBoot-自定义Banner" class="headerlink" title="SpringBoot 自定义Banner"></a>SpringBoot 自定义Banner</h1><p>在研究一些SpringBoot 开源项目的时候，经常看到在启动项目的时候，终端显示一些与众不同的Banner。感觉挺好玩的，其实自己实现起来也不难。下面就开始介绍如何自定义Banner。</p><h2 id="准备banner"><a href="#准备banner" class="headerlink" title="准备banner"></a>准备banner</h2><p>banner文件是一个txt文件，所以显示的内容是由文件内容决定的。比如想显示个性化的内容就需要先就内容转换为字符。</p><p>这里推荐几个可以将文字，图片转换字符的网站</p><ul><li><a href="http://www.network-science.de/ascii/" target="_blank" rel="noopener">将文字转换为字符——http://www.network-science.de/ascii/</a></li><li><a href="https://www.degraeve.com/img2txt.php" target="_blank" rel="noopener">将图片转换为字符——https://www.degraeve.com/img2txt.php</a></li></ul><p>生成字符之后，在项目的<code>resource</code>下面建立一个名为<code>banner.txt</code>的文件，然后把内容复制到文件中即可。</p><pre><code> __      __              .__                .__   /  \    /  \ ____   _____|  | ___.__.___  __|  |  \   \/\/   // __ \ /  ___/  |&lt;   |  |\  \/  /  |   \        /\  ___/ \___ \|  |_\___  | &gt;    &lt;|  |__  \__/\  /  \___  &gt;____  &gt;____/ ____|/__/\_ \____/       \/       \/     \/     \/           \/</code></pre><h2 id="设置其他属性：颜色"><a href="#设置其他属性：颜色" class="headerlink" title="设置其他属性：颜色"></a>设置其他属性：颜色</h2><p>还可以设置banner的其他属性，具体实现方法就是在banner文件添加如下一些值</p><pre><code>${AnsiColor.BRIGHT_RED}：设置控制台中输出内容的颜色</code></pre><p>除了在banner.txt文件中设置，还可以在配置文件中设置。<a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">设置的官网教程</a></p><pre><code># BANNERspring.banner.charset=UTF-8 # Banner file encoding.spring.banner.location=classpath:banner.txt # Banner text resource location.spring.banner.image.location=classpath:banner.gif # Banner image file location (jpg or png can also be used).spring.banner.image.width=76 # Width of the banner image in chars.spring.banner.image.height= # Height of the banner image in chars (default based on image height).spring.banner.image.margin=2 # Left hand image margin in chars.spring.banner.image.invert=false # Whether images should be inverted for dark terminal themes.</code></pre><h2 id="关闭banner"><a href="#关闭banner" class="headerlink" title="关闭banner"></a>关闭banner</h2><p>banner<strong>默认开启</strong>，除此之外我们还可以关闭它。有以下两种方式：</p><ol><li>在启动的main方法中设置关闭，加上<code>springApplication.setBannerMode(Banner.Mode.OFF);</code>这句话</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 启动主类，springboot的入口 * springboot 默认扫描的类是在启动类的当前包和下级包 */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootWebsocketSpringdataJpaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication springApplication <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span>SpringbootWebsocketSpringdataJpaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Banner.Mode.OFF 关闭</span>        springApplication<span class="token punctuation">.</span><span class="token function">setBannerMode</span><span class="token punctuation">(</span>Banner<span class="token punctuation">.</span>Mode<span class="token punctuation">.</span>OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>        springApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>在idea中关闭如下图所示</li></ol><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g977sdu17aj20jp05o74d.jpg" alt="2019-11-22_230134.png"></p><h1 id="常见基础知识点"><a href="#常见基础知识点" class="headerlink" title="常见基础知识点"></a>常见基础知识点</h1><p>SpringBoot太多太多内容了，这里记录一下平时觉得有意识的东西。</p><h2 id="SpringBoot——-PathVariable，-RequestParam详解"><a href="#SpringBoot——-PathVariable，-RequestParam详解" class="headerlink" title="SpringBoot——@PathVariable，@RequestParam详解"></a>SpringBoot——@PathVariable，@<strong>RequestParam</strong>详解</h2><blockquote><p>1、当URL指向的是某一具体业务资源（或资源列表），例如博客，用户时，使用@PathVariable</p><p>2、当URL需要对资源或者资源列表进行过滤，筛选时，用@RequestParam</p></blockquote><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><blockquote><p>URL变量</p></blockquote><p>Web应用中的URL通常不是一成不变的，例如微博两个不同用户的个人主页对应两个不同的URL：<a href="http://weibo.com/user1和[http://weibo.com/user2](http://weibo.com/user1)。我们不能对于每一个用户都编写一个被@RequestMapping注解的方法来处理其请求，也就是说，对于相同模式的URL（例如不同用户的主页，他们仅仅是URL中的某一部分不同，为他们各自的用户名，我们说他们具有相同的模式）。" target="_blank" rel="noopener">http://weibo.com/user1和[http://weibo.com/user2](http://weibo.com/user1)。我们不能对于每一个用户都编写一个被@RequestMapping注解的方法来处理其请求，也就是说，对于相同模式的URL（例如不同用户的主页，他们仅仅是URL中的某一部分不同，为他们各自的用户名，我们说他们具有相同的模式）。</a></p><blockquote><p>定义URL变量规则</p></blockquote><p>可以在@RequestMapping注解中用{ }来表明它的变量部分，例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user/{username}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的{username}就是我们定义的变量规则，username是变量的名字，那么这个URL路由可以匹配下列任意URL并进行处理：</p><ul><li>/user/Tom</li><li>/user/Jerry</li><li>/user/Jack2</li></ul><p>需要注意的是，在默认情况下，变量中不可以包含URL的分隔符/，例如路由不能匹配/user/Denny/Jon，即使你认为Denny/Jon是一个存在的用户名。</p><blockquote><p>获取URL变量</p></blockquote><p>在路由中定义变量规则后，通常我们需要在处理方法（也就是@RequestMapping注解的方法）中获取这个URL的具体值，并根据这个值（例如用户名）做相应的操作，SpringMVC提供的@PathVariable可以帮助我们：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user/{username}"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> String <span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"username"</span><span class="token punctuation">)</span> String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"user"</span><span class="token operator">+</span>username<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，当@Controller处理HTTP请求时，userProfile的参数username会自动设置为URL中对应变量username（同名赋值）的值。例如，当HTTP请求为/user/fpc，URL变量username的值fpc就会被赋值给函数参数username，函数的返回值是userfpc。</p><p>在默认情况下，Spring会对@PathVariable注解的变量进行自动赋值，也可以指定@PathVariable使用哪一个URL中的变量：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"user/{username}"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> String <span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"username"</span><span class="token punctuation">)</span> String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"user"</span><span class="token operator">+</span>username<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>请求url：<code>localhost:8089/users/fpc</code></p><p>返回结果：userfpc</p><p>请求url：<code>localhost:8089/users/abcdfpc</code></p><p>返回结果：userabcdfpc</p><p><img src="https://img-blog.csdnimg.cn/20181213085745718.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ExNTAyODU5NjMzOA==,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>定义多个URL变量 </p></blockquote><p> 可以定义URL路由，其中包含多个URL变量：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/user/{username}/blog/{blogId}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getUserBlog</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String username<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> <span class="token keyword">int</span> blogId<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"user:"</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">"blog->"</span> <span class="token operator">+</span> blogId<span class="token punctuation">;</span>                                                                          <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 这种情况下，Spring能够根据名字自动赋值对应的函数参数值，当然也可以在@PathVariable中显示地表明具体的URL变量值。</p><p>在默认情况下，@PathVariable注解的参数可以是一些基本的简单类型：int，long，Date，String等，Spring能够根据URL变量的具体值及函数参数类型来进行转换。例如/user/fpc/blog/1，会将fpc的值赋给username，而1赋给int变量blogId。</p><p>请求url：<code>localhost:8089/users/fpc/blog/2</code></p><p>返回结果：user:fpcblog-&gt;2</p><blockquote><p>匹配正则表达式</p></blockquote><p> 很多时候，需要对URL变量进行更加精确的定义。例如，用户名只可能包含大小写字母，数字，下划线，我们希望：</p><ul><li>/user/fpc是一个合法的URL</li><li><code>/user/#$$$</code>则是一个不合法的URL</li></ul><p>除了简单地定义{username}变量，还可以定义正则表达式进行更精确地控制，定义语法是{变量名: 正则表达式}。[a-zA-Z0-9_]+是一个正则表达式，表示只能包含小写字母，大写字母，数字，下划线。如此设置URL变量规则后，不合法的URL则不会被处理，直接由SpringMVC框架返回404NotFound。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/user/{username: [a-zA-Z0-9]+}/blog/{blogId}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="SpringBoot——-RequestParam"><a href="#SpringBoot——-RequestParam" class="headerlink" title="SpringBoot——@RequestParam"></a>SpringBoot——@RequestParam</h3><blockquote><p>Request参数</p></blockquote><p> 在访问各种各样的网站时，经常会发现网站的URL的最后一部分形如：?xx=yy&amp;zz=ww。这就是HTTP协议中的Request参数，它有什么用呢？先看一个例子：</p><ul><li>在知乎中搜索web</li><li>浏览器跳转到新页面后，URL变为<a href="https://www.zhihu.com/search?type=content&amp;q=web" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=web</a></li><li>在知乎中搜索java</li><li>浏览器跳转到新页面后，URL变为<a href="https://www.zhihu.com/search?type=content&amp;q=java" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=java</a></li></ul><p>这里的type=content&amp;q=web就是搜索请求的参数，不同参数之间用&amp;分隔，每个参数形如name=value的形式，分别表示参数名字和参数值。在这个例子中，我们输入不同的搜索关键词，在搜索结果页面的URL的q参数是不同的。也就是说，HTTP参数实际上可以认为是一种用户的输入，根据不同的用户输入，服务器经过处理后返回不同的输出（例如搜索spring和搜索java，显示结果是不一样的）。</p><blockquote><p>Spring MVC中的Request参数</p></blockquote><p> 在SpringMVC框架中，可以通过定义@RequestMapping来处理URL请求。和@PathVariable一样，需要在处理URL的函数中获取URL中的参数，也就是?key1=value1&amp;key2=value2这样的参数列表。通过注解@RequestParam可以轻松地将URL中的参数绑定到处理函数方法的变量中：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/user"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getUserBlog</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> blogId<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"blogId="</span><span class="token operator">+</span>blogId<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 这样，当我们访问/user/?id=123时，SpringMVC帮助我们将Request参数id的值绑定到了处理函数的参数blogId上。这样就能够轻松获取用户输入，并根据它的值进行计算并返回了。</p><p>请求url：<code>localhost:8089/user/?id=123</code></p><p>返回结果：blogid=123</p><p><img src="https://img-blog.csdnimg.cn/20181212174746325.PNG" alt="img"></p><h3 id="RequestParam和-PathVariable"><a href="#RequestParam和-PathVariable" class="headerlink" title="@RequestParam和@PathVariable"></a>@RequestParam和@PathVariable</h3><blockquote><p> 相同点与区别</p></blockquote><p> @RequestParam和@PathVariable都能够完成类似的功能——因为本质上，它们都是用户的输入，只不过输入的部分不同，一个在URL路径部分，另一个在参数部分。要访问一篇博客文章，这两种URL设计都是可以的：</p><ul><li>通过@PathVariable，例如/blogs/1</li><li>通过@RequestParam，例如blogs?blogId=1</li></ul><p>那么究竟应该选择哪一种呢？建议：</p><p>1、当URL指向的是某一具体业务资源（或资源列表），例如博客，用户时，使用@PathVariable</p><p>2、当URL需要对资源或者资源列表进行过滤，筛选时，用@RequestParam</p><p>例如我们会这样设计URL：</p><ul><li>/blogs/{blogId}</li><li>/blogs?state=publish而不是/blogs/state/publish来表示处于发布状态的博客文章</li></ul><blockquote><p>更多用法</p></blockquote><p> 一旦我们在方法中定义了@RequestParam变量，如果访问的URL中不带有相应的参数，就会抛出异常——这是显然的，Spring尝试帮我们进行绑定，然而没有成功。但有的时候，<strong>参数确实不一定永远都存在，这时我们可以通过定义required属性</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，在参数不存在的情况下，可能希望变量有一个默认值：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> defaultValue <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试——基础部分3</title>
      <link href="/2019/11/13/2019/11/java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/"/>
      <url>/2019/11/13/2019/11/java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/</url>
      
        <content type="html"><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a><strong>Hibernate</strong></h1><h2 id="1-为什么要使用-hibernate？"><a href="#1-为什么要使用-hibernate？" class="headerlink" title="1. 为什么要使用 hibernate？"></a><strong>1. 为什么要使用 hibernate？</strong></h2><ul><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li><li>Hibernate<strong>是一个基于JDBC的主流持久化框架</strong>，是一个优秀的ORM实现。很大程度的简化DAO层的编码工作</li><li>hibernate使用<strong>Java反射机制，而不是字节码增强程序来实现透明性</strong>。</li><li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li></ul><h2 id="2-什么是-ORM-框架？"><a href="#2-什么是-ORM-框架？" class="headerlink" title="2. 什么是 ORM 框架？"></a><strong>2. 什么是 ORM 框架？</strong></h2><p>对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。<strong>对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据</strong>。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</p><h2 id="3-hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#3-hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="3. hibernate 中如何在控制台查看打印的 sql 语句？"></a><strong>3. hibernate 中如何在控制台查看打印的 sql 语句？</strong></h2><p>参考：blog.csdn.net/Randy_Wang_/article/details/79460306</p><h2 id="4-hibernate-有几种查询方式？"><a href="#4-hibernate-有几种查询方式？" class="headerlink" title="4. hibernate 有几种查询方式？"></a><strong>4. hibernate 有几种查询方式？</strong></h2><ol><li>hql 查询</li><li>sql 查询</li><li>条件查询</li></ol><p>示例代码</p><pre class="line-numbers language-java"><code class="language-java">hql查询，sql查询，条件查询HQL<span class="token operator">:</span>  Hibernate Query Language<span class="token punctuation">.</span> 面向对象的写法<span class="token operator">:</span>Query query <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span><span class="token string">"from Customer where name = ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>query<span class="token punctuation">.</span><span class="token function">setParameter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"苍老师"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>QBC<span class="token operator">:</span>  Query By Criteria<span class="token punctuation">.</span><span class="token punctuation">(</span>条件查询<span class="token punctuation">)</span>Criteria criteria <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createCriteria</span><span class="token punctuation">(</span>Customer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>criteria<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Restrictions<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"花姐"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Customer<span class="token operator">></span> list <span class="token operator">=</span> criteria<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SQL<span class="token operator">:</span>SQLQuery query <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createSQLQuery</span><span class="token punctuation">(</span><span class="token string">"select * from customer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> list <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SQLQuery query <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">createSQLQuery</span><span class="token punctuation">(</span><span class="token string">"select * from customer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>query<span class="token punctuation">.</span><span class="token function">addEntity</span><span class="token punctuation">(</span>Customer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Customer<span class="token operator">></span> list <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Hql： 具体分类<span class="token number">1</span>、 属性查询 <span class="token number">2</span>、 参数查询、命名参数查询 <span class="token number">3</span>、 关联查询 <span class="token number">4</span>、 分页查询 <span class="token number">5</span>、 统计函数HQL和SQL的区别HQL是面向对象查询操作的，SQL是结构化查询语言 是面向数据库表结构的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-hibernate-实体类可以被定义为-final-吗？"><a href="#5-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="5. hibernate 实体类可以被定义为 final 吗？"></a><strong>5. hibernate 实体类可以被定义为 final 吗？</strong></h2><p>可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能够避免出现前面所说的不利后果。</p><h2 id="6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a><strong>6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</strong></h2><p>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p><h2 id="7-hibernate-是如何工作的？"><a href="#7-hibernate-是如何工作的？" class="headerlink" title="7. hibernate 是如何工作的？"></a><strong>7. hibernate 是如何工作的？</strong></h2><p>hibernate工作原理：</p><ol><li><p>通过<code>Configuration config = new Configuration().configure();</code>//读取并解析hibernate.cfg.xml配置文件</p></li><li><p>由hibernate.cfg.xml中的<code>&lt;mapping resource=&quot;com/xx/User.hbm.xml&quot;/&gt;</code>读取并解析映射信息</p></li><li><p>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</p></li><li><p>Session session = sf.openSession();//打开Sesssion</p></li><li><p>Transaction tx = session.beginTransaction();//创建并启动事务Transation</p></li><li><p>persistent operate操作数据，持久化操作</p></li><li><p>tx.commit();//提交事务</p></li><li><p>关闭Session</p></li><li><p>关闭SesstionFactory</p></li></ol><h2 id="8-get-和-load-的区别？"><a href="#8-get-和-load-的区别？" class="headerlink" title="8. get()和 load()的区别？"></a><strong>8. get()和 load()的区别？</strong></h2><ul><li>load() 没有使用对象的其他属性的时候，没有SQL  延迟加载</li><li>get() 没有使用对象的其他属性的时候，也生成了SQL  立即加载</li></ul><h2 id="9-说一下-hibernate-的缓存机制？"><a href="#9-说一下-hibernate-的缓存机制？" class="headerlink" title="9. 说一下 hibernate 的缓存机制？"></a><strong>9. 说一下 hibernate 的缓存机制？</strong></h2><p>Hibernate中的缓存分为一级缓存和二级缓存。</p><ul><li><p><strong>一级缓存就是  Session 级别的缓存，在事务范围内有效是,内置的不能被卸载</strong>。</p></li><li><p>二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，<strong>默认没有二级缓存，需要手动开启。</strong>保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</p></li></ul><p>什么样的数据适合存放到第二级缓存中？</p><ul><li>很少被修改的数据 ——帖子的最后回复时间</li><li>经常被查询的数据  ——电商的地点</li><li>不是很重要的数据，允许出现偶尔并发的数据</li><li>不会被并发访问的数据</li><li>常量数据</li></ul><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。<strong>使用  memcahe,redis等中央缓存来代替二级缓存</strong>。</p><h2 id="9-hibernate-对象有哪些状态？"><a href="#9-hibernate-对象有哪些状态？" class="headerlink" title="9. hibernate 对象有哪些状态？"></a><strong>9. hibernate 对象有哪些状态？</strong></h2><p>hibernate里对象有三种状态：</p><ol><li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li><li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li><li>Detached（脱管）：当session  close()完之后，变成Detached。</li></ol><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vmoe9ju9j20ir0c2jrr.jpg" alt="640-1573569036236.jpg"></p><h2 id="10-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#10-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="10. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a><strong>10. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</strong></h2><p>openSession 从字面上可以看得出来<strong>，是打开一个新的session对象，而且每次使用都是打开一个新的session</strong>，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session。</p><p>getCurrentSession ，从字面上可以看得出来，是<strong>获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象</strong>，这就是与openSession的区别之一。</p><blockquote><p>简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</p></blockquote><p>注意：在实际开发中，<strong>往往使用getCurrentSession多</strong>，因为一般是处理同一个事务（即是使用一个数据库的情况），所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</p><h2 id="11-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#11-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="11. hibernate 实体类必须要有无参构造函数吗？为什么？"></a><strong>11. hibernate 实体类必须要有无参构造函数吗？为什么？</strong></h2><p>必须，<strong>因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法</strong>，这个方法就是通过调用默认构造方法来创建实例对象的。</p><blockquote><p>另外再提醒一点，如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</p></blockquote><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><strong>Mybatis</strong></h1><h2 id="1-mybatis-中-和-的区别是什么？"><a href="#1-mybatis-中-和-的区别是什么？" class="headerlink" title="1. mybatis 中 #{}和 ${}的区别是什么？"></a><strong>1. mybatis 中 <code>#{}</code>和 <code>${}</code>的区别是什么？</strong></h2><ul><li><code>#{}</code>是<strong>预编译处理</strong>，<code>${}</code>是<strong>字符串替换</strong>；</li><li>Mybatis 在处理 <code>#{}</code> 时，会将 sql 中的<code>#{}</code>替换为? 号，调用 PreparedStatement 的 set 方法来赋值；</li><li>Mybatis 在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值；</li><li>使用<code>#{}</code> 可以<strong>有效的防止 SQL 注入，提高系统安全性</strong>。</li></ul><h2 id="2-mybatis-有几种分页方式？"><a href="#2-mybatis-有几种分页方式？" class="headerlink" title="2. mybatis 有几种分页方式？"></a><strong>2. mybatis 有几种分页方式？</strong></h2><ol><li><p>数组分页</p></li><li><p>sql 分页</p></li><li><p>拦截器分页</p></li><li><p>RowBounds 分页</p></li></ol><h2 id="3-mybatis-逻辑分页和物理分页的区别是什么？"><a href="#3-mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="3. mybatis 逻辑分页和物理分页的区别是什么？"></a><strong>3. mybatis 逻辑分页和物理分页的区别是什么？</strong></h2><ul><li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li><li><strong>物理分页总是优于逻辑分页</strong>：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势, 然而其它性能上的优点足以弥补这个缺点。</li></ul><h2 id="4-mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#4-mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="4. mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a><strong>4. mybatis 是否支持延迟加载？延迟加载的原理是什么？</strong></h2><blockquote><p>延迟加载就是在用到的时候采取赋值，常见的就是在get方法里面判断是否为null，为null的时候采取查询一次。</p></blockquote><p>Mybatis 仅支持 <strong>association 关联对象和 collection 关联集合对象的延迟加载</strong>，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code>。</p><p>它的原理是，<strong>使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用</strong>。这就是延迟加载的基本原理。——》就是在get的时候如果是null就去查询一次并赋值</p><blockquote><p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p></blockquote><h2 id="5-说一下-mybatis-的一级缓存和二级缓存？"><a href="#5-说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="5. 说一下 mybatis 的一级缓存和二级缓存？"></a><strong>5. 说一下 mybatis 的一级缓存和二级缓存？</strong></h2><blockquote><p>二者之间区别就是作用域不同</p></blockquote><ul><li><p>一级缓存: 基于 PerpetualCache 的 <strong>HashMap 本地缓存</strong>，其存储作用域为 <strong>Session</strong>，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p></li><li><p>二级缓存与一级缓存其机制相同，<strong>默认也是采用 PerpetualCache，HashMap 存储</strong>，不同在于其存储作用域为 <strong>Mapper(Namespace)</strong>，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口 (可用来保存对象的状态), 可在它的映射文件中配置<code>&lt; cache/&gt;</code>；</p></li></ul><blockquote><p>对于缓存数据更新机制，当某一个作用域 (一级缓存 Session / 二级缓存 Namespaces) 的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p></blockquote><h2 id="6-mybatis-和-hibernate-的区别有哪些？"><a href="#6-mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="6. mybatis 和 hibernate 的区别有哪些？"></a><strong>6. mybatis 和 hibernate 的区别有哪些？</strong></h2><p>（1）Mybatis 和 hibernate 不同，<strong>它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句</strong>。</p><p>（2）Mybatis 直接<strong>编写原生态 sql，可以严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果</strong>。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套 sql 映射文件，工作量大。 </p><p>（3）Hibernate 对象 / 关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用 hibernate 开发可以节省很多代码，提高效率。 </p><h2 id="7-mybatis-有哪些执行器（Executor）？"><a href="#7-mybatis-有哪些执行器（Executor）？" class="headerlink" title="7. mybatis 有哪些执行器（Executor）？"></a><strong>7. mybatis 有哪些执行器（Executor）？</strong></h2><p> Mybatis 有三种基本的执行器（Executor）：</p><ol><li><strong>SimpleExecutor</strong>：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。——不可复用</li><li><strong>ReuseExecutor</strong>：执行 update 或 select，<strong>以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map 内，供下一次使</strong>用。简言之，就是重复使用 Statement 对象。——可复用</li><li><strong>BatchExecutor</strong>：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），<strong>它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理</strong>。与 JDBC 批处理相同。——批量处理</li></ol><h2 id="8-mybatis-分页插件的实现原理是什么？"><a href="#8-mybatis-分页插件的实现原理是什么？" class="headerlink" title="8. mybatis 分页插件的实现原理是什么？"></a><strong>8. mybatis 分页插件的实现原理是什么？</strong></h2><blockquote><ul><li>实现mybatis的插件接口</li><li>拦截执行的sql，然后重写sql</li><li>添加对应的物理分页参数</li></ul></blockquote><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件<strong>，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数</strong>。</p><h2 id="9-mybatis-如何编写一个自定义插件？"><a href="#9-mybatis-如何编写一个自定义插件？" class="headerlink" title="9. mybatis 如何编写一个自定义插件？"></a>9.<em><em> mybatis 如何编写一个自定义插件？</em></em></h2><p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p><p>Mybatis 自定义插件针对 Mybatis 四大对象（<strong>Executor、StatementHandler 、ParameterHandler 、ResultSetHandler</strong> ）进行拦截，具体拦截方式为： </p><ul><li>Executor：拦截执行器的方法 (log 记录) </li><li>StatementHandler ：拦截 Sql 语法构建的处理 </li><li>ParameterHandler ：拦截参数的处理 </li><li>ResultSetHandler ：拦截结果集的处理 </li></ul><p>Mybatis 自定义插件必须实现 Interceptor 接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>    Object <span class="token function">intercept</span><span class="token punctuation">(</span>Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable<span class="token punctuation">;</span>    Object <span class="token function">plugin</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setProperties</span><span class="token punctuation">(</span>Properties properties<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>intercept 方法：拦截器具体处理逻辑方法 </p></li><li><p>plugin 方法：根据签名 signatureMap 生成动态代理对象 </p></li><li><p>setProperties 方法：设置 Properties 属性</p></li></ul><p>自定义插件 demo:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ExamplePlugin.java</span><span class="token annotation punctuation">@Intercepts</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Signature</span><span class="token punctuation">(</span>  type<span class="token operator">=</span> Executor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>  method <span class="token operator">=</span> <span class="token string">"update"</span><span class="token punctuation">,</span>  args <span class="token operator">=</span> <span class="token punctuation">{</span>MappedStatement<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExamplePlugin</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>  Object target <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//被代理对象</span>  Method method <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//代理方法</span>  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//方法参数</span>  <span class="token comment" spellcheck="true">// do something ...... 方法拦截前执行代码块</span>  Object result <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// do something .......方法拦截后执行代码块</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> Object <span class="token function">plugin</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Plugin<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setProperties</span><span class="token punctuation">(</span>Properties properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个 @Intercepts 可以配置多个 @Signature，@Signature 中的参数定义如下： </p><ul><li>type：表示拦截的类，这里是 Executor 的实现类；</li><li>method：表示拦截的方法，这里是拦截 Executor 的 update 方法；</li><li>args：表示方法参数。</li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h1><h2 id="1-rabbitmq-的使用场景有哪些？"><a href="#1-rabbitmq-的使用场景有哪些？" class="headerlink" title="1. rabbitmq 的使用场景有哪些？"></a><strong>1. rabbitmq 的使用场景有哪些？</strong></h2><p>①. 跨系统的异步通信，<strong>所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式</strong>。</p><p>②. 多个应用之间的耦合，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，<strong>因此更适合作为多个应用之间的松耦合的接口</strong>。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。</p><p>③. 应用内的同步变异步，<strong>比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉</strong>。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。</p><p>④. 消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。</p><p>⑤. 应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。</p><p>⑥. 跨局域网，甚至跨城市的通讯（CDN行业），比如北京机房与广州机房的应用程序的通信。</p><h2 id="2-rabbitmq-有哪些重要的角色？"><a href="#2-rabbitmq-有哪些重要的角色？" class="headerlink" title="2. rabbitmq 有哪些重要的角色？"></a><strong>2. rabbitmq 有哪些重要的角色？</strong></h2><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h2 id="3-rabbitmq-有哪些重要的组件？"><a href="#3-rabbitmq-有哪些重要的组件？" class="headerlink" title="3. rabbitmq 有哪些重要的组件？"></a><strong>3. rabbitmq 有哪些重要的组件？</strong></h2><ul><li>ConnectionFactory（连接管理器）：<strong>应用程序与Rabbit之间建立连接的管理器</strong>，程序代码中使用。</li><li>Channel（信道）：消息推送使用的通道。</li><li>Exchange（交换器）：用于接受、分配消息。</li><li>Queue（队列）：用于存储生产者的消息。</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><h2 id="4-rabbitmq-中-vhost-的作用是什么？"><a href="#4-rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="4. rabbitmq 中 vhost 的作用是什么？"></a><strong>4. rabbitmq 中 vhost 的作用是什么？</strong></h2><p>vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ  server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，<strong>vhost 可以作为不同权限隔离的手段</strong>（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 </p><h2 id="5-rabbitmq-的消息是怎么发送的？"><a href="#5-rabbitmq-的消息是怎么发送的？" class="headerlink" title="5. rabbitmq 的消息是怎么发送的？"></a><strong>5. rabbitmq 的消息是怎么发送的？</strong></h2><blockquote><p>常见的客户端，服务端建立长连接。通过订阅，发布来通信</p><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p></blockquote><h2 id="6-rabbitmq-怎么保证消息的稳定性？"><a href="#6-rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="6. rabbitmq 怎么保证消息的稳定性？"></a><strong>6. rabbitmq 怎么保证消息的稳定性？</strong></h2><ul><li>提供了<strong>事务的功能</strong>。</li><li><strong>通过将 channel 设置为 confirm（确认）模式</strong>。</li></ul><h2 id="7-rabbitmq-怎么避免消息丢失？"><a href="#7-rabbitmq-怎么避免消息丢失？" class="headerlink" title="7. rabbitmq 怎么避免消息丢失？"></a><strong>7. rabbitmq 怎么避免消息丢失？</strong></h2><blockquote><p>同样适用于IM通信中</p></blockquote><ol><li>消息持久化</li><li>ACK确认机制</li><li>设置<strong>集群镜像模式</strong></li><li>消息补偿机制</li></ol><h2 id="8-要保证消息持久化成功的条件有哪些？"><a href="#8-要保证消息持久化成功的条件有哪些？" class="headerlink" title="8. 要保证消息持久化成功的条件有哪些？"></a><strong>8. 要保证消息持久化成功的条件有哪些？</strong></h2><ol><li>声明队列必须设置持久化 <strong>durable 设置为 true</strong>.</li><li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li><li>消息已经到达持久化交换器。</li><li>消息已经到达<strong>持久化队列</strong>。</li></ol><p>以上四个条件都满足才能保证消息持久化成功。</p><h2 id="9-rabbitmq-持久化有什么缺点？"><a href="#9-rabbitmq-持久化有什么缺点？" class="headerlink" title="9. rabbitmq 持久化有什么缺点？"></a><strong>9. rabbitmq 持久化有什么缺点？</strong></h2><blockquote><p>显而易见的问题</p></blockquote><p>持久化的缺地就是<strong>降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量</strong>。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h2 id="10-rabbitmq-有几种广播类型？"><a href="#10-rabbitmq-有几种广播类型？" class="headerlink" title="10. rabbitmq 有几种广播类型？"></a><strong>10. rabbitmq 有几种广播类型？</strong></h2><p> 三种广播模式：</p><ol><li>fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</li><li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</li><li>topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息；</li></ol><h2 id="11-rabbitmq-怎么实现延迟消息队列？"><a href="#11-rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="11. rabbitmq 怎么实现延迟消息队列？"></a><strong>11. rabbitmq 怎么实现延迟消息队列？</strong></h2><blockquote><p>由延迟消费队列</p></blockquote><ol><li>通过消息过期后进入死信交换器，再由交换器转发到<strong>延迟消费队列</strong>，实现延迟功能；</li><li>使用<code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</li></ol><h2 id="12-rabbitmq-集群有什么用？"><a href="#12-rabbitmq-集群有什么用？" class="headerlink" title="12. rabbitmq 集群有什么用？"></a><strong>12. rabbitmq 集群有什么用？</strong></h2><p>集群主要有以下两个用途：</p><ul><li>高可用：某个服务器出现问题，<strong>整个 RabbitMQ 还可以继续使用</strong>；</li><li>高容量：集群可以承载更多的消息量。</li></ul><h2 id="13-rabbitmq-节点的类型有哪些？"><a href="#13-rabbitmq-节点的类型有哪些？" class="headerlink" title="13. rabbitmq 节点的类型有哪些？"></a><strong>13. rabbitmq 节点的类型有哪些？</strong></h2><blockquote><p>跟存储相关</p></blockquote><ul><li>磁盘节点：消息会存储到磁盘。</li><li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li></ul><h2 id="13-rabbitmq-集群搭建需要注意哪些问题？"><a href="#13-rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="13. rabbitmq 集群搭建需要注意哪些问题？"></a><strong>13. rabbitmq 集群搭建需要注意哪些问题？</strong></h2><ul><li>各节点之间使用<code>“--link”</code>连接，此属性不能忽略。</li><li>各节点使用的<code>erlang cookie</code>值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li><li>整个集群中<strong>必须包含一个磁盘节点</strong>。</li></ul><h2 id="14-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#14-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="14. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a><strong>14. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</strong></h2><p>不是，原因有以下两个：</p><ol><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li><li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li></ol><h2 id="15-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#15-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="15. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a><strong>15. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</strong></h2><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><blockquote><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p></blockquote><h2 id="16-rabbitmq-对集群节点停止顺序有要求吗？"><a href="#16-rabbitmq-对集群节点停止顺序有要求吗？" class="headerlink" title="16. rabbitmq 对集群节点停止顺序有要求吗？"></a><strong>16. rabbitmq 对集群节点停止顺序有要求吗？</strong></h2><p>RabbitMQ 对集群的停止的顺序是有要求的，<strong>应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失</strong>。</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><strong>Kafka</strong></h1><h2 id="1-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#1-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="1. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a><strong>1. kafka 可以脱离 zookeeper 单独使用吗？为什么？</strong></h2><p>kafka 不能脱离 zookeeper 单独使用，<strong>因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器</strong>。</p><h2 id="2-kafka-有几种数据保留的策略？"><a href="#2-kafka-有几种数据保留的策略？" class="headerlink" title="2. kafka 有几种数据保留的策略？"></a><strong>2. kafka 有几种数据保留的策略？</strong></h2><p>kafka 有两种数据保存策略：按照<strong>过期时间</strong>保留和按照存储的<strong>消息大小</strong>保留。</p><h2 id="3-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#3-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="3. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a><strong>3. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</strong></h2><p>这个时候 kafka 会执行数据清除工作，<strong>时间和大小不论那个满足条件，都会清空数据</strong>。</p><h2 id="4-什么情况会导致-kafka-运行变慢？"><a href="#4-什么情况会导致-kafka-运行变慢？" class="headerlink" title="4. 什么情况会导致 kafka 运行变慢？"></a><strong>4. 什么情况会导致 kafka 运行变慢？</strong></h2><blockquote><p>三大硬件角度，cpu，磁盘，网络，内存。</p></blockquote><ul><li>cpu 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul><h2 id="5-使用-kafka-集群需要注意什么？"><a href="#5-使用-kafka-集群需要注意什么？" class="headerlink" title="5. 使用 kafka 集群需要注意什么？"></a><strong>5. 使用 kafka 集群需要注意什么？</strong></h2><ul><li>集群的数量不是越多越好，<strong>最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低</strong>。——节点之后存在同步</li><li>集群数量最好是单数，<strong>因为超过一半故障集群就不能用了，设置为单数容错率更高</strong>。</li></ul><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><strong>Zookeeper</strong></h1><h2 id="1-zookeeper-是什么？"><a href="#1-zookeeper-是什么？" class="headerlink" title="1. zookeeper 是什么？"></a><strong>1. zookeeper 是什么？</strong></h2><p>zookeeper 是一个分布式的，开放源码的分布式<strong>应用程序协调服务</strong>，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：<strong>配置维护、域名服务、分布式同步、组服务</strong>等。</p><h2 id="2-zookeeper-都有哪些功能？"><a href="#2-zookeeper-都有哪些功能？" class="headerlink" title="2. zookeeper 都有哪些功能？"></a><strong>2. zookeeper 都有哪些功能？</strong></h2><ul><li>集群管理：监控节点存活状态、运行请求等。</li><li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li><li>分布式锁：<strong>zookeeper 提供两种锁：独占锁、共享锁</strong>。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li><li>命名服务：在分布式系统中，通<strong>过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</strong>。</li></ul><h2 id="3-zookeeper-有几种部署模式？"><a href="#3-zookeeper-有几种部署模式？" class="headerlink" title="3. zookeeper 有几种部署模式？"></a><strong>3. zookeeper 有几种部署模式？</strong></h2><p>zookeeper 有三种部署模式：</p><ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li></ul><h2 id="4-zookeeper-怎么保证主从节点的状态同步？"><a href="#4-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="4. zookeeper 怎么保证主从节点的状态同步？"></a><strong>4. zookeeper 怎么保证主从节点的状态同步？</strong></h2><p>zookeeper 的<strong>核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议</strong>。 zab 协议有两种模式，分别是<strong>恢复模式（选主）和广播模式（同步）</strong>。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h2 id="5-集群中为什么要有主节点？"><a href="#5-集群中为什么要有主节点？" class="headerlink" title="5. 集群中为什么要有主节点？"></a><strong>5. 集群中为什么要有主节点？</strong></h2><p>在分布式环境中，<strong>有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</strong>。——共享结果，只需要一台机器执行</p><h2 id="6-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#6-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="6. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a><strong>6. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</strong></h2><p>可以继续使用，<strong>单数服务器只要没超过一半的服务器宕机就可以继续使用</strong>。</p><h2 id="7-说一下-zookeeper-的通知机制？"><a href="#7-说一下-zookeeper-的通知机制？" class="headerlink" title="7. 说一下 zookeeper 的通知机制？"></a><strong>7. 说一下 zookeeper 的通知机制？</strong></h2><p>客户端端会对某个 znode 建立一个 watcher 事件，<strong>当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变</strong>。</p><h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a><strong>MySql</strong></h1><h2 id="1-数据库的三范式是什么？"><a href="#1-数据库的三范式是什么？" class="headerlink" title="1. 数据库的三范式是什么？"></a><strong>1. 数据库的三范式是什么？</strong></h2><ul><li>第一范式：强调的是列的原子性，即数据库表的<strong>每一列都是不可分割的原子数据项</strong>。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h2 id="2-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？"><a href="#2-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？"></a><strong>2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</strong></h2><ul><li>表类型如果是 MyISAM ，那 id 就是 18。</li><li>表类型如果是 InnoDB，那 id 就是 15。</li></ul><blockquote><p>InnoDB 表只会把<strong>自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失</strong>。</p></blockquote><h2 id="3-如何获取当前数据库版本？"><a href="#3-如何获取当前数据库版本？" class="headerlink" title="3. 如何获取当前数据库版本？"></a><strong>3. 如何获取当前数据库版本？</strong></h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h2 id="4-说一下-ACID-是什么？"><a href="#4-说一下-ACID-是什么？" class="headerlink" title="4. 说一下 ACID 是什么？"></a><strong>4. 说一下 ACID 是什么？</strong></h2><ul><li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h2 id="5-char-和-varchar-的区别是什么？"><a href="#5-char-和-varchar-的区别是什么？" class="headerlink" title="5. char 和 varchar 的区别是什么？"></a><strong>5. char 和 varchar 的区别是什么？</strong></h2><p>char(n) ：<strong>固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节</strong>。</p><p>chat 优点：效率高；缺点：占用空间；适用场景：<strong>存储密码的 md5 值，固定长度的，使用 char 非常合适</strong>。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><blockquote><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p></blockquote><h2 id="6-float-和-double-的区别是什么？"><a href="#6-float-和-double-的区别是什么？" class="headerlink" title="6. float 和 double 的区别是什么？"></a><strong>6. float 和 double 的区别是什么？</strong></h2><ul><li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li><li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li></ul><h2 id="7-mysql-的内连接、左连接、右连接有什么区别？"><a href="#7-mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="7. mysql 的内连接、左连接、右连接有什么区别？"></a><strong>7. mysql 的内连接、左连接、右连接有什么区别？</strong></h2><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><blockquote><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p></blockquote><h2 id="8-mysql-索引是怎么实现的？"><a href="#8-mysql-索引是怎么实现的？" class="headerlink" title="8. mysql 索引是怎么实现的？"></a><strong>8. mysql 索引是怎么实现的？</strong></h2><p>索引是满足某种特定<strong>查找算法的数据结构</strong>，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><blockquote><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，<strong>B+ 树的搜索效率</strong>，可以到达二分法的性能，<strong>找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的</strong>。</p></blockquote><h2 id="9-怎么验证-mysql-的索引是否满足需求？"><a href="#9-怎么验证-mysql-的索引是否满足需求？" class="headerlink" title="9. 怎么验证 mysql 的索引是否满足需求？"></a><strong>9. 怎么验证 mysql 的索引是否满足需求？</strong></h2><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><blockquote><p>explain 语法：explain select * from table where type=1。</p></blockquote><h2 id="10-说一下数据库的事务隔离？"><a href="#10-说一下数据库的事务隔离？" class="headerlink" title="10. 说一下数据库的事务隔离？"></a><strong>10. 说一下数据库的事务隔离？</strong></h2><p>MySQL 的事务隔离是在 <strong>MySQL. ini 配置文件里添加的</strong>，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><ul><li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li><li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li><li>REPEATABLE-READ<strong>：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）</strong>。</li><li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h2 id="11-说一下-mysql-常用的引擎？"><a href="#11-说一下-mysql-常用的引擎？" class="headerlink" title="11. 说一下 mysql 常用的引擎？"></a><strong>11. 说一下 mysql 常用的引擎？</strong></h2><p>InnoDB 引擎：<strong>InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统</strong>。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，<strong>所以当进行 select count(*) from table 指令的时候，需要进行扫描全表</strong>。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyIASM 引擎：<strong>MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键</strong>。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。<strong>不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。</strong>所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><blockquote><ul><li>如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li><li>如果表的写操作远远多于读，需要事务支持，在并发度较高的场景下使用InnoDB会提升效率的。</li></ul></blockquote><h2 id="12-说一下-mysql-的行锁和表锁？"><a href="#12-说一下-mysql-的行锁和表锁？" class="headerlink" title="12. 说一下 mysql 的行锁和表锁？"></a><strong>12. 说一下 mysql 的行锁和表锁？</strong></h2><p>MyISAM 只支持表锁，<strong>InnoDB 支持表锁和行锁，默认为行锁</strong>。</p><ul><li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，<strong>发生锁冲突的概率最高，并发量最低</strong>。</li><li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，<strong>发生锁冲突的概率小，并发度最高</strong>。</li></ul><h2 id="13-说一下乐观锁和悲观锁？"><a href="#13-说一下乐观锁和悲观锁？" class="headerlink" title="13. 说一下乐观锁和悲观锁？"></a><strong>13. 说一下乐观锁和悲观锁？</strong></h2><blockquote><p>乐观：没人会去更改</p><p>悲观：肯定有人会去更改</p></blockquote><ul><li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>提交更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>。</li><li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，<strong>这样别人想拿这个数据就会阻止，直到这个锁被释放</strong>。</li></ul><blockquote><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p></blockquote><h2 id="14-mysql-问题排查都有哪些手段？"><a href="#14-mysql-问题排查都有哪些手段？" class="headerlink" title="14. mysql 问题排查都有哪些手段？"></a><strong>14. mysql 问题排查都有哪些手段？</strong></h2><ul><li>使用 show processlist 命令查看当前所有连接信息。</li><li><strong>使用 explain 命令查询 SQL 语句执行计划。</strong></li><li>开启慢查询日志，<strong>查看慢查询的 SQL。</strong></li></ul><h2 id="15-如何做-mysql-的性能优化？"><a href="#15-如何做-mysql-的性能优化？" class="headerlink" title="15. 如何做 mysql 的性能优化？"></a><strong>15. 如何做 mysql 的性能优化？</strong></h2><blockquote><p>索引，分割表，避免全局查找，正确的引擎</p></blockquote><ul><li>为搜索字段创建索引。</li><li>避免使用 select *，列出需要查询的字段。</li><li><strong>垂直分割分表</strong>。</li><li><strong>选择正确的存储引擎</strong>。</li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h1><h2 id="1-redis-是什么？都有哪些使用场景？"><a href="#1-redis-是什么？都有哪些使用场景？" class="headerlink" title="1. redis 是什么？都有哪些使用场景？"></a><strong>1. redis 是什么？都有哪些使用场景？</strong></h2><p>Redis是一个开源的使用<strong>ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</strong>。</p><blockquote><p>Redis 使用场景：</p></blockquote><ul><li>数据高并发的读写</li><li>海量数据的读写</li><li>对扩展性要求高的数据</li></ul><h2 id="2-redis-有哪些功能？"><a href="#2-redis-有哪些功能？" class="headerlink" title="2. redis 有哪些功能？"></a><strong>2. redis 有哪些功能？</strong></h2><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h2 id="3-redis-和-memecache-有什么区别？"><a href="#3-redis-和-memecache-有什么区别？" class="headerlink" title="3. redis 和 memecache 有什么区别？"></a><strong>3. redis 和 memecache 有什么区别？</strong></h2><ul><li><strong>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</strong></li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ul><h2 id="4-redis-为什么是单线程的？"><a href="#4-redis-为什么是单线程的？" class="headerlink" title="4. redis 为什么是单线程的？"></a><strong>4. redis 为什么是单线程的？</strong></h2><p>因为 cpu 不是 Redis 的瓶颈，<strong>Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了</strong>。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><blockquote><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p></blockquote><h2 id="5-什么是缓存穿透？怎么解决？"><a href="#5-什么是缓存穿透？怎么解决？" class="headerlink" title="5. 什么是缓存穿透？怎么解决？"></a><strong>5. 什么是缓存穿透？怎么解决？</strong></h2><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个<strong>不存在的数据每次请求都要到数据库去查询，造成缓存穿透</strong>。</p><blockquote><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p></blockquote><h2 id="6-redis-支持的数据类型有哪些？"><a href="#6-redis-支持的数据类型有哪些？" class="headerlink" title="6. redis 支持的数据类型有哪些？"></a><strong>6. redis 支持的数据类型有哪些？</strong></h2><p>string、list、hash、set、zset。</p><h2 id="7-redis-支持的-java-客户端都有哪些？"><a href="#7-redis-支持的-java-客户端都有哪些？" class="headerlink" title="7. redis 支持的 java 客户端都有哪些？"></a><strong>7. redis 支持的 java 客户端都有哪些？</strong></h2><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h2 id="8-jedis-和-redisson-有哪些区别？"><a href="#8-jedis-和-redisson-有哪些区别？" class="headerlink" title="8. jedis 和 redisson 有哪些区别？"></a><strong>8. jedis 和 redisson 有哪些区别？</strong></h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p><p><strong>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性</strong>。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="9-怎么保证缓存和数据库数据的一致性？"><a href="#9-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="9. 怎么保证缓存和数据库数据的一致性？"></a><strong>9. 怎么保证缓存和数据库数据的一致性？</strong></h2><ul><li>合理设置缓存的过期时间。</li><li>新增、更改、删除数据库操作时<strong>同步更新 Redis，可以使用事物机制来保证数据的一致性</strong>。</li></ul><h2 id="10-redis-持久化有几种方式？"><a href="#10-redis-持久化有几种方式？" class="headerlink" title="10. redis 持久化有几种方式？"></a><strong>10. redis 持久化有几种方式？</strong></h2><blockquote><p>时间，命令</p></blockquote><p>Redis 的持久化有两种方式，或者说有两种策略：</p><ul><li>RDB（Redis Database）：指定的<strong>时间间隔能对你的数据进行快照存储</strong>。</li><li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li></ul><h2 id="11-redis-怎么实现分布式锁？"><a href="#11-redis-怎么实现分布式锁？" class="headerlink" title="11. redis 怎么实现分布式锁？"></a><strong>11. redis 怎么实现分布式锁？</strong></h2><p>Redis 分布式锁其实就是在<strong>系统里面占一个“坑”，其他程序也要占“坑”的时候</strong>，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h2 id="12-redis-分布式锁有什么缺陷？"><a href="#12-redis-分布式锁有什么缺陷？" class="headerlink" title="12. redis 分布式锁有什么缺陷？"></a><strong>12. redis 分布式锁有什么缺陷？</strong></h2><p>Redis 分布式锁<strong>不能解决超时的问题，分布式锁有一个超时时间</strong>，程序的执行如果超出了锁的超时时间就会出现问题。</p><h2 id="13-redis-如何做内存优化？"><a href="#13-redis-如何做内存优化？" class="headerlink" title="13. redis 如何做内存优化？"></a><strong>13. redis 如何做内存优化？</strong></h2><blockquote><p>散列表</p></blockquote><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p><blockquote><p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p></blockquote><h2 id="14-redis-淘汰策略有哪些？"><a href="#14-redis-淘汰策略有哪些？" class="headerlink" title="14. redis 淘汰策略有哪些？"></a><strong>14. redis 淘汰策略有哪些？</strong></h2><ul><li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li><li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li><li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li><li>no-enviction（驱逐）：禁止驱逐数据。</li></ul><h2 id="15-redis-常见的性能问题有哪些？该如何解决？"><a href="#15-redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="15. redis 常见的性能问题有哪些？该如何解决？"></a><strong>15. redis 常见的性能问题有哪些？该如何解决？</strong></h2><ul><li>主服务器写内存快照，会阻塞主线程的工作，<strong>当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照</strong>。</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，<strong>主从库最好在同一个局域网内</strong>。</li></ul><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h1><h2 id="1-说一下-jvm-的主要组成部分？及其作用？"><a href="#1-说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="1. 说一下 jvm 的主要组成部分？及其作用？"></a><strong>1. 说一下 jvm 的主要组成部分？及其作用？</strong></h2><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 <strong>JVM 的一套指令集规范，并不能直接交个底层操作系统去执行</strong>，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h2 id="2-说一下-jvm-运行时数据区？"><a href="#2-说一下-jvm-运行时数据区？" class="headerlink" title="2. 说一下 jvm 运行时数据区？"></a><strong>2. 说一下 jvm 运行时数据区？</strong></h2><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ul><p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8w8c3qeyuj20d70b2wey.jpg" alt="640-1573613318963.jpg"></p><h2 id="3-说一下堆栈的区别？"><a href="#3-说一下堆栈的区别？" class="headerlink" title="3. 说一下堆栈的区别？"></a><strong>3. 说一下堆栈的区别？</strong></h2><ol><li><p>栈内存存储的是局部变量而<strong>堆内存存储的是实体</strong>；</p></li><li><p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p></li><li><p>栈内存存放的变量生命周期一旦结束就会被释放，<strong>而堆内存存放的实体会被垃圾回收机制不定时的回收</strong>。</p></li></ol><h2 id="4-队列和栈是什么？有什么区别？"><a href="#4-队列和栈是什么？有什么区别？" class="headerlink" title="4. 队列和栈是什么？有什么区别？"></a><strong>4. 队列和栈是什么？有什么区别？</strong></h2><ul><li>队列和栈都是被用来预存储数据的。</li><li>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</li><li>栈和队列很相似，但它运行对元素进行后进先出进行检索。</li></ul><h2 id="5-什么是双亲委派模型？"><a href="#5-什么是双亲委派模型？" class="headerlink" title="5. 什么是双亲委派模型？"></a><strong>5. 什么是双亲委派模型？</strong></h2><p>在介绍双亲委派模型之前先说下类加载器。<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象</strong>。</p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载<code>Java_HOME/lib /</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载<code>&lt;java_home style=&quot;box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;&quot;&gt;\lib\ext</code> 目录或<code>Java. ext. dirs</code>系统变量指定的路径中的所有类库；<code>&lt;/java_home&gt;</code></li><li>应用程序类加载器（Application ClassLoader）。<strong>负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器</strong>。</li></ul><blockquote><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，<strong>只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类</strong>。</p></blockquote><h2 id="6-说一下类加载的执行过程？"><a href="#6-说一下类加载的执行过程？" class="headerlink" title="6. 说一下类加载的执行过程？"></a><strong>6. 说一下类加载的执行过程？</strong></h2><p>类加载分为以下 5 个步骤：</p><ol><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>检查：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。<strong>符号引用就理解为一个标示，而在直接引用直接指向内存中的地址</strong>；</li><li>初始化：<strong>对静态变量和静态代码块执行初始化工作。</strong></li></ol><h2 id="7-怎么判断对象是否可以被回收？"><a href="#7-怎么判断对象是否可以被回收？" class="headerlink" title="7. 怎么判断对象是否可以被回收？"></a><strong>7. 怎么判断对象是否可以被回收？</strong></h2><blockquote><p>垃圾回收原理</p></blockquote><p>一般有两种方法来判断：</p><ul><li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析：从 <strong>GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</strong></li></ul><h2 id="8-java-中都有哪些引用类型？"><a href="#8-java-中都有哪些引用类型？" class="headerlink" title="8. java 中都有哪些引用类型？"></a><strong>8. java 中都有哪些引用类型？</strong></h2><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用（幽灵引用 / 幻影引用）</li></ul><h2 id="9-说一下-jvm-有哪些垃圾回收算法？"><a href="#9-说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="9. 说一下 jvm 有哪些垃圾回收算法？"></a><strong>9. 说一下 jvm 有哪些垃圾回收算法？</strong></h2><ul><li>标记 - 清除算法</li><li>标记 - 整理算法</li><li>复制算法</li><li>分代算法</li></ul><h2 id="10-说一下-jvm-有哪些垃圾回收器？"><a href="#10-说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="10. 说一下 jvm 有哪些垃圾回收器？"></a><strong>10. 说一下 jvm 有哪些垃圾回收器？</strong></h2><ul><li>Serial：最早的单线程串行垃圾回收器。</li><li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li><li>ParNew：是 Serial 的多线程版本。</li><li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li><li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记 - 整理的内存回收算法。</li><li>CMS：一<strong>种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统</strong>。</li><li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li></ul><h2 id="11-详细介绍一下-CMS-垃圾回收器？"><a href="#11-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="11. 详细介绍一下 CMS 垃圾回收器？"></a><strong>11. 详细介绍一下 CMS 垃圾回收器？</strong></h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，<strong>是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器</strong>。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。<strong>在启动 JVM 的参数加上<code>“-XX:+UseConcMarkSweepGC”</code>来指定使用 CMS 垃圾回收器</strong>。</p><p>CMS 使用的是标记 - 清除的算法实现的，所以在 gc 的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h2 id="12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a><strong>12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong></h2><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><p>新生代垃圾回收器一般采用的是复制算法，<strong>复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记 - 整理的算法进行垃圾回收</strong>。</p><h2 id="13-简述分代垃圾回收器是怎么工作的？"><a href="#13-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="13. 简述分代垃圾回收器是怎么工作的？"></a><strong>13. 简述分代垃圾回收器是怎么工作的？</strong></h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h2 id="14-说一下-jvm-调优的工具？"><a href="#14-说一下-jvm-调优的工具？" class="headerlink" title="14. 说一下 jvm 调优的工具？"></a><strong>14. 说一下 jvm 调优的工具？</strong></h2><p><strong>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下</strong>，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h2 id="15-常用的-jvm-调优的参数都有哪些？"><a href="#15-常用的-jvm-调优的参数都有哪些？" class="headerlink" title="15. 常用的 jvm 调优的参数都有哪些？"></a><strong>15. 常用的 jvm 调优的参数都有哪些？</strong></h2><ul><li>-Xms2g：初始化推大小为 2g；</li><li>-Xmx2g：堆最大内存为 2g；</li><li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li><li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>-XX:+PrintGC：开启打印 gc 信息；</li><li>-XX:+PrintGCDetails：打印 gc 详细信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试——基础部分2</title>
      <link href="/2019/11/12/2019/11/java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/"/>
      <url>/2019/11/12/2019/11/java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/</url>
      
        <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h1><p>下面列举一些常见的网络相关问题。</p><h2 id="1-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#1-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="1. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>1. <strong>http 响应码 301 和 302 代表的是什么？有什么区别？</strong></h2><p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p><p><strong>区别：</strong> </p><ul><li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li><li>302 redirect: 302 代表暂时性转移(Temporarily Moved )。 </li></ul><h2 id="2-forward-和-redirect-的区别？"><a href="#2-forward-和-redirect-的区别？" class="headerlink" title="2. forward 和 redirect 的区别？"></a>2. <strong>forward 和 redirect 的区别？</strong></h2><p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p><p><strong>直接转发方式（Forward）</strong>，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p><p><strong>间接转发方式（Redirect）</strong>实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p><blockquote><p><strong>举个通俗的例子：</strong></p><p>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p><p>间接转发就相当于：”A找B借钱，B说没有，让A去找C借”。</p></blockquote><h2 id="3-简述-tcp-和-udp的区别？"><a href="#3-简述-tcp-和-udp的区别？" class="headerlink" title="3. 简述 tcp 和 udp的区别？"></a>3. <strong>简述 tcp 和 udp的区别？</strong></h2><ul><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，<strong>即发送数据之前不需要建立连接</strong>。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li><strong>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</strong>。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ul><h2 id="4-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#4-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="4. tcp 为什么要三次握手，两次不行吗？为什么？"></a>4. <strong>tcp 为什么要三次握手，两次不行吗？为什么？</strong></h2><blockquote><p>明确三次握手的目的。</p></blockquote><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 </p><blockquote><p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p></blockquote><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p><h2 id="5-说一下-tcp-粘包是怎么产生的？"><a href="#5-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="5. 说一下 tcp 粘包是怎么产生的？"></a>5. <strong>说一下 tcp 粘包是怎么产生的？</strong></h2><blockquote><p>分为两种，一种是发送的时候，一种是接收的时候</p></blockquote><p><strong>①. 发送方产生粘包</strong></p><blockquote><ol><li>数据包小</li><li>Nagle算法合并</li><li>缓冲区</li></ol></blockquote><p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（<strong>一次连接发一次数据不存在粘包</strong>），双方在连接不断开的情况下，可以一直传输数据；<strong>但当发送的数据包过于小的时候，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）</strong>；这个合并过程就是在发送缓冲区中进行的，<strong>也就是说数据发送出来它已经是粘包的状态了</strong>。</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vhwyqjrqj20n0088jrb.jpg" alt="6404.png"></p><p><strong>②. 接收方产生粘包</strong></p><blockquote><ol><li>放数据的速度 &gt; 应用层拿数据速度</li><li>缓冲区</li></ol></blockquote><p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的 <strong>TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）</strong>；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） </p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vhypgvwuj20u00hddhb.jpg" alt="6405.png"></p><h2 id="6-OSI-的七层模型都有哪些？"><a href="#6-OSI-的七层模型都有哪些？" class="headerlink" title="6. OSI 的七层模型都有哪些？"></a>6. <strong>OSI 的七层模型都有哪些？</strong></h2><ol><li>应用层：网络服务与最终用户的一个接口。</li><li>表示层：数据的表示、安全、压缩。</li><li>会话层：建立、管理、终止会话。</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li><li>物理层：建立、维护、断开物理连接。</li></ol><h2 id="7-get-和-post-请求有哪些区别？"><a href="#7-get-和-post-请求有哪些区别？" class="headerlink" title="7. get 和 post 请求有哪些区别？"></a>7. <strong>get 和 post 请求有哪些区别？</strong></h2><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。——》<strong>这个容易被忽略</strong></li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li><li>GET 请求只能进行 url 编码，<strong>而 POST 支持多种编码方式</strong>。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中。</li></ul><h2 id="8-如何实现跨域？"><a href="#8-如何实现跨域？" class="headerlink" title="8. 如何实现跨域？"></a>8. <strong>如何实现跨域？</strong></h2><h3 id="方式一：图片-ping-或-script-标签跨域"><a href="#方式一：图片-ping-或-script-标签跨域" class="headerlink" title="方式一：图片 ping 或 script 标签跨域"></a><strong>方式一：图片 ping 或 script 标签跨域</strong></h3><ul><li><strong>图片 ping</strong> 常用于跟踪用户点击页面或动态广告曝光次数。 </li><li><strong>script 标签</strong>可以得到从其他来源数据，这也是 JSONP 依赖的根据。 </li></ul><h3 id="方式二：JSONP-跨域"><a href="#方式二：JSONP-跨域" class="headerlink" title="方式二：JSONP 跨域"></a><strong>方式二：JSONP 跨域</strong></h3><p>JSONP（JSON with Padding）是数据格式 JSON 的一种 “使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用<code>&lt;script &gt;</code>元素的这个开放策略，<strong>网页可以得到从其他来源动态产生的 JSON 数据</strong>，而这种使用模式就是所谓的 JSONP。<strong>用 JSONP 抓到的数据并不是 JSON，而是任意的 JavaScript，用 JavaScript 解释器运行而不是用 JSON 解析器解析</strong>。所有，通过 Chrome 查看所有 JSONP 发送的 Get 请求都是 js 类型，而非 XHR。 </p><p>缺点：</p><ul><li>只能使用 Get 请求</li><li>不能注册 success、error 等事件监听函数，不能很容易的确定 JSONP 请求是否失败</li><li>JSONP 是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保</li></ul><h3 id="方式三：CORS"><a href="#方式三：CORS" class="headerlink" title="方式三：CORS"></a><strong>方式三：CORS</strong></h3><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用 CORS 在 API 容器如 XMLHttpRequest 来减少 HTTP 请求的风险来源。<strong>与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种</strong></p><pre class="line-numbers language-html"><code class="language-html">Access-Control-Allow-Origin: *Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>跨域请求默认不会携带 Cookie 信息，如果需要携带，配置下述参数</p><pre class="line-numbers language-html"><code class="language-html">"Access-Control-Allow-Credentials": true// Ajax设置"withCredentials": true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="方式四：window-name-iframe——之前用了个框架就是用这种方式"><a href="#方式四：window-name-iframe——之前用了个框架就是用这种方式" class="headerlink" title="方式四：window.name+iframe——之前用了个框架就是用这种方式"></a><strong>方式四：window.name+iframe</strong>——之前用了个框架就是用这种方式</h3><p>window.name 通过在 iframe（一般动态创建 i）中加载跨域 HTML 文件来起作用。然后，HTML 文件将传递给请求者的字符串内容赋值给 window.name。然后，请求者可以检索 window.name 值作为响应。</p><ul><li>iframe 标签的跨域能力；</li><li>window.name 属性值在文档刷新后依旧存在的能力（且最大允许 2M 左右）。</li></ul><p>每个 iframe 都有包裹它的 window，而这个 window 是 top window 的子窗口。contentWindow 属性返回 <code>&lt;iframe&gt;</code> 元素的 Window 对象。你可以使用这个 Window 对象来访问 iframe 的文档及其内部 DOM。</p><p>示例代码</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--  下述用端口  10000表示：domainA 10001表示：domainB--></span><span class="token comment" spellcheck="true">&lt;!-- localhost:10000 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  iframe<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 隐藏</span>  <span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 防止页面无限刷新</span>  iframe<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>state <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 清除创建的iframe</span>          iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>state <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span>          <span class="token comment" spellcheck="true">// Blocked a frame with origin "http://localhost:10000" from accessing a cross-origin frame.</span>          iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">'http://localhost:10000/proxy.html'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:10001'</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- localhost:10001 --></span><span class="token doctype">&lt;!DOCTYPE html></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  window<span class="token punctuation">.</span>name <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方式五：window-postMessage"><a href="#方式五：window-postMessage" class="headerlink" title="方式五：window.postMessage()"></a><strong>方式五：window.postMessage()</strong></h3><p>HTML5 新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。</p><p>下述代码实现了跨域存储 localStorage</p><pre class="line-numbers language-html"><code class="language-html">!--  下述用端口  10000表示：domainA 10001表示：domainB--><span class="token comment" spellcheck="true">&lt;!-- localhost:10000 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:10001/msg.html<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myPostMessage<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">LSsetItem</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">'Test: '</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">LSgetItem</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'value: '</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">LSremoveItem</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> callbacks <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>source <span class="token operator">===</span> frames<span class="token punctuation">[</span><span class="token string">'myPostMessage'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>          <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token regex">/^#localStorage#(\d+)(null)?#([\S\s]*)/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>callbacks<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  callbacks<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'null'</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">delete</span> callbacks<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> domain <span class="token operator">=</span> <span class="token string">'*'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 增加</span>  <span class="token keyword">function</span> <span class="token function">LSsetItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>          setItem<span class="token punctuation">:</span> key<span class="token punctuation">,</span>          value<span class="token punctuation">:</span> value      <span class="token punctuation">}</span><span class="token punctuation">;</span>      frames<span class="token punctuation">[</span><span class="token string">'myPostMessage'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> domain<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 获取</span>  <span class="token keyword">function</span> <span class="token function">LSgetItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> identifier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>          identifier<span class="token punctuation">:</span> identifier<span class="token punctuation">,</span>          getItem<span class="token punctuation">:</span> key      <span class="token punctuation">}</span><span class="token punctuation">;</span>      callbacks<span class="token punctuation">[</span>identifier<span class="token punctuation">]</span> <span class="token operator">=</span> callback<span class="token punctuation">;</span>      frames<span class="token punctuation">[</span><span class="token string">'myPostMessage'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> domain<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 删除</span>  <span class="token keyword">function</span> <span class="token function">LSremoveItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>          removeItem<span class="token punctuation">:</span> key      <span class="token punctuation">}</span><span class="token punctuation">;</span>      frames<span class="token punctuation">[</span><span class="token string">'myPostMessage'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> domain<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- localhost:10001 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Receiver debugging'</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>origin <span class="token operator">==</span> <span class="token string">'http://localhost:10000'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> data <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'setItem'</span> <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>setItem<span class="token punctuation">,</span> data<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'getItem'</span> <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> gotItem <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>getItem<span class="token punctuation">)</span><span class="token punctuation">;</span>        event<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>          <span class="token string">'#localStorage#'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>identifier <span class="token operator">+</span>          <span class="token punctuation">(</span>gotItem <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">'null#'</span> <span class="token punctuation">:</span> <span class="token string">'#'</span> <span class="token operator">+</span> gotItem<span class="token punctuation">)</span><span class="token punctuation">,</span>          event<span class="token punctuation">.</span>origin        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'removeItem'</span> <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>removeItem<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 Safari 一下，会报错</p><h3 id="方式七：WebSocket"><a href="#方式七：WebSocket" class="headerlink" title="方式七：WebSocket"></a><strong>方式七：WebSocket</strong></h3><p>WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS</p><p>需要注意：WebSocket 对象不支持 DOM 2 级事件侦听器，必须使用 DOM 0 级语法分别定义各个事件。</p><h3 id="方式八：代理"><a href="#方式八：代理" class="headerlink" title="方式八：代理"></a><strong>方式八：代理</strong></h3><p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p><p>DomainA 客户端（浏览器） ==&gt; DomainA 服务器 ==&gt; DomainB 服务器 ==&gt; DomainA 客户端（浏览器）</p><p>来源：blog.csdn.net/ligang2585116/article/details/73072868</p><h2 id="9-说一下-JSONP-实现原理？"><a href="#9-说一下-JSONP-实现原理？" class="headerlink" title="9. 说一下 JSONP 实现原理？"></a>9. <strong>说一下 JSONP 实现原理？</strong></h2><p>jsonp 即 json+padding，<strong>动态创建 script 标签，利用 script 标签的 src 属性可以获取任何域下的 js 脚本，通过这个特性 (也可以说漏洞)，服务器端不在返货 json 格式，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域</strong>。</p><p>扩展阅读：<a href="https://www.cnblogs.com/soyxiaobi/p/9616011.html" target="_blank" rel="noopener">彻底弄懂jsonp原理及实现方法</a></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-说一下你熟悉的设计模式？"><a href="#1-说一下你熟悉的设计模式？" class="headerlink" title="1. 说一下你熟悉的设计模式？"></a>1. <strong>说一下你熟悉的设计模式？</strong></h2><p><strong>来源：cnblogs.com/ILoke-Yang/p/8054466.html</strong></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去 new，<strong>因为构造器是被 private 修饰的，一般通过 getInstance() 的方法来获取它们的实例</strong>。</p><p>getInstance() 的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看 demo 吧</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> singleton<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照我的习惯，我恨不得写满注释，怕你们看不懂，但是这个代码实在太简单了，所以我没写任何注释，如果这几行代码你都看不明白的话，那你可以洗洗睡了，等你睡醒了再来看我的博客说不定能看懂。</p><p>上面的是最基本的写法，也叫懒汉写法（线程不安全）下面我再公布几种单例模式的写法：</p><p><strong>懒汉式写法（线程安全）</strong></p><pre><code>public class Singleton {     private static Singleton instance;     private Singleton (){}     public static synchronized Singleton getInstance() {     if (instance == null) {         instance = new Singleton();     }     return instance;     }  }</code></pre><p><strong>饿汉式写法</strong></p><pre><code>public class Singleton {     private static Singleton instance = new Singleton();     private Singleton (){}     public static Singleton getInstance() {     return instance;     }  }</code></pre><p><strong>静态内部类</strong></p><pre><code>public class Singleton {     private static class SingletonHolder {     private static final Singleton INSTANCE = new Singleton();     }     private Singleton (){}     public static final Singleton getInstance() {     return SingletonHolder.INSTANCE;     }  }</code></pre><p><strong>枚举</strong></p><pre><code>public enum Singleton {     INSTANCE;     public void whateverMethod() {     }  }</code></pre><p>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，<strong>而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊</strong>，不过，个人认为由于 1.5 中才加入 enum 特性，用这种方式写不免让人感觉生疏。</p><p><strong>双重校验锁</strong></p><pre><code>public class Singleton {     private volatile static Singleton singleton;     private Singleton (){}     public static Singleton getSingleton() {     if (singleton == null) {         synchronized (Singleton.class) {         if (singleton == null) {             singleton = new Singleton();         }         }     }     return singleton;     }  }</code></pre><p><strong>总结</strong>：我个人比较喜欢静态内部类写法和饿汉式写法，其实这两种写法能够应付绝大多数情况了。其他写法也可以选择，主要还是看业务需求吧。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><strong>观察者模式</strong></h3><p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8visbqlbsj20b507d0ss.jpg" alt="640.jpg"></p><p>观察者模式 UML 图</p><p>看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。” 这句话被小王和小李听到了，结果乐坏了，蹭蹭蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进行相应的处理，看代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//小王和小李通过这个接口可以接收到小美发过来的消息</span>   <span class="token keyword">void</span> <span class="token function">getMessage</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打 getMessage 这个电话，拨打电话就是调用接口，看不懂没关系，先往下看</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LaoWang</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> String name <span class="token operator">=</span> <span class="token string">"小王"</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">LaoWang</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getMessage</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"接到了小美打过来的电话，电话内容是："</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LaoLi</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> String name <span class="token operator">=</span> <span class="token string">"小李"</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">LaoLi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getMessage</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"接到了小美打过来的电话，电话内容是：->"</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码很简单，我们再看看小美的代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XiaoMei</span> <span class="token punctuation">{</span>   List<span class="token operator">&lt;</span>Person<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">XiaoMei</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPerson</span><span class="token punctuation">(</span>Person person<span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历list，把自己的通知发送给所有暗恋自己的人</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Person person<span class="token operator">:</span>list<span class="token punctuation">)</span><span class="token punctuation">{</span>            person<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token string">"你们过来吧，谁先过来谁就能陪我一起玩儿游戏!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们写一个测试类来看一下结果对不对</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       XiaoMei xiao_mei <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoMei</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       LaoWang lao_wang <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LaoWang</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       LaoLi lao_li <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LaoLi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//小王和小李在小美那里都注册了一下</span>       xiao_mei<span class="token punctuation">.</span><span class="token function">addPerson</span><span class="token punctuation">(</span>lao_wang<span class="token punctuation">)</span><span class="token punctuation">;</span>       xiao_mei<span class="token punctuation">.</span><span class="token function">addPerson</span><span class="token punctuation">(</span>lao_li<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//小美向小王和小李发送通知</span>       xiao_mei<span class="token punctuation">.</span><span class="token function">notifyPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完美～</p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a><strong>装饰者模式</strong></h3><p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如 Java 中的 IO 流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。（ps：不知道上海哪里有卖好吃的三明治的，求推荐～）那我们应该怎么来写代码呢？ 首先，我们需要写一个 Food 类，让其他所有食物都来继承这个类，看代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> String food_name<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">Food</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token function">Food</span><span class="token punctuation">(</span>String food_name<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>food_name <span class="token operator">=</span> food_name<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> food_name<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码很简单，我就不解释了，然后我们写几个子类继承它：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//面包类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bread</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> Food basic_food<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">Bread</span><span class="token punctuation">(</span>Food basic_food<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>basic_food <span class="token operator">=</span> basic_food<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> basic_food<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"+面包"</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//奶油类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cream</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> Food basic_food<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">Cream</span><span class="token punctuation">(</span>Food basic_food<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>basic_food <span class="token operator">=</span> basic_food<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> basic_food<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"+奶油"</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//蔬菜类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vegetable</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> Food basic_food<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token function">Vegetable</span><span class="token punctuation">(</span>Food basic_food<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>basic_food <span class="token operator">=</span> basic_food<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> String <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> basic_food<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"+蔬菜"</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这几个类都是差不多的，构造方法传入一个 Food 类型的参数，然后在 make 方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的 Test 类是怎么写的，一看你就明白了</p><pre><code>public class Test {   public static void main(String[] args) {       Food food = new Bread(new Vegetable(new Cream(new Food(&quot;香肠&quot;))));       System.out.println(food.make());   }}</code></pre><p>看到没有，一层一层封装，我们从里往外看：最里面我 new 了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？ </p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><strong>适配器模式</strong></h3><p>将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是 20V，但是正常的电压是 220V，这时候就需要一个变压器，将 220V 的电压转换成 20V 的电压，这样，变压器就将 20V 的电压和手机联系起来了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Phone phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       VoltageAdapter adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoltageAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       phone<span class="token punctuation">.</span><span class="token function">setAdapter</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>       phone<span class="token punctuation">.</span><span class="token function">charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 手机类</span><span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> V <span class="token operator">=</span> <span class="token number">220</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 正常电压220v，是一个常量</span>   <span class="token keyword">private</span> VoltageAdapter adapter<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 充电</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">charge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       adapter<span class="token punctuation">.</span><span class="token function">changeVoltage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAdapter</span><span class="token punctuation">(</span>VoltageAdapter adapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>adapter <span class="token operator">=</span> adapter<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 变压器</span><span class="token keyword">class</span> <span class="token class-name">VoltageAdapter</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 改变电压的功能</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changeVoltage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正在充电..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始电压："</span> <span class="token operator">+</span> Phone<span class="token punctuation">.</span>V <span class="token operator">+</span> <span class="token string">"V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经过变压器转换之后的电压:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Phone<span class="token punctuation">.</span>V <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h3><p>简单工厂模式：一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 抽象产品类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体实现类</span><span class="token keyword">class</span> <span class="token class-name">Benz</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Benz开始启动了。。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Benz停车了。。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Ford</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Ford开始启动了。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Ford停车了。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 工厂类</span><span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">getCarInstance</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Car c <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"Benz"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Benz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"Ford"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> c<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Car c <span class="token operator">=</span> Factory<span class="token punctuation">.</span><span class="token function">getCarInstance</span><span class="token punctuation">(</span><span class="token string">"Benz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>           c<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           c<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"造不了这种汽车。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工厂方法模式：有四个角色，<strong>抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式</strong>。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 抽象产品角色</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>   <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体产品角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Plane</span> <span class="token keyword">implements</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"plane...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Broom</span> <span class="token keyword">implements</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"broom....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象工厂</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">{</span>   <span class="token keyword">abstract</span> Moveable <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlaneFactory</span> <span class="token keyword">extends</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> Moveable <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Plane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BroomFactory</span> <span class="token keyword">extends</span> <span class="token class-name">VehicleFactory</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> Moveable <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Broom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       VehicleFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroomFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       Moveable m <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       m<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>抽象工厂模式：与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">/</span>抽象工厂类<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> Vehicle <span class="token function">createVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> Weapon <span class="token function">createWeapon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> Food <span class="token function">createFood</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Food <span class="token function">createFood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Vehicle <span class="token function">createVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> Weapon <span class="token function">createWeapon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AK47</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       AbstractFactory f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       Vehicle v <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">createVehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       v<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       Weapon w <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">createWeapon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       w<span class="token punctuation">.</span><span class="token function">shoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       Food a <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">createFood</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       a<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代理模式（proxy）"><a href="#代理模式（proxy）" class="headerlink" title="代理模式（proxy）"></a><strong>代理模式（proxy）</strong></h3><p>有两种，静态代理和动态代理。先说静态代理，很多理论性的东西我不讲，我就算讲了，你们也看不懂。什么真实角色，抽象角色，代理角色，委托角色。。。乱七八糟的，我是看不懂。之前学代理模式的时候，去网上翻一下，资料一大堆，打开链接一看，基本上都是给你分析有什么什么角色，理论一大堆，看起来很费劲，不信的话你们可以去看看，我是看不懂他们在说什么。咱不来虚的，直接用生活中的例子说话。（注意：我这里并不是否定理论知识，我只是觉得有时候理论知识晦涩难懂，喜欢挑刺的人一边去，你是来学习知识的，不是来挑刺的）<br>到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样的：家里人催婚 -&gt; 男女双方家庭商定结婚的黄道即日 -&gt; 找一家靠谱的婚庆公司 -&gt; 在约定的时间举行结婚仪式 -&gt; 结婚完毕<br>婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知。。。别担心，不是黑中介，我们只要把钱给人家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色，现在明白什么是代理角色了吧。</p><p>代码实现请看：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//代理接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProxyInterface</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写</span><span class="token keyword">void</span> <span class="token function">marry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//代理吃饭(自己的饭，让别人吃去吧)</span><span class="token comment" spellcheck="true">//void eat();</span><span class="token comment" spellcheck="true">//代理拉屎，自己的屎，让别人拉去吧</span><span class="token comment" spellcheck="true">//void shit();</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文明社会，代理吃饭，代理拉屎什么的我就不写了，有伤社会风化～～～能明白就好</p><p>好了，我们看看婚庆公司的代码:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeddingCompany</span> <span class="token keyword">implements</span> <span class="token class-name">ProxyInterface</span> <span class="token punctuation">{</span><span class="token keyword">private</span> ProxyInterface proxyInterface<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">WeddingCompany</span><span class="token punctuation">(</span>ProxyInterface proxyInterface<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>proxyInterface <span class="token operator">=</span> proxyInterface<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">marry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们是婚庆公司的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们在做结婚前的准备工作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"节目彩排..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"礼物购买..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工作人员分工..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"可以开始结婚了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> proxyInterface<span class="token punctuation">.</span><span class="token function">marry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到没有，婚庆公司需要做的事情很多，我们再看看结婚家庭的代码:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NormalHome</span> <span class="token keyword">implements</span> <span class="token class-name">ProxyInterface</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">marry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我们结婚啦～"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个已经很明显了，结婚家庭只需要结婚，而婚庆公司要包揽一切，前前后后的事情都是婚庆公司来做，听说现在婚庆公司很赚钱的，这就是原因，干的活多，能不赚钱吗？</p><p>来看看测试类代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> ProxyInterface proxyInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeddingCompany</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NormalHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> proxyInterface<span class="token punctuation">.</span><span class="token function">marry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-简单工厂和抽象工厂有什么区别？"><a href="#2-简单工厂和抽象工厂有什么区别？" class="headerlink" title="2. 简单工厂和抽象工厂有什么区别？"></a>2. <strong>简单工厂和抽象工厂有什么区别？</strong></h2><p><strong>简单工厂模式</strong>：</p><p>这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。</p><p>它由三种角色组成：</p><ul><li>工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的 Driver 类。</li><li>抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的 Car 接口。</li><li>具体产品角色：工厂类所创建的对象就是此角色的实例。在 java 中由一个具体类实现，如例子中的 Benz、Bmw 类。</li></ul><p>来用类图来清晰的表示下的它们之间的关系：</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vj0taiahj20fg05rwea.jpg" alt="img"></p><p><strong>抽象工厂模式：</strong></p><p>先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vj0tgw7yj20pk0eat8p.jpg" alt="img"></p><p>图中的 BmwCar 和 BenzCar 就是两个产品树（产品层次结构）；而如图所示的 BenzSportsCar 和 BmwSportsCar 就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理 BmwBussinessCar 和 BenzBusinessCar 也是一个产品族。</p><p><strong>可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。</strong></p><p>而且使用抽象工厂模式还要满足一下条件：</p><ol><li>系统中有多个产品族，而系统一次只可能消费其中一族产品</li><li>同属于同一个产品族的产品以其使用。</li></ol><p>来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：</p><ul><li>抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在 java 中它由抽象类或者接口来实现。</li><li>具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在 java 中它由具体的类来实现。</li><li>抽象产品角色：它是具体产品继承的父类或者是实现的接口。在 java 中一般有抽象类或者接口来实现。</li><li>具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在 java 中由具体的类来实现。</li></ul><h1 id="Spring、SpringMVC——结合项目来理解"><a href="#Spring、SpringMVC——结合项目来理解" class="headerlink" title="Spring、SpringMVC——结合项目来理解"></a>Spring、SpringMVC——结合项目来理解</h1><blockquote><p>任何框架的目的都是为了提高开发效率</p></blockquote><h2 id="1-为什么要使用-spring？"><a href="#1-为什么要使用-spring？" class="headerlink" title="1. 为什么要使用 spring？"></a>1. <strong>为什么要使用 spring？</strong></h2><p><strong>1. 简介</strong></p><ul><li>目的：解决企业应用开发的复杂性</li><li>功能：使用基本的 JavaBean 代替 EJB，并提供了更多的企业应用功能</li><li>范围：任何 Java 应用</li></ul><p>简单来说，Spring 是一个轻量级的控制反转 (IoC) 和面向切面 (AOP) 的容器框架。</p><p><strong>2. 轻量</strong>　　</p><p>从大小与开销两方面而言 Spring 都是轻量的。完整的 Spring 框架可以在一个大小只有 1MB 多的 JAR 文件里发布。并且 Spring 所需的处理开销也是微不足道的。此外，Spring 是非侵入式的：典型地，Spring 应用中的对象不依赖于 Spring 的特定类。</p><p><strong>3. 控制反转</strong>　　</p><p><strong>Spring 通过一种称作控制反转（IoC）的技术促进了松耦合</strong>。当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为 IoC 与 JNDI 相反——<strong>不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它</strong>。</p><p><strong>4. 面向切面</strong>　　</p><p>Spring 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</p><p><strong>5. 容器</strong></p><p>S<strong>pring 包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个 bean 如何被创建——基于一个可配置原型（prototype），你的 bean 可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的</strong>。然而，Spring 不应该被混同于传统的重量级的 EJB 容器，它们经常是庞大与笨重的，难以使用。</p><p><strong>6. 框架</strong></p><p>Spring 可以将简单的组件配置、组合成为复杂的应用。在 Spring 中，应用对象被声明式地组合，典型地是在一个 XML 文件里。Spring 也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p><p>所有 Spring 的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为 Spring 中的各种模块提供了基础支持。</p><p><strong>91. 解释一下什么是 aop？</strong></p><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP 引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP 则显得无能为力。也就是说，OOP 允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在 OOP 设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>而 AOP 技术则恰恰相反，它利用一种称为 “横切” 的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为 “Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP 代表的是一个横向的关系，如果说“对象” 是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的 “方面” 了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p><p><strong>使用 “横切” 技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如 Avanade 公司的高级方案构架师 Adam Magee 所说，AOP 的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p><h2 id="2-解释一下什么是-ioc？"><a href="#2-解释一下什么是-ioc？" class="headerlink" title="2. 解释一下什么是 ioc？"></a>2. <strong>解释一下什么是 ioc？</strong></h2><blockquote><p>解决依赖关系，用IOC作为中间桥梁。</p></blockquote><p>IOC 是 Inversion of Control 的缩写，多数书籍翻译成 “控制反转”。</p><p>1996 年，Michael Mattson 在一篇有关探讨面向对象框架的文章中，首先提出了 IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，<strong>简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的</strong>，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p><p>IOC 理论提出的观点大体是这样的：<strong>借助于 “第三方” 实现具有依赖关系的对象之间的解耦</strong>。如下图</p><p><img src="E:%5CHexoBlog%5Cnew_hexo%5Cnew_hexo%5Csource_posts%5C2019%5C11%5Cassets%5C640-1573561786732.jpg" alt="img"></p><p>大家看到了吧，由于引进了中间位置的 “第三方”，<strong>也就是 IOC 容器，使得 A、B、C、D 这 4 个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方” 了，全部对象的控制权全部上缴给 “第三方”IOC 容器，所以，IOC 容器成了整个系统的关键核心，它起到了一种类似“粘合剂” 的作用</strong>，把系统中的所有对象粘合在一起发挥作用，如果没有这个 “粘合剂”，对象与对象之间会彼此失去联系，这就是有人把 IOC 容器比喻成“粘合剂” 的由来。</p><p>我们再来做个试验：把上图中间的 IOC 容器拿掉，然后再来看看这套系统：</p><p><img src="E:%5CHexoBlog%5Cnew_hexo%5Cnew_hexo%5Csource_posts%5C2019%5C11%5Cassets%5C640-1573561817893.png" alt="img"></p><p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D 这 4 个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现 A 的时候，根本无须再去考虑 B、C 和 D 了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现 IOC 容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！</p><h2 id="3-spring-有哪些主要模块？"><a href="#3-spring-有哪些主要模块？" class="headerlink" title="3. spring 有哪些主要模块？"></a>3. <strong>spring 有哪些主要模块？</strong></h2><p>Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vjkjlpewj20mb0hct9o.jpg" alt="640-1573562570082.jpg"></p><h2 id="4-spring-常用的注入方式有哪些？"><a href="#4-spring-常用的注入方式有哪些？" class="headerlink" title="4. spring 常用的注入方式有哪些？"></a>4. <strong>spring 常用的注入方式有哪些？</strong></h2><p>Spring 通过 DI（依赖注入）实现 IOC（控制反转），常用的注入方式主要有三种：</p><ol><li>构造方法注入</li><li>setter 注入</li><li>基于注解的注入——》用的最多</li></ol><h2 id="5-spring-中的-bean-是线程安全的吗？"><a href="#5-spring-中的-bean-是线程安全的吗？" class="headerlink" title="5. spring 中的 bean 是线程安全的吗？"></a>5. <strong>spring 中的 bean 是线程安全的吗？</strong></h2><p>Spring 容器中的 Bean 是否线程安全，容器本身并没有提供 Bean 的线程安全策略，<strong>因此可以说 spring 容器中的 Bean 本身不具备线程安全的特性</strong>，但是具体还是要结合具体 <strong>scope 的 Bean 去研究</strong>。</p><h2 id="6-spring-支持几种-bean-的作用域？"><a href="#6-spring-支持几种-bean-的作用域？" class="headerlink" title="6. spring 支持几种 bean 的作用域？"></a>6. <strong>spring 支持几种 bean 的作用域？</strong></h2><blockquote><p>默认是singleton</p></blockquote><p>当通过 spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 实例的实例化，还可以为 Bean 指定特定的作用域。Spring 支持如下 5 种作用域：</p><ul><li>singleton：单例模式，在整个 Spring IoC 容器中，使用 singleton 定义的 Bean 将只有一个实例</li><li>prototype：原型模式，每次通过容器的 getBean 方法获取 prototype 定义的 Bean 时，都将产生一个新的 Bean 实例</li><li>request：对于每次 HTTP 请求，使用 request 定义的 Bean 都将产生一个新实例，即每次 HTTP 请求将会产生不同的 Bean 实例。只有在 Web 应用中使用 Spring 时，该作用域才有效——</li><li>session：对于每次 HTTP Session，使用 session 定义的 Bean 豆浆产生一个新实例。同样只有在 Web 应用中使用 Spring 时，该作用域才有效</li><li>globalsession：每个全局的 HTTP Session，使用 session 定义的 Bean 都将产生一个新实例。典型情况下，仅在使用 portlet context 的时候有效。同样只有在 Web 应用中使用 Spring 时，该作用域才有效</li></ul><p>其中比较常用的是 singleton 和 prototype 两种作用域。对于 singleton 作用域的 Bean，每次请求该 Bean 都将获得相同的实例。容器负责跟踪 Bean 实例的状态，负责维护 Bean 实例的生命周期行为；如果一个 Bean 被设置成 prototype 作用域，程序每次请求该 id 的 Bean，Spring 都会新建一个 Bean 实例，然后返回给程序。在这种情况下，Spring 容器仅仅使用 new 关键字创建 Bean 实例，<strong>一旦创建成功，容器不在跟踪实例，也不会维护 Bean 实例的状态</strong>。</p><p><strong>如果不指定 Bean 的作用域，Spring 默认使用 singleton 作用域</strong>。Java 在创建 Java 实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype 作用域 Bean 的创建、销毁代价比较大。而 singleton 作用域的 Bean 实例一旦创建成功，可以重复使用。<strong>因此，除非必要，否则尽量避免将 Bean 被设置成 prototype 作用域</strong>。</p><h2 id="7-spring-自动装配-bean-有哪些方式？"><a href="#7-spring-自动装配-bean-有哪些方式？" class="headerlink" title="7. spring 自动装配 bean 有哪些方式？"></a>7. <strong>spring 自动装配 bean 有哪些方式？</strong></h2><p>Spring 容器负责创建应用程序中的 bean 同时通过 ID 来协调这些对象之间的关系。作为开发人员，<strong>我们需要告诉 Spring 要创建哪些 bean 并且如何将其装配到一起</strong>。</p><p>spring 中 bean 装配有两种方式：</p><ul><li>隐式的 bean 发现机制和自动装配</li><li>在 java 代码或者 XML 中进行显示配置</li></ul><p>当然这些方式也可以配合使用。</p><h2 id="8-spring-事务实现方式有哪些？"><a href="#8-spring-事务实现方式有哪些？" class="headerlink" title="8. spring 事务实现方式有哪些？"></a>8. <strong>spring 事务实现方式有哪些？</strong></h2><ol><li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用 beginTransaction()、commit()、rollback() 等事务管理相关的方法，这就是编程式事务管理。</li><li>基于 TransactionProxyFactoryBean 的声明式事务管理</li><li>基于 @Transactional 的声明式事务管理</li><li>基于 Aspectj AOP 配置事务</li></ol><h2 id="9-说一下-spring-的事务隔离？"><a href="#9-说一下-spring-的事务隔离？" class="headerlink" title="9.说一下 spring 的事务隔离？"></a>9.<strong>说一下 spring 的事务隔离？</strong></h2><p>事务隔离级别指的<strong>是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据</strong>时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><ul><li>脏读：一个事务读到另一个事务未提交的更新数据。</li><li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的 “全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入 “一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li><li>不可重复读：比方说在同一个事务中先后执行两条一模一样的 select 语句，期间在此次事务中没有执行过任何 DDL 语句，但先后得到的结果不一致，这就是不可重复读。</li></ul><h2 id="10-说一下-spring-mvc-运行流程？"><a href="#10-说一下-spring-mvc-运行流程？" class="headerlink" title="10.说一下 spring mvc 运行流程？"></a>10.<strong>说一下 spring mvc 运行流程？</strong></h2><p><strong>Spring MVC 运行流程图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vjsc7pxaj20oe0ekwfn.jpg" alt="640-1573563025725.jpg"></p><p><strong>Spring 运行流程描述：</strong></p><ol><li><p>用户向服务器发送请求，请求被 Spring 前端控制 Servelt DispatcherServlet 捕获；</p></li><li><p>DispatcherServlet 对请求 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 对象的形式返回；</p></li><li><p>DispatcherServlet 根据获得的 Handler，选择一个合适的 HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 preHandler(…) 方法）</p></li><li><p>提取 Request 中的模型数据，填充 Handler 入参，开始执行 Handler（Controller)。 在填充 Handler 的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</p></li></ol><ul><li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息</li><li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等</li><li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中</li></ul><ol start="5"><li><p>Handler 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</p></li><li><p>根据返回的 ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver) 返回给 DispatcherServlet ；</p></li><li><p>ViewResolver 结合 Model 和 View，来渲染视图；</p></li><li><p>将渲染结果返回给客户端。</p></li></ol><h2 id="11-spring-mvc-有哪些组件？"><a href="#11-spring-mvc-有哪些组件？" class="headerlink" title="11. spring mvc 有哪些组件？"></a><strong>11. spring mvc 有哪些组件？</strong></h2><p>Spring MVC 的核心组件：</p><ol><li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li><li>Controller：具体处理请求的控制器</li><li>HandlerMapping：映射处理器，负责映射中央处理器转发给 controller 时的映射策略</li><li>ModelAndView：服务层返回的数据和视图层的封装类</li><li>ViewResolver：视图解析器，解析具体的视图</li><li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li></ol><h2 id="12-RequestMapping-的作用是什么？"><a href="#12-RequestMapping-的作用是什么？" class="headerlink" title="12. @RequestMapping 的作用是什么？"></a>12. <strong>@RequestMapping 的作用是什么？</strong></h2><p>RequestMapping 是一个用来<strong>处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</strong>。</p><p>RequestMapping 注解有六个属性，下面我们把她分成三类进行说明。</p><h3 id="value，-method："><a href="#value，-method：" class="headerlink" title="value， method："></a><strong>value， method：</strong></h3><ul><li>value：指定请求的实际地址，指定的地址可以是 URI Template 模式（后面将会说明）；</li><li>method：指定请求的 method 类型， GET、POST、PUT、DELETE 等；</li></ul><h3 id="consumes，produces"><a href="#consumes，produces" class="headerlink" title="consumes，produces"></a><strong>consumes，produces</strong></h3><ul><li>consumes：指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html；</li><li>produces：指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回；</li></ul><h3 id="params，headers"><a href="#params，headers" class="headerlink" title="params，headers"></a><strong>params，headers</strong></h3><ul><li>params： 指定 request 中必须包含某些参数值是，才让该方法处理。</li><li>headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。</li></ul><h1 id="SpringBoot、SpringCloud——结合项目来理解"><a href="#SpringBoot、SpringCloud——结合项目来理解" class="headerlink" title="SpringBoot、SpringCloud——结合项目来理解"></a>SpringBoot、SpringCloud——结合项目来理解</h1><h2 id="1-什么是-spring-boot？"><a href="#1-什么是-spring-boot？" class="headerlink" title="1. 什么是 spring boot？"></a><strong>1. 什么是 spring boot？</strong></h2><p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建<code>&lt;bean&gt;</code>，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p><p>SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，<strong>所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件</strong>。</p><h2 id="2-为什么要用-spring-boot？"><a href="#2-为什么要用-spring-boot？" class="headerlink" title="2. 为什么要用 spring boot？"></a><strong>2. 为什么要用 spring boot？</strong></h2><ul><li>Spring Boot使编码变简单</li><li>Spring Boot使配置变简单</li><li>Spring Boot使部署变简单</li><li>Spring Boot使监控变简单</li><li>Spring的不足</li></ul><h2 id="3-spring-boot-核心配置文件是什么？"><a href="#3-spring-boot-核心配置文件是什么？" class="headerlink" title="3. spring boot 核心配置文件是什么？"></a><strong>3. spring boot 核心配置文件是什么？</strong></h2><p>Spring Boot提供了两种常用的配置文件：</p><ul><li>properties文件</li><li>yml文件——》推荐</li></ul><h2 id="4-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#4-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="4. spring boot 配置文件有哪几种类型？它们有什么区别？"></a><strong>4. spring boot 配置文件有哪几种类型？它们有什么区别？</strong></h2><p>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。——类似于python</p><h2 id="5-spring-boot-有哪些方式可以实现热部署？"><a href="#5-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="5. spring boot 有哪些方式可以实现热部署？"></a><strong>5. spring boot 有哪些方式可以实现热部署？</strong></h2><p>SpringBoot热部署实现有两种方式：</p><p><strong>①. 使用spring loaded</strong></p><p>在项目中添加如下</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- springBoot编译插件--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!-- spring热部署 --></span>                    <span class="token comment" spellcheck="true">&lt;!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 --></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springloaded<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加完毕后需要使用mvn指令运行：</p><p>首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的”+”,然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）</p><p>　　　<img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vkzr8ec8j20tz0l2dgo.jpg" alt="640-1573565538706.png"></p><p>　</p><p>点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vl0b02iyj207402gglg.jpg" alt="640-1573565571223.png"></p><p><strong>②. 使用spring-boot-devtools</strong></p><p>在项目的pom文件中添加依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!--热部署jar--></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后：使用 shift+ctrl+alt+”/“ （IDEA中的快捷键） 选择”Registry” 然后勾选 compiler.automake.allow.when.app.running</p><h2 id="6-jpa-和-hibernate-有什么区别？"><a href="#6-jpa-和-hibernate-有什么区别？" class="headerlink" title="6. jpa 和 hibernate 有什么区别？"></a><strong>6. jpa 和 hibernate 有什么区别？</strong></h2><ul><li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。</li><li><strong>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集</strong>。</li><li>JPA和Hibernate之间的关系，可以简单的理解为J<strong>PA是标准接口，Hibernate是实现</strong>。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li><li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li><li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li><li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li></ul><h2 id="7-什么是-spring-cloud？"><a href="#7-什么是-spring-cloud？" class="headerlink" title="7. 什么是 spring cloud？"></a><strong>7. 什么是 spring cloud？</strong></h2><p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p><p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p><ul><li>配置管理</li><li>服务注册与发现</li><li>断路器</li><li>智能路由</li><li>服务间调用</li><li>负载均衡</li><li>微代理</li><li>控制总线</li><li>一次性令牌</li><li>全局锁</li><li>领导选举</li><li>分布式会话</li><li>集群状态</li><li>分布式消息</li><li>……</li></ul><p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p><h2 id="8-spring-cloud-断路器的作用是什么？"><a href="#8-spring-cloud-断路器的作用是什么？" class="headerlink" title="8. spring cloud 断路器的作用是什么？"></a><strong>8. spring cloud 断路器的作用是什么？</strong></h2><p>在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p><h2 id="9-spring-cloud-的核心组件有哪些？"><a href="#9-spring-cloud-的核心组件有哪些？" class="headerlink" title="9. spring cloud 的核心组件有哪些？"></a><strong>9. spring cloud 的核心组件有哪些？</strong></h2><p><strong>①. 服务发现——Netflix Eureka</strong></p><p>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</p><p><strong>②. 客服端负载均衡——Netflix Ribbon</strong></p><p>Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。</p><p><strong>③. 断路器——Netflix Hystrix</strong></p><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><p><strong>④. 服务网关——Netflix Zuul</strong></p><p>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p><p><strong>⑤. 分布式配置——Spring Cloud Config</strong></p><p>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试——基础部分1</title>
      <link href="/2019/11/12/2019/11/java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%861/"/>
      <url>/2019/11/12/2019/11/java%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%861/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java一直是后端开发语言中的一哥般的存在，自己也接触过其他后端开发语言，比如php、nodejs、golang等。相比之下，java的优势显而易见，库多，代码虽然很冗长但是很清晰，适合做大型项目。未来能够和java一争高下的应该是golang，golang在区块链开发领域很火，暂时java开发后端不用担心什么。</p><p>由于java后端涉及到了太多太多东西了，肯定是覆盖不完的，这里只选取常见的一些基础知识、面试题进行整理。大致分为三个部分：基础、中级、高级。</p><p>GitHub上已经有大神整理过类似的资料，为什么自己还要重新造轮子呢？因为知识只有经过自己理解后才算是真正的掌握了。毕竟那是别人的！</p><p>这篇讲解java基础部分</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-main函数"><a href="#1-main函数" class="headerlink" title="1. main函数"></a>1. main函数</h2><p>main函数是程序执行的入口，关于main函数有如下几点需要注意：</p><ul><li>main函数返回值</li><li>main函数参数</li></ul><p>java的main函数和c/c++的main函数有所不同，c/c++main函数有返回值(int 类型)，而java的main函数没有返回值(void)。<strong>首先我们要知道这个返回值的作用是用来代表程序退出时的 exit code，一般被命令解释器或其他外部程序调用，用来确定流程是否完成。</strong></p><p>在Java中 <strong>void</strong> 返回值表示了不由程序返回<code>exit code</code>退出，当没有其他守护线程的时候， JVM 会调用 <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/lang/hook-design.html" target="_blank" rel="noopener">Shutdown Hook</a> 退出，如果有守护线程在运行 JVM 不会退出。在 Java 中想要实现像 C 语言那样的退出可以调用 <code>System.exit(0);</code> </p><blockquote><p>我们可以换一方式理解c/c++程序的调用：<strong>C 程序运行起来以后，实际上入口可以这样理解：exit(main(*))，而这个 exit 函数才是真正的入口，它的参数就是 main 的返回值。而 Java 有运行时的帮忙，程序结束（不管是正常还是非正常情况）自动返回 <code>exit code</code>或者手动调用<code>System.exit</code>。</strong></p></blockquote><p>main函数的参数是字符串，一个程序的执行我们可以看做事一个函数的调用，通过传入当前的运行环境，比如执行文件路径、操作系统类型等。注意这里的函数参数类型不能随意更改，入口函数只能是<code>public static void main(String args[])</code>。</p><blockquote><p>留一个小问题：web项目没有main函数，却能够正常运行，这是为什么？</p></blockquote><h2 id="2-JDK-和-JRE-有什么区别？"><a href="#2-JDK-和-JRE-有什么区别？" class="headerlink" title="2. JDK 和 JRE 有什么区别？"></a>2. <strong>JDK 和 JRE 有什么区别？</strong></h2><p>这根问题非常容易忽略。</p><ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul><p>简单来讲，如果只需要运行java程序，安装jre即可，如果要开发，调试java程序需要安装jdk。jdk里面包含有jre</p><h2 id="3-和-equals-的区别是什么？"><a href="#3-和-equals-的区别是什么？" class="headerlink" title="3. == 和 equals 的区别是什么？"></a>3. <strong>== 和 equals 的区别是什么？</strong></h2><blockquote><ul><li>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</li><li>equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</li></ul></blockquote><p>例子：</p><pre class="line-numbers language-java"><code class="language-java">        String x <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>        String y <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>        String z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">==</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String() 方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>java中Object的equal方法如下：</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>java中String的equal方法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><h2 id="4-两个对象的-hashCode-相同，则-equals-也一定为-true么"><a href="#4-两个对象的-hashCode-相同，则-equals-也一定为-true么" class="headerlink" title="4. 两个对象的 hashCode() 相同，则 equals() 也一定为 true么"></a>4. <strong>两个对象的 hashCode() 相同，则 equals() 也一定为 true么</strong></h2><blockquote><p>哈希值存在碰撞，所以在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p></blockquote><p>接着上面的equal，顺便就吧hashcode讲了。知道散列表都知道碰撞的问题，所以哈希值也不例外，如果出现了碰撞，那么equals就不相等。</p><p>以String为例，它的hashcode代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> hash<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            hash <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码</p><pre class="line-numbers language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"通话"</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token string">"重地"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"str1：%d | str2：%d"</span><span class="token punctuation">,</span>  str1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>str2<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-java"><code class="language-java">执行的结果：str1：<span class="token number">1179395</span> <span class="token operator">|</span> str2：<span class="token number">1179395</span><span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p></blockquote><h3 id="hashCode介绍"><a href="#hashCode介绍" class="headerlink" title="hashCode介绍"></a>hashCode介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，<strong>HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</strong>（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象<strong>在哈希表中的索引位置</strong>。<strong>hashCode() 在散列表中才有用，在其它情况下没用</strong>。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><h2 id="5-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#5-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="5.  java 中操作字符串都有哪些类？它们之间有什么区别？"></a>5.  <strong>java 中操作字符串都有哪些类？它们之间有什么区别？</strong></h2><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>他们的区别在于：</p><ul><li>String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象。</li><li>StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</li></ul><p>StringBuffer 和 StringBuilder 最大的区别在于：</p><ul><li>StringBuffer 是线程安全的（使用synchronized实现），而 StringBuilder 是非线程安全的，<strong>但 StringBuilder 的性能却高于 StringBuffer</strong>，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</li></ul><blockquote><p>它们底层都是用字符数组实现的。String中字符数组用final限定不可变，StringBuffer，StringBuilder没有限制，但同样有扩容的过程。</p></blockquote><p>扩容的代码</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">newCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> MAX_ARRAY_SIZE <span class="token operator">-</span> newCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token operator">?</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span>            <span class="token operator">:</span> newCapacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-String-str-”i”-与-String-str-new-String-“i”-一样吗？"><a href="#6-String-str-”i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="6.  String str=”i” 与 String str=new String(“i”) 一样吗？"></a>6.  <strong>String str=”i” 与 String str=new String(“i”) 一样吗？</strong></h2><blockquote><ul><li>用``的方式赋值会放在常量池里面</li><li>用new的方式会分配到堆内存中，因为这个时候看成了对象。</li></ul></blockquote><p>不一样，因为内存的分配方式不一样。String str=”i” 的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h2 id="7-接口和抽象类有什么区别？"><a href="#7-接口和抽象类有什么区别？" class="headerlink" title="7. 接口和抽象类有什么区别？"></a>7. <strong>接口和抽象类有什么区别？</strong></h2><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><h2 id="8-java-中-IO-流分为几种？"><a href="#8-java-中-IO-流分为几种？" class="headerlink" title="8. java 中 IO 流分为几种？"></a>8. <strong>java 中 IO 流分为几种？</strong></h2><ul><li>按功能来分：输入流（input）、输出流（output）。</li><li>按类型来分：字节流和字符流。</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>字节流和字符流的区别是：字节流按 <strong>8 位传输以字节为单位</strong>输入输出数据，<strong>字符流按 16 位传输以字符</strong>为单位输入输出数据。——一个字符两个字节，一个字节8位</p><p>java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img src="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" alt></p><p>按操作对象分类结构图:</p><p><img src="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" alt="IO-æä½å¯¹è±¡åç±»"></p><h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，<strong>问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题</strong>。所以， I/O 流就干脆提供了一个直接操作字符的接口，<strong>方便我们平时对字符进行流操作</strong>。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h2 id="9-BIO、NIO、AIO-有什么区别？"><a href="#9-BIO、NIO、AIO-有什么区别？" class="headerlink" title="9. BIO、NIO、AIO 有什么区别？"></a>9. <strong>BIO、NIO、AIO 有什么区别？</strong></h2><p>关于iO这块后面会出一篇正对性的文章来讲解，这里只大致了解下区别。</p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，<strong>客户端和服务器端通过 Channel（通道）通讯，实现了多路复用</strong>。——本质多路复用</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的<strong>操作基于事件和回调机制</strong>。——真正的异步，基于系统事件、回调</li></ul><blockquote><p>补充：</p><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code>两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。<strong>异步 IO 是基于事件和回调机制实现的</strong>，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，<strong>但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。</strong>查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul></blockquote><h2 id="13-深拷贝-vs-浅拷贝"><a href="#13-深拷贝-vs-浅拷贝" class="headerlink" title="13. 深拷贝 vs 浅拷贝"></a>13. 深拷贝 vs 浅拷贝</h2><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行<strong>引用传递般的拷贝</strong>，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，<strong>对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝</strong>。</li></ol><p><a href="https://camo.githubusercontent.com/d6d8355e9c0cbde0bdf8a53d34b0e2b46bbaa5e7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f6a6176612d646565702d616e642d7368616c6c6f772d636f70792e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d6d8355e9c0cbde0bdf8a53d34b0e2b46bbaa5e7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f6a6176612d646565702d616e642d7368616c6c6f772d636f70792e6a7067" alt="deep and shallow copy"></a></p><h2 id="10-为什么-Java-中只有值传递？"><a href="#10-为什么-Java-中只有值传递？" class="headerlink" title="10 . 为什么 Java 中只有值传递？"></a>10 . 为什么 Java 中只有值传递？</h2><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>下面通过 3 个例子来给大家说明</strong></p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num1 = "</span> <span class="token operator">+</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num2 = "</span> <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a = "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b = "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><pre><code>a = 20b = 10num1 = 10num2 = 20</code></pre><p><strong>解析：</strong></p><p><a href="https://camo.githubusercontent.com/ab46506b1a5ce09a516051c35f981e55255337f9/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f32323139313334382e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ab46506b1a5ce09a516051c35f981e55255337f9/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f32323139313334382e6a7067" alt="example 1 "></a></p><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><h3 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h3><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">change</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将数组的第一个元素变为0</span>        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><pre><code>10</code></pre><p><strong>解析：</strong></p><p><a href="https://camo.githubusercontent.com/b7bad9506150c29bb8d7debd3905bd7a71cd6611/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f333832353230342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/b7bad9506150c29bb8d7debd3905bd7a71cd6611/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f333832353230342e6a7067" alt="example 2"></a></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><h3 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小张"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"小李"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Test<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s1:"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s2:"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Student x<span class="token punctuation">,</span> Student y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Student temp <span class="token operator">=</span> x<span class="token punctuation">;</span>        x <span class="token operator">=</span> y<span class="token punctuation">;</span>        y <span class="token operator">=</span> temp<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x:"</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"y:"</span> <span class="token operator">+</span> y<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结果：</strong></p><pre><code>x:小李y:小张s1:小张s2:小李</code></pre><p><strong>解析：</strong></p><p>交换之前：</p><p><a href="https://camo.githubusercontent.com/9d6dd0313695d309280675cd3251b47432a28814/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f38383732393831382e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9d6dd0313695d309280675cd3251b47432a28814/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f38383732393831382e6a7067" alt="img"></a></p><p>交换之后：</p><p><a href="https://camo.githubusercontent.com/6bea9b0ed65609d699207ab787f631f7ba0a9246/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f33343338343431342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6bea9b0ed65609d699207ab787f631f7ba0a9246/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f33343338343431342e6a7067" alt="img"></a></p><p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p><p>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p><h2 id="11-关于-final-关键字的一些问题"><a href="#11-关于-final-关键字的一些问题" class="headerlink" title="11. 关于 final 关键字的一些问题"></a>11. 关于 final 关键字的一些问题</h2><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>使用final方法的原因有两个。第一个原因是把方法锁定<strong>，以防任何继承类修改它的含义</strong>；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol><h2 id="12-Java序列化中如果有些字段不想进行序列化，怎么办？"><a href="#12-Java序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="12. Java序列化中如果有些字段不想进行序列化，怎么办？"></a>12. Java序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用<strong>transient</strong>关键字修饰。</p><blockquote><p>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。<strong>transient只能修饰变量，不能修饰类和方法</strong>。</p></blockquote><h2 id="13-构造器-Constructor-是否可被-override"><a href="#13-构造器-Constructor-是否可被-override" class="headerlink" title="13.构造器 Constructor 是否可被 override?"></a>13.构造器 Constructor 是否可被 override?</h2><p>在讲继承的时候我们就知道父类的<strong>私有属性和构造方法并不能被继承</strong>，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h1 id="容器、集合"><a href="#容器、集合" class="headerlink" title="容器、集合"></a>容器、集合</h1><p>集合类型是编程语言中自带的非常基础的数据结构。最基础的是数组和链表，接下来有队列，栈，字典，set等等。相当于这些集合就是提供给开发人员最为基础的数据结构。</p><h2 id="1-java-容器都有哪些？"><a href="#1-java-容器都有哪些？" class="headerlink" title="1. java 容器都有哪些？"></a>1. <strong>java 容器都有哪些？</strong></h2><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8v8vu8sgyj20k00eh3yv.jpg" alt="640.jpg"></p><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. <strong>Collection 和 Collections 有什么区别？</strong></h2><blockquote><p>一个是接口，一个是类</p></blockquote><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是<strong>为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有 List 与 Set</strong>。</li><li>Collections 则是集合类的一个工具类 / 帮助类，<strong>其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作</strong>。</li></ul><h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. <strong>List、Set、Map 之间的区别是什么？</strong></h2><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8v94gyu7bj20nu0at0tk.jpg" alt="6410.jpg"></p><h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. <strong>HashMap 和 Hashtable 有什么区别？</strong></h2><ul><li>hashMap 去掉了 HashTable 的 contains 方法，<strong>但是加上了 containsValue（）和 containsKey（）方法</strong>。</li><li>hashTable 同步的，而 HashMap 是非同步的，效率上逼 hashTable 要高。</li><li>hashMap 允许空键值，而 hashTable 不允许。</li></ul><h2 id="5-如何决定使用-HashMap-还是-TreeMap？"><a href="#5-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使用 HashMap 还是 TreeMap？"></a>5. <strong>如何决定使用 HashMap 还是 TreeMap？</strong></h2><blockquote><p>map：插入，删除，查找</p><p>treemap：有序的key遍历</p></blockquote><p>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。</p><p>然而，假如你需要对一个有序的 key <strong>集合进行遍历，TreeMap 是更好的选择</strong>。基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，将 map 换为 TreeMap 进行有序 key 的遍历。</p><h2 id="6-说一下-HashMap-的实现原理？"><a href="#6-说一下-HashMap-的实现原理？" class="headerlink" title="6. 说一下 HashMap 的实现原理？"></a>6. <strong>说一下 HashMap 的实现原理？</strong></h2><p>HashMap原理如果要深究是非常复杂的，这里简单了解</p><p>HashMap 概述： HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </p><p>HashMap 的数据结构： 在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap 也不例外。<strong>HashMap 实际上是一个 “链表散列” 的数据结构，即数组和链表的结合体</strong>。</p><p>当我们往 Hashmap 中 put 元素时, 首先根据 key 的 hashcode 重新计算 hash 值, 根绝 hash 值<strong>得到这个元素在数组中的位置 (下标)</strong>, 如果该数组在该位置上已经存放了其他元素, 那么在这个位置上的元素将以链表的形式存放, 新加入的放在链头, 最先加入的放入链尾. 如果数组中该位置没有元素, 就直接将该元素放到数组的该位置上。</p><p>需要注意 Jdk 1.8 中对 HashMap 的实现做了优化, 当链表中的节点数据超过八个之后, 该链表会转为红黑树来提高查询效率, 从原来的 O(n) 到 O(logn)</p><h2 id="7-说一下-HashSet-的实现原理？"><a href="#7-说一下-HashSet-的实现原理？" class="headerlink" title="7. 说一下 HashSet 的实现原理？"></a>7. <strong>说一下 HashSet 的实现原理？</strong></h2><ul><li>HashSet 底层由 HashMap 实现</li><li>HashSet 的值存放于 HashMap 的 key 上</li><li>HashMap 的 value 统一为 PRESENT</li></ul><h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. <strong>ArrayList 和 LinkedList 的区别是什么？</strong></h2><blockquote><p>一个是数组，一个是双向循环链表</p></blockquote><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p><h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. <strong>如何实现数组和 List 之间的转换？</strong></h2><ul><li>List 转换成为数组：调用 ArrayList 的 toArray 方法。</li><li>数组转换成为 List：调用 Arrays 的 asList 方法。</li></ul><pre class="line-numbers language-java"><code class="language-java">            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           Object<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           List l <span class="token operator">=</span>  Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10.ArrayList 和 Vector 的区别是什么？"></a>10.<strong>ArrayList 和 Vector 的区别是什么？</strong></h2><ul><li>Vector 是同步的,线程安全，而 ArrayList 不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用 CopyOnWriteArrayList。 </li><li>ArrayList 比 Vector 快，它因为有同步，不会过载。 </li><li><strong>ArrayList 更加通用</strong>，因为我们可以使用 Collections 工具类轻易地获取同步列表和只读列表。</li></ul><h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. <strong>Array 和 ArrayList 有何区别？</strong></h2><blockquote><p>这个区别容易让人忽略</p></blockquote><ul><li><strong>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。</strong> </li><li>Array 是指定大小的，而 ArrayList 大小是固定的。 </li><li>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。</li></ul><h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll() 和 remove() 有什么区别？"></a>12. <strong>在 Queue 中 poll() 和 remove() 有什么区别？</strong></h2><blockquote><p>作用是一样的，不同在出现异常的时候是否抛出异常。</p></blockquote><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. <strong>哪些集合类是线程安全的？</strong></h2><ul><li>vector：就比 arraylist 多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在 web 应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比 hashmap 多了个线程安全。</li><li>enumeration：枚举，<strong>相当于迭代器</strong>。</li></ul><h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. <strong>迭代器 Iterator 是什么？</strong></h2><p>迭代器是一种设计模式，<strong>它是一个对象，它可以遍历并选择序列中的对象</strong>，而开发人员不需要了解该序列的底层结构。迭代器通常被称为 “轻量级” 对象，因为创建它的代价小。</p><p>Java 中的 Iterator 功能比较简单，并且只能单向移动，一般结合while实现遍历：</p><p>(1) 使用方法 iterator() 要求容器返回一个 Iterator。第一次调用 Iterator 的 next() 方法时，它返回序列的第一个元素。<strong>注意：iterator() 方法是 java.lang.Iterable 接口, 被 Collection 继承，所以所有继承自Collectoin的对象都可以使用迭代器</strong>。</p><p>(2) 使用 next() 获得序列中的下一个元素。</p><p>(3) 使用 hasNext() 检查序列中是否还有元素。</p><p>(4) 使用 remove() 将迭代器新返回的元素删除。</p><p>Iterator 是 Java 迭代器最简单的实现，为 List 设计的 ListIterator 具有更多的功能，它可以从两个方向遍历 List，也可以从 List 中插入和删除元素。</p><ul><li>Iterator <strong>可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List</strong>。 </li><li>Iterator 对集合只能是<strong>前向遍历</strong>，ListIterator 既可以前向也可以后向。 </li><li>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul><h1 id="多线程——难"><a href="#多线程——难" class="headerlink" title="多线程——难"></a>多线程——难</h1><h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1. 并行和并发有什么区别？"></a>1. <strong>并行和并发有什么区别？</strong></h2><blockquote><ul><li>并行是同一时刻</li><li>并发是同一时间间隔，计算机中常常提到的是并发</li></ul></blockquote><ul><li>并行是指两个或者多个事件在<strong>同一时刻发生</strong>；而并发是指两个或多个事件<strong>在同一时间间隔发生</strong>。</li><li>并行是在<strong>不同实体上</strong>的多个事件，并发是在<strong>同一实体上</strong>的多个事件。</li><li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li></ul><p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2. 线程和进程的区别？"></a>2. <strong>线程和进程的区别？</strong></h2><blockquote><p>所描述的对象不同，进程是相对于程序而言；线程是相对于进程而言。二者都是对单位的描述。</p><p>进程是程序运行和资源分配的基本单元。线程是CPU调度和分配的基本单元。</p></blockquote><p>简而言之，<strong>进程是程序运行和资源分配的基本单位</strong>，一个程序至少有一个进程，一个进程至少有一个线程。</p><ul><li>进程在执行过程中拥有<strong>独立的内存单元</strong>，而多个线程共享内存资源，减少切换次数，从而效率更高。</li><li><strong>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位</strong>。同一进程中的多个线程之间可以并发执行。</li></ul><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><blockquote><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，<strong>也就是说程序是静态的代码</strong>。</p></blockquote><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。</p><blockquote><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p></blockquote><h2 id="3-守护线程是什么？"><a href="#3-守护线程是什么？" class="headerlink" title="3. 守护线程是什么？"></a>3. <strong>守护线程是什么？</strong></h2><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p><h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4. 创建线程有哪几种方式？"></a>4. <strong>创建线程有哪几种方式？</strong></h2><blockquote><p>后面会深入了解</p></blockquote><p>①. 继承Thread类创建线程类。——》类似于iOS的NSOperation</p><ul><li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul><p>需要注意：</p><ul><li>a.一个线程调用 两次start()方法将会抛出线程状态异常，也就是的start()只可以被调用一次 </li><li>b.native生明的方法只有方法名，没有方法体。是本地方法，不是抽象方法，而是调用c语言方法  registerNative()方法包含了所有与线程相关的操作系统方法</li><li>c. run()方法是由jvm创建完本地操作系统级线程后回调的方法，不可以手动调用（否则就是普通方法）</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread mThread1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread mThread2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread myThread3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThread3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②. 通过Runnable接口创建线程类</p><blockquote><p>需要创建Runable实例</p></blockquote><ul><li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li><strong>创建 Runnable实现类的实例</strong>，并依此实例作为Thread的target来创建Thread对象，<strong>该Thread对象才是真正的线程对象</strong>。</li><li>调用线程对象的start()方法来启动该线程。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-当前剩余票数:"</span><span class="token operator">+</span>count<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>​    a.实现Runnable接口避免多继承局限<br>​    b.实现Runnable()可以更好的体现共享的概念</p></blockquote><p>③. 通过Callable和Future创建线程</p><ul><li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li><li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li></ul><p>相比于上面的两种多了</p><ol><li>核心方法叫call()方法，有返回值</li><li>有返回值</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>FutureTask<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//            Thread.yield();</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"当前票数："</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"sale out"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException <span class="token punctuation">{</span>        Callable<span class="token operator">&lt;</span>String<span class="token operator">></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FutureTask<span class="token operator">&lt;</span>String<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread mThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread mThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread mThread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mThread3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul></blockquote><h2 id="5-线程有哪些状态？"><a href="#5-线程有哪些状态？" class="headerlink" title="5. 线程有哪些状态？"></a>5. <strong>线程有哪些状态？</strong></h2><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p><ul><li>创建状态。在生成线程对象，<strong>并没有调用该对象的start方法，这是线程处于创建状态</strong>。</li><li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，<strong>但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态</strong>。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li><li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程<strong>就进入了运行状态</strong>，开始运行run函数当中的代码。</li><li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li><li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　</li></ul><p><strong>状态之间的转换图</strong></p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vbb7u7xhj20lw0aeaad.jpg" alt="2019-11-12_155719.png"></p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，<strong>它只能看到 RUNNABLE 状态</strong>（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><a href="https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67" alt="RUNNABLE-VS-RUNNING"></a></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="6-sleep-和-wait-有什么区别？"><a href="#6-sleep-和-wait-有什么区别？" class="headerlink" title="6.  sleep() 和 wait() 有什么区别？"></a>6.  <strong>sleep() 和 wait() 有什么区别？</strong></h2><ul><li><p>sleep()：<strong>方法是线程类（Thread）的静态方法</strong>，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。<strong>因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象</strong>。</p></li><li><p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，<strong>它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</strong></p></li></ul><h2 id="7-notify-和-notifyAll-有什么区别？"><a href="#7-notify-和-notifyAll-有什么区别？" class="headerlink" title="7. notify()和 notifyAll()有什么区别？"></a>7. <strong>notify()和 notifyAll()有什么区别？</strong></h2><ul><li>如果线程调用了对象的 wait()方法，<strong>那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁</strong>。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），<strong>被唤醒的的线程便会进入该对象的锁池中</strong>，锁池中的线程会去竞争该对象锁。也就是说，<strong>调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</strong>。</li><li><strong>优先级高的线程竞争到对象锁的概率大</strong>，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，<strong>直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁</strong>。</li></ul><h2 id="8-线程的-run-和-start-有什么区别？"><a href="#8-线程的-run-和-start-有什么区别？" class="headerlink" title="8. 线程的 run()和 start()有什么区别？"></a>8. <strong>线程的 run()和 start()有什么区别？</strong></h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，<strong>方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程</strong>。</p><ul><li><p>start()方法来启动一个线程，<strong>真正实现了多线程运行</strong>。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； <strong>这时此线程是处于就绪状态， 并没有运行</strong>。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p></li><li><p><strong>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的</strong>。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，<strong>所以在多线程执行时要使用start()方法而不是run()方法</strong>。</p></li></ul><h2 id="9-创建线程池有哪几种方式？"><a href="#9-创建线程池有哪几种方式？" class="headerlink" title="9.  创建线程池有哪几种方式？"></a>9.  <strong>创建线程池有哪几种方式？</strong></h2><p>①. newFixedThreadPool(int nThreads)</p><p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p><p>②. newCachedThreadPool()</p><p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p><p>③. newSingleThreadExecutor()</p><p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；<strong>它的特点是能确保依照任务在队列中的顺序来串行执行</strong>。</p><p>④. newScheduledThreadPool(int corePoolSize)</p><p>创建了一个固定长度的线程池，<strong>而且以延迟或定时的方式来执行任务</strong>，类似于Timer。</p><h2 id="10-线程池都有哪些状态？"><a href="#10-线程池都有哪些状态？" class="headerlink" title="10. 线程池都有哪些状态？"></a>10. <strong>线程池都有哪些状态？</strong></h2><p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p><p>线程池各个状态切换框架图</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vcodia9sj20sp0bagm5.jpg" alt="6402.jpg"></p><h2 id="11-线程池中-submit-和-execute-方法有什么区别？"><a href="#11-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="11.线程池中 submit() 和 execute() 方法有什么区别？"></a>11.<strong>线程池中 submit() 和 execute() 方法有什么区别？</strong></h2><ul><li>接收的参数不一样</li><li>submit 有返回值，而 execute 没有</li><li>submit 方便 Exception 处理</li></ul><h2 id="12-在-java-程序中怎么保证多线程的运行安全？"><a href="#12-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="12. 在 java 程序中怎么保证多线程的运行安全？"></a>12. <strong>在 java 程序中怎么保证多线程的运行安全？</strong></h2><blockquote><p>原子性、可见性、有序性</p></blockquote><p>线程安全在三个方面体现：</p><ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li><li>可见性：一个线程对主内存的修改<strong>可以及时</strong>地被其他线程看到，（synchronized,volatile）；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before 原则）。</li></ul><h2 id="13-多线程锁的升级原理是什么？"><a href="#13-多线程锁的升级原理是什么？" class="headerlink" title="13. 多线程锁的升级原理是什么？"></a>13. <strong>多线程锁的升级原理是什么？</strong></h2><p>在 Java 中，锁共有 4 种状态，级别从低到高依次为：<strong>无状态锁，偏向锁，轻量级锁和重量级锁状态</strong>，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p><p>锁升级的图示过程</p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8vctls0i8j20nq0d5aax.jpg" alt="6403.jpg"></p><h2 id="14-什么是死锁？"><a href="#14-什么是死锁？" class="headerlink" title="14.  什么是死锁？"></a>14.  <strong>什么是死锁？</strong></h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><p>死锁的四个必要条件：</p><ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h2 id="15-ThreadLocal-是什么？有哪些使用场景？"><a href="#15-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="15. ThreadLocal 是什么？有哪些使用场景？"></a>15. <strong>ThreadLocal 是什么？有哪些使用场景？</strong></h2><p>线程局部变量是局限于线程内部的变量，<strong>属于线程自身所有，不在多个线程间共享</strong>。Java 提供 ThreadLocal 类来支持线程局部变量，<strong>是一种实现线程安全的方式</strong>。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。<strong>任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险</strong>。</p><h2 id="16-说一下-synchronized-底层实现原理？"><a href="#16-说一下-synchronized-底层实现原理？" class="headerlink" title="16. 说一下 synchronized 底层实现原理？"></a>16. <strong>说一下 synchronized 底层实现原理？</strong></h2><p>synchronized <strong>可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区</strong>，同时它还可以保证共享变量的内存可见性。</p><p>Java 中<strong>每一个对象都可以作为锁</strong>，这是 synchronized 实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的 class 对象</li><li>同步方法块，锁是括号里面的对象</li></ul><h2 id="17-synchronized-和-volatile-的区别是什么？"><a href="#17-synchronized-和-volatile-的区别是什么？" class="headerlink" title="17. synchronized 和 volatile 的区别是什么？"></a>17. <strong>synchronized 和 volatile 的区别是什么？</strong></h2><blockquote><p>一个是共享变量，一个是加锁。</p></blockquote><ul><li>volatile 本质是在告诉 jvm 当前变量在<strong>寄存器（工作内存）中的值是不确定的，需要从主存中读取</strong>； synchronized 则是<strong>锁定当前变量</strong>，只有当前线程可以访问该变量，其他<strong>线程被阻塞住</strong>。</li><li>volatile 仅能使用在<strong>变量级别</strong>；synchronized 则可以使用在变量、方法、和类级别的。</li><li>volatile 仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成<strong>线程的阻塞</strong>；synchronized 可能会造成线程的阻塞。因为synchronized底层是加锁实现。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><h2 id="18-synchronized-和-Lock-有什么区别？"><a href="#18-synchronized-和-Lock-有什么区别？" class="headerlink" title="18. synchronized 和 Lock 有什么区别？"></a>18. <strong>synchronized 和 Lock 有什么区别？</strong></h2><ul><li>首先 synchronized 是 java 内置关键字，在 jvm 层面，Lock 是个 java 类；</li><li>synchronized <strong>无法判断是否获取锁的状态，Lock 可以判断是否获取到锁</strong>；</li><li>synchronized 会自动释放锁 (a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，<strong>Lock 需在 finally 中手工释放锁（unlock() 方法释放锁）</strong>，否则容易造成线程死锁；</li><li>用 synchronized 关键字的两个线程 1 和线程 2，如果当前线程 1 获得锁，线程 2 线程等待。如果线程 1 阻塞，线程 2 则会一直等待下去，而 Lock 锁就不一定会等待下去，<strong>如果尝试获取不到锁，线程可以不用一直等待就结束了</strong>；</li><li>synchronized 的锁可重入、不可中断、非公平，而 Lock 锁可重入、可判断、可公平（两者皆可）；</li><li>Lock <strong>锁适合大量同步的代码的同步问题，synchronized 锁适合代码少量的同步问题</strong>。</li></ul><h2 id="19-synchronized-和-ReentrantLock-区别是什么？"><a href="#19-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="19. . synchronized 和 ReentrantLock 区别是什么？"></a>19. <strong>. synchronized 和 ReentrantLock 区别是什么？</strong></h2><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized <strong>更多更灵活的特性</strong>，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上： </p><ul><li>ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁 </li><li>ReentrantLock 可以获取各种锁的信息</li><li>ReentrantLock 可以灵活地实现多路通知 </li></ul><blockquote><p>另外，二者的锁机制其实也是不一样的: ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word。</p></blockquote><h2 id="20-说一下-atomic-的原理？"><a href="#20-说一下-atomic-的原理？" class="headerlink" title="20. 说一下 atomic 的原理？"></a>20. <strong>说一下 atomic 的原理？</strong></h2><p>Atomic 包中的类基本的特性就是在多线程环境下，<strong>当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性</strong>，即当多个线程同时对该变量的值进行更新时，<strong>仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功</strong>。</p><p>Atomic 系列的类中的核心方法都会调用 unsafe 类中的几个本地方法。我们需要先知道一个东西就是 Unsafe 类，全名为：sun.misc.Unsafe，这个类包含了大量的对 C 代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过 unsafe 分配内存的时候，如果自己指定某些区域可能会导致一些类似 C++ 一样的指针越界到其他进程的问题。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. <strong>什么是反射？</strong></h2><blockquote><p>可以动态的修改程序本身。</p></blockquote><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p><p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。 </li></ul><h2 id="2-什么是-java-序列化？什么情况下需要序列化？"><a href="#2-什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="2. 什么是 java 序列化？什么情况下需要序列化？"></a>2. <strong>什么是 java 序列化？什么情况下需要序列化？</strong></h2><blockquote><p>将对象归档，传输</p></blockquote><p><strong>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。</strong></p><p>虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p><p>什么情况下需要序列化：</p><p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>b）当你想用套接字在网络上传送对象的时候；<br>c）当你想通过RMI传输对象的时候；</p><h2 id="3-动态代理是什么？有哪些应用？"><a href="#3-动态代理是什么？有哪些应用？" class="headerlink" title="3. 动态代理是什么？有哪些应用？"></a>3. <strong>动态代理是什么？有哪些应用？</strong></h2><p>首先要知道代理是什么。代理其实是一种设计模式，也就是把你要做的事情交给另外一个人做，或者说是在执行一段代码的时候，插入另一段代码，另一段代码位于其他地方。</p><p>而动态代理和代理类似，关键在于多了动态两个字，也就是这个代理可以在运行的时候动态设置。</p><blockquote><p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。<strong>具有解耦意义，灵活，扩展性强</strong>。</p></blockquote><p>动态代理的应用：</p><ul><li>Spring的AOP</li><li>加事务</li><li>加权限</li><li>加日志</li></ul><p>要实现动态代理，首先必须<strong>定义一个接口</strong>，还要有一个<strong>InvocationHandler</strong>(将实现接口的类的对象传递给它)处理类。再有一个工具类<strong>Proxy</strong>(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p><h2 id="4-对象拷贝，如何实现对象克隆？"><a href="#4-对象拷贝，如何实现对象克隆？" class="headerlink" title="4. 对象拷贝，如何实现对象克隆？"></a>4. <strong>对象拷贝，如何实现对象克隆</strong>？</h2><p>有两种方式：</p><p>1). 实现Cloneable接口<strong>并重写Object类中的clone()方</strong>法；</p><p>2). 实现Serializable接口，<strong>通过对象的序列化和反序列化实现克隆</strong>，可以实现真正的深度克隆。</p><p>下面代码是通过实现Serializable，用序列化和反序列化实现深拷贝。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">CloneUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token operator">></span> T <span class="token function">clone</span><span class="token punctuation">(</span>T obj<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ByteArrayOutputStream bout <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bout<span class="token punctuation">)</span><span class="token punctuation">;</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteArrayInputStream bin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bout<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span>        <span class="token comment" spellcheck="true">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p></blockquote><h2 id="5-深拷贝和浅拷贝区别是什么？"><a href="#5-深拷贝和浅拷贝区别是什么？" class="headerlink" title="5. 深拷贝和浅拷贝区别是什么？"></a>5. <strong>深拷贝和浅拷贝区别是什么？</strong></h2><ul><li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li><li>深拷贝是将对象及值复制过来，<strong>两个对象修改其中任意的值另一个值不会改变</strong>，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li></ul><h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><p>虽然现在大部分公司都实行前后端分离，但在一些小公司在用Javaweb那一套，所以这里还是整理一下。</p><p>JavaWeb中最为核心的就是Servlet：</p><blockquote><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法<strong>。</strong>Servlet需要在web.xml中配置，一个Servlet可以设置多个URL访问<strong>。Servlet不是线程安全</strong>，因此要谨慎使用类变量。——Servlet不是线程安全的，谨慎使用类变量。</p></blockquote><h2 id="1-jsp-和-servlet"><a href="#1-jsp-和-servlet" class="headerlink" title="1.  jsp 和 servlet "></a>1.  <em><em>jsp 和 servlet </em></em></h2><h3 id="jsp和servlet区别"><a href="#jsp和servlet区别" class="headerlink" title="jsp和servlet区别"></a>jsp和servlet区别</h3><ol><li>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，<strong>JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类</strong>）</li><li><strong>jsp更擅长表现于页面显示</strong>，servlet更擅长于逻辑控制。</li><li>Servlet中<strong>没有内置对象</strong>，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li><li><strong>Jsp是Servlet的一种简化</strong>，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</li></ol><h3 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h3><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><code>void init(ServletConfig config) throws ServletException</code></li><li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li><li><code>void destroy()</code></li><li><code>java.lang.String getServletInfo()</code></li><li><code>ServletConfig getServletConfig()</code></li></ul><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源</strong>。</p><h3 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h3><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。 注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><h3 id="如何实现JSP或Servlet的单线程模式"><a href="#如何实现JSP或Servlet的单线程模式" class="headerlink" title="如何实现JSP或Servlet的单线程模式"></a>如何实现JSP或Servlet的单线程模式</h3><p>对于JSP页面，可以通过page指令进行设置。 <code>&lt;%@page isThreadSafe=&quot;false&quot;%&gt;</code></p><p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p><p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p><h2 id="2-jsp-有哪些内置对象？作用分别是什么？"><a href="#2-jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="2. jsp 有哪些内置对象？作用分别是什么？"></a>2. <strong>jsp 有哪些内置对象？作用分别是什么？</strong></h2><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h3 id="Request对象的主要方法有哪些"><a href="#Request对象的主要方法有哪些" class="headerlink" title="Request对象的主要方法有哪些"></a>Request对象的主要方法有哪些</h3><ul><li>setAttribute(String name,Object)：设置名字为name的request 的参数值</li><li>getAttribute(String name)：返回由name指定的属性值</li><li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例</li><li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组</li><li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度</li><li>getHeader(String name) ：获得HTTP协议定义的文件头信息</li><li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例</li><li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例</li><li>getInputStream() ：返回请求的输入流，用于获得请求中的数据</li><li>getMethod() ：获得客户端向服务器端传送数据的方法</li><li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值</li><li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li><li>getParameterValues(String name)：获得有name指定的参数的所有值</li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li><li>getQueryString() ：获得查询字符串</li><li>getRequestURI() ：获取发出请求字符串的客户端地址</li><li>getRemoteAddr()：获取客户端的 IP 地址</li><li>getRemoteHost() ：获取客户端的名字</li><li>getSession([Boolean create]) ：返回和请求相关 Session</li><li>getServerName() ：获取服务器的名字</li><li>getServletPath()：获取客户端所请求的脚本文件的路径</li><li>getServerPort()：获取服务器的端口号</li><li>removeAttribute(String name)：删除请求中的一个属性</li></ul><h3 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h3><p><strong>从获取方向来看：</strong></p><p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p><p><code>getAttribute()</code>是获取对象容器中的数据值；</p><p><strong>从用途来看：</strong></p><p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p><p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了 mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p><p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。 <code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p><blockquote><p><strong>总结：</strong></p></blockquote><blockquote><p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p></blockquote><blockquote><p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p></blockquote><h3 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a>include指令include的行为的区别</h3><p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下： &lt;%@ include file=”文件相对 url 地址” %&gt;</p><p>i<strong>nclude动作：</strong> <code>&lt;jsp:include&gt;</code>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下： &lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</p><h2 id="3-说一下-jsp-的-4-种作用域？"><a href="#3-说一下-jsp-的-4-种作用域？" class="headerlink" title="3. 说一下 jsp 的 4 种作用域？"></a>3. <strong>说一下 jsp 的 4 种作用域？</strong></h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li><strong>page</strong>代表与一个页面相关的对象和属性。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性<strong>。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域</strong>。</li><li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h2 id="4-session-和-cookie-有什么区别？"><a href="#4-session-和-cookie-有什么区别？" class="headerlink" title="4. session 和 cookie 有什么区别？"></a>4. <strong>session 和 cookie 有什么区别？</strong></h2><blockquote><p>由于HTTP协议是无状态的协议, session 和 cookie都是用来保存状态的。</p><p>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p></blockquote><ul><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。<strong>在服务端保存Session的方法很多，内存、数据库、文件都有</strong>。集群的时候也要考虑Session的转移，在大型的网站，<strong>一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session</strong>。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。<strong>每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了</strong>。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做<strong>URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户</strong>。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：</li></ul><h3 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h3><ol><li><strong>使用Cookie</strong></li></ol><p>向客户端发送Cookie</p><pre><code>Cookie c =new Cookie(&quot;name&quot;,&quot;value&quot;); //创建Cookie c.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天response.addCookie(c); //把Cookie放入到HTTP响应中</code></pre><p>从客户端读取Cookie</p><pre><code>String name =&quot;name&quot;; Cookie[]cookies =request.getCookies(); if(cookies !=null){    for(int i= 0;i&lt;cookies.length;i++){     Cookie cookie =cookies[i];     if(name.equals(cookis.getName()))     //something is here.     //you can get the value     cookie.getValue();    } }</code></pre><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p><p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p><ol><li>URL 重写</li></ol><p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</p><p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p><p><strong>缺点：</strong> 必须对网站的URL进行编码，<strong>所有页面必须动态生成，不能用预先记录下来的URL进行访问。</strong></p><p>3.隐藏的表单域</p><pre><code>&lt;input type=&quot;hidden&quot; name =&quot;session&quot; value=&quot;...&quot;/&gt;</code></pre><p><strong>优点：</strong> Cookie被禁时可以使用</p><p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p><ol><li>HttpSession</li></ol><p>在所有会话跟踪技术中，H<strong>ttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象</strong>。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><h3 id="说一下-session-的工作原理？"><a href="#说一下-session-的工作原理？" class="headerlink" title="说一下 session 的工作原理？"></a><strong>说一下 session 的工作原理？</strong></h3><p>其实session是一个存在服务器上的类似于一个散列表格的<strong>文件</strong>。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，<strong>里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了</strong>。</p><h2 id="5-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#5-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="5. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>5. <strong>如果客户端禁止 cookie 能实现 session 还能用吗？</strong></h2><p>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？</p><blockquote><p>因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p></blockquote><p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p><ol><li>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“–enable-trans-sid”选项，<strong>让PHP自动跨页传递Session ID</strong>。</li><li><strong>手动通过URL传值、隐藏表单传递Session ID</strong>。——》常见方式</li><li><strong>用文件、数据库等形式保存Session ID，在跨页过程中手动调用</strong>。</li></ol><h2 id="6-spring-mvc-和-struts-的区别是什么？"><a href="#6-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="6. spring mvc 和 struts 的区别是什么？"></a>6. <strong>spring mvc 和 struts 的区别是什么？</strong></h2><ul><li>拦截机制的不同</li></ul><p>Struts2<strong>是类级别的拦截</strong>，每次请求就会创建一个Action，<strong>和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性</strong>。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p><p>SpringMVC<strong>是方法级别的拦截</strong>，一个方法对应一个Request上下文，<strong>所以方法直接基本上是独立的，独享request，response数据</strong>。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，<strong>SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改</strong>。</p><p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p><ul><li>底层框架的不同</li></ul><p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。<strong>Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁</strong>。</p><ul><li>性能方面</li></ul><p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p><ul><li>配置方面</li></ul><p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p><h2 id="7-如何避免-sql-注入？"><a href="#7-如何避免-sql-注入？" class="headerlink" title="7. 如何避免 sql 注入？"></a>7. <strong>如何避免 sql 注入？</strong></h2><ol><li>PreparedStatement（简单又有效的方法）——》常用</li><li>使用正则表达式过滤传入的参数</li><li><strong>字符串过滤</strong></li><li>JSP中调用该函数检查是否包函非法字符</li><li>JSP页面判断代码</li></ol><h2 id="8-什么是-XSS-攻击，如何避免？"><a href="#8-什么是-XSS-攻击，如何避免？" class="headerlink" title="8. 什么是 XSS 攻击，如何避免？"></a>8. <strong>什么是 XSS 攻击，如何避免？</strong></h2><p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。<strong>XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息</strong>。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p><blockquote><p> XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p></blockquote><h2 id="9-什么是-CSRF-攻击，如何避免？"><a href="#9-什么是-CSRF-攻击，如何避免？" class="headerlink" title="9. 什么是 CSRF 攻击，如何避免？"></a>9. <strong>什么是 CSRF 攻击，如何避免？</strong></h2><p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p><h3 id="1-验证-HTTP-Referer-字段"><a href="#1-验证-HTTP-Referer-字段" class="headerlink" title="1. 验证 HTTP Referer 字段"></a>1. 验证 HTTP Referer 字段</h3><blockquote><p>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF<br>攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</p></blockquote><h3 id="2-使用验证码"><a href="#2-使用验证码" class="headerlink" title="2. 使用验证码"></a>2. 使用验证码</h3><blockquote><p>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</p></blockquote><h3 id="3-在请求地址中添加token并验证"><a href="#3-在请求地址中添加token并验证" class="headerlink" title="3. 在请求地址中添加token并验证"></a>3. 在请求地址中添加token并验证</h3><blockquote><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。<strong>可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求</strong>。<br>对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a><br>而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue">，这样就把token以参数的形式加入请求了。</p></blockquote><h3 id="4-在HTTP-头中自定义属性并验证"><a href="#4-在HTTP-头中自定义属性并验证" class="headerlink" title="4. 在HTTP 头中自定义属性并验证"></a>4. 在HTTP 头中自定义属性并验证</h3><blockquote><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p></blockquote><h2 id="10-转发-Forward-和重定向-Redirect-的区别"><a href="#10-转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="10. 转发(Forward)和重定向(Redirect)的区别"></a>10. 转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forward）</strong> 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><pre><code>     request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response);</code></pre><p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong></li></ol><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.<strong>浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的UR</strong>L.</p><ol><li><strong>从数据共享来说</strong></li></ol><p>forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</p><ol><li><strong>从运用地方来说</strong></li></ol><blockquote><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p></blockquote><ol><li>从效率来说</li></ol><p>forward:高. redirect:低.</p><h2 id="11-自动刷新-Refresh"><a href="#11-自动刷新-Refresh" class="headerlink" title="11. 自动刷新(Refresh)"></a>11. 自动刷新(Refresh)</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p><pre class="line-numbers language-java"><code class="language-java">Response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Refresh"</span><span class="token punctuation">,</span><span class="token string">"5;URL=http://localhost:8080/servlet/example.htm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener"><strong>fullstack-tutorial</strong></a></p><p><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener"><strong>CS-Notes</strong></a></p><p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener"><strong>JavaGuide</strong></a></p><p><a href="https://github.com/hadyang/interview" target="_blank" rel="noopener">java <strong>interview</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近的两个月</title>
      <link href="/2019/11/11/2019/11/%E6%80%BB%E7%BB%93%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4/"/>
      <url>/2019/11/11/2019/11/%E6%80%BB%E7%BB%93%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>十月初离职，忙忙碌碌工作了5年。工作的这几年一直没有时间去旅行，这次离职之后总算是满足了老婆的小小愿望去了一趟北京。</p><p>回到杭州之后留恋了一个周，之后就收拾行囊回到重庆。行李很多，第一次跨省搬家，感受到了生活太不容易了。<strong>尤其没有收入来源的时候</strong>。</p><p>到了重庆，栖居在堂弟家里。还好吧有了一个落脚的地方，堂弟也是做开发的，有了很多共同语言。花了一个周找房子，总算是安顿了下来。</p><p>接下来抽周末的时间回老家看望了年迈的奶奶、外公。十月底回到重庆，用了十来天的时间把一些基础的事情做完，接下来主要就是确定工作，老婆看房。</p><blockquote><p>没有任何一个人活得容易。人生就像是一场修行，不骄不躁，闲庭看落花。</p></blockquote><h1 id="北京之行"><a href="#北京之行" class="headerlink" title="北京之行"></a>北京之行</h1><p>北京之行路途发生了很多有趣、难忘的事情。整个旅行全是靠老婆一个人规划，我负责提箱子，拿行李。看了天安门升国旗，故宫，国家大剧院，圆明园遗址，八达岭长城….</p><h2 id="走错火车站"><a href="#走错火车站" class="headerlink" title="走错火车站"></a>走错火车站</h2><p>出发的当天下午，我们提早收拾好了行李，就等着出发去火车站了。当初买火车票的时候没有注意到是杭州东站还是杭州城站，因为之前坐车都是在杭州东出发的。所以我们两个人拖着行李，一股脑的就往杭州东去了。</p><p>提前出发了一个多小时，做地铁到了杭州东，已经准备好了进站了。老婆突然觉得哪里不对，叫我看下车票，我恍然看了一眼，我日还真他吗坐错了。这下就着急了，还剩不到不半个小时的时间，当时情况真的是让人捉急。</p><p>马上就拿出地图导航，不幸中的万幸，杭州东站到杭州城站有直到的地铁。我们两人急匆匆的冲向地跌站。安检，进站花了不到5分钟，上了地铁，由于跑得太急，都气喘吁吁。</p><p>还好我们提前出发了，最终到城站的时候还剩十来分钟，总算是化险为夷，顺利了踏上了去北京的火车。</p><h2 id="卧铺鼾声不绝于耳"><a href="#卧铺鼾声不绝于耳" class="headerlink" title="卧铺鼾声不绝于耳"></a>卧铺鼾声不绝于耳</h2><p>城站是杭州的老火车站，虽然在网上买的是快车，但事实上是由绿皮火车改装过的，而且卧铺是三层，空间也就更加狭窄了。</p><p>刚一上车，老婆就说：“你看，为了省几十块钱受这种罪，空间又小，人又多，环境这么差。”确实是因为当初为了省那几十块钱，考虑到卧铺的话，在火车上睡一晚刚好就到了。也就省下了一晚的住宿费。</p><p>事与愿违，还没有到晚上，同车厢的一个大叔就开始表演，打鼾打得那是如雷贯耳。从哪个时刻就知道今天晚上注定是一个不眠夜。</p><p>床位预定的是下铺和上铺，当时还真没注意到还有个中铺。睡在下铺能够很清晰的听清楚铁轨发出的声音。那酸爽让人难以忘怀，铁轨的声音、车厢里打鼾的声音（不止一个人打鼾）让人都快发疯了。到了凌晨一点，实在是受不了了，我跑道了走道上休息了一会，这个时候老婆也没睡着。哎！——为了省几十块钱真的是不划算。</p><blockquote><p>当初为了省钱选了这趟卧铺，然而旅行体验太差了。有时候能用钱解决的问题真的就不是问题，现在总算是明白了，宁愿多花点钱也要选好一点的。</p><p>被鼾声的恐惧支配，直到第二天早上才被解除，太吓人了。多一点钱买的更多是安心，优质。</p></blockquote><h2 id="行李游圆明园"><a href="#行李游圆明园" class="headerlink" title="行李游圆明园"></a>行李游圆明园</h2><p>第二天起早看了庄严的天安门升国旗，上午决定去附近的几个景点打卡。</p><p>故宫确实让人联想到五千年历史的波澜壮阔。那天的人也很多，比较奇葩的是我一直手里提着行李。</p><p>说到行李，就不得不说预定的酒店。同样的剧情，以为到北京，可以找到比网上更加便宜的酒店，结果非但没有找到，反而更贵了。到了入驻的酒店，顺便就问了明天还有房间没有，结果全部都被预定完了。</p><p>没办法第二天只有把随身带着行李去各个景点打卡了。拖着箱子逛了故宫，孔子庙，圆明园。一路上也发现了和我们有类似经历的游客，拖着大大小小的箱子依然热情高涨。印象最深的还是要数圆明园了。</p><p>圆明园占地面积很大，是后来扩修了的。在里面游览了三个多小时，还是有很多景点没有走完。走在圆明园里面，仿佛回到了乡村的感觉，空气中弥漫着清晰的味道。我们没有从大门进入，选择了从一偏门，那里的人不算多，所以一开始还以为圆明园咋这么冷清呢。知道走到了大路上才发现人越来越多了。</p><p>到了圆明园遗址的地方，终于见到了念书的时候，历史书上圆明园的那张照片。不得不佩服当时劳动人民的鬼斧神工，在那个时候建造了这么精美的建筑。只不过现在成了残垣断壁，从仅有的断石中依然可以看到那些渐渐被侵蚀的花纹。确实这就是中华民族屈辱的见证。</p><p>拖着行李在里面走了三个多小时，真的累成狗。还有一处景点只能通过人扛着行李走的景点，像是一个湖，具体名字记不清了。一个不大不小的湖，经过一个一个的小石板才能通过。</p><p>有一处大路上面长了很多狗尾巴草，一大片一大片的，可能走到了偏远处。像极了家乡的农村，远处还有几个装点的蒙古包，只是有点破解。</p><h2 id="返杭"><a href="#返杭" class="headerlink" title="返杭"></a>返杭</h2><p>接下里去爬了长城，真实有点坑。公交车上的导游一直说有多高多远多累，忽悠我花了两百多做索道，其实根本不高。游客去爬的都是景区，不是电视上看到的那么雄伟险峻的长城。</p><p>玩了将近一个周，到了该返回的时间了。北京的空气非常干燥，老婆的脸上已经开始长红色的粉刺，加上温度不是那么友好，所以还是打算早点回去。<strong>这次返回杭州汲取上次的教训，不再去省那几十块钱遭罪。买了高铁，五六个小时就到杭州。</strong></p><p>从北京回杭州，留下了不少的照片，可能这就是旅行仅仅剩下的回忆。说真的这次旅行并没有放松心情，反而比上班还累。<strong>只能说看风景，看人头各一半吧！</strong></p><p>到了杭州，也就意味着是时候离开杭州返回家乡——重庆了。</p><h1 id="杭州之缘"><a href="#杭州之缘" class="headerlink" title="杭州之缘"></a>杭州之缘</h1><p>从北京回来之后，在最初的计划中是应该马上收拾行李回重庆的。事实上并没有那么急切回重庆的冲动。于是在杭州停留了一个多周的时间。</p><p>杭州是自己毕业工作的处女地，也见证了杭州房价的飞涨，只可惜自己没有上车，一直没有买房，这确实让人有些懊悔。校招到恒生电子，做了不到半年下定决心一定要走出去（公司的技术太老了），拼了老命，终于找到了一家愿意收留自己的公司（一家做即时通讯的）。从此之后就一直做即时通讯，<strong>回想当初，发至内心的感谢当时的那家公司，不仅工资Double，而且深得老大的赏识，很快就成了小组的Leader。在那里的几年是自己进步最快的几年，无论是从技术还是管理上来讲。</strong></p><h2 id="异地的爱情"><a href="#异地的爱情" class="headerlink" title="异地的爱情"></a>异地的爱情</h2><p>在没结婚之前，和老婆一直是分分合合了不下三次。比较严重的有两次，其中最大的问题就是在于工作的地点。说白了就是异地恋。</p><p>刚毕业的时候，我来到了杭州，老婆去了深圳。虽然说好要一起，但是再好的感情也经不住距离的考验。<strong>所以毕业之后的几个月之内就分手了，这次分手对但是的自己来讲，并没有撕心裂肺的痛，最开始只是非常的不习惯。</strong></p><p>到了第二年，一次偶然的机会。偶然得知双方都没有找到合适的，冥冥之中两人决定重归于好。限制于当时自己的工资还算是比较让人满意，于是老婆就到了杭州准备两个人生活在一起。</p><p>但是老婆不适应当时的气候，两个人由于种种原因最终还是分开了。</p><h2 id="职业的起始地"><a href="#职业的起始地" class="headerlink" title="职业的起始地"></a>职业的起始地</h2><p>由于毕业就来了杭州，而且学的是计算机，所以很符合当地的人才需求。这里的机会很多，尤其是前几年的创业热潮，让不少人实现了财务自由。自己也得益于前几年的互联网热潮，算是赶上了互联网的尾巴，小小赚到了一些钱。</p><p>在杭州接触到的大部分玩家都是玩互联网的，同时也看清了互联网公司生存的方式。所谓的投融资，资本运作这一切都是为了利益。接触到了一些大脑，玩数字货币，通过数字货币发财的不在少数。也有走旁门左道的，什么黄播，菠菜之类的。更有甚者玩起了洗钱这门生意，只不过是通过数字货币来洗钱而已。</p><h3 id="大开眼界"><a href="#大开眼界" class="headerlink" title="大开眼界"></a>大开眼界</h3><p>人性的贪婪让这个城市焕发着不懈的动力。在自己的认知中，清华、北大出来的人应该是敬佩，或者说尊敬的吧。万万没想到，越是这样的人才，赚钱的手段更让人大跌眼镜。<strong>欺骗，割韭菜，资金盘…..</strong></p><h2 id="最后的几天"><a href="#最后的几天" class="headerlink" title="最后的几天"></a>最后的几天</h2><p>在杭州呆了最后一个周，也觉得应该回重庆了。这个城市给了自己很多的思考，见识了各方大佬。最后几天自己并去周边看看，反而心情归于平静。待在家里，每天收拾一点东西，到了饭点就去吃饭；到黄昏的时候就去散步；到了晚上就玩玩游戏，该睡觉了。</p><blockquote><p>终于是时候离开杭州了。</p></blockquote><h1 id="重庆我回来了"><a href="#重庆我回来了" class="headerlink" title="重庆我回来了"></a>重庆我回来了</h1><blockquote><p>这次回重庆是去年就开始打算的。老婆的想法是在一个地方如果呆了五年以上就算是安家了。但是自己深刻的知道自己不可能在杭州安家，也许回来之后工资不再那么华丽，也许会遇到一些挫折，但有舍才有得。</p></blockquote><h2 id="踏上归途"><a href="#踏上归途" class="headerlink" title="踏上归途"></a>踏上归途</h2><p>很多事情要趁早，比如当时在决定什么时候回重庆的问题上，自己一直都没有计划清楚。后来在一次和老婆的争论中下定决心，过三天之后就回去。立下了这个flag，所以的事情都已经写上了日程。</p><p>出发的前一天，和老婆辛辛苦苦地把房间打扫干净，该收拾的行李都收拾好了。并且叫了快递小哥，帮忙送下快递，比较不爽的就是，我靠原来跨省跨地这么贵。<strong>总共邮寄物品就用了五六百。后来加了快递小哥的微信，拜托他上个心，因为行李里面有一台电脑，让他帮忙小心包裹一下。——情商真的很重要。</strong>后来发了个红包给它，幸运的是电脑最终没有损坏。</p><p>为了能够赶上动车，住的地方离东站比较远，所以必须前一天晚上就要到附近住下。当时两个人拖两个大箱子、两个大书包，外加一个行李包，一个电脑包。第一次叫滴滴的时候，那师傅居然不载。<strong>还有后来有一个滴滴师傅愿意接下这单。</strong></p><p>第二天一大早就收拾好行李急急忙忙的去车站。幸好走的时候不算是出行高峰期，不然还真会赶不上。历经千辛万苦总算是上了动车，看着慢慢的行李，不由想到农民工。那个时候自己就感觉生活可能就是这样的，我已经有了大量的行李，必须一个一个的来处理再也回不到没有行李的时候了。</p><p>晚上到了重庆，说好的堂弟来接应。刚下动车，听到的都是乡音，正宗的重庆话。到了堂弟住的地方，大家都饿了。当时已经晚上十一点多了，<strong>重庆最不少的就是吃饭的地方，</strong>一行人找了家串串店，总算是把饿得问题解决了。</p><p>这一天总算是累完了，第二天我们决定去海洋公园看一看。</p><h2 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h2><p>一直住在别人家始终不是那么方便，和老婆商量一定要在一个周之内租房，然后把东西都搬过去。<strong>做任何事情一点要有一个时间截止点，无论是工作还是生活。</strong></p><p>从周一找到周四，每天平均看两到三套。重庆相比于杭州来说房租还是要便宜很多，相应的工资也要低很多。现在工作还没有确定，只是大致的知道重庆互联网产业主要集中在哪些地方，老婆也想找一个离工作近一点的地方。</p><p>前前后后去了渝北，南坪，渝中看了房子。<strong>租房相对于买房来说还是比较简单的了，但是经历了这次租房，自己深刻的知道租一套房太累了。考虑因素很多很多，老婆是一个生活质量非常注重的人，平时非常爱清洁。不仅仅考虑交通方便，还要考虑小区是否安静，周边环境是否安全等等。</strong></p><p>租房都如此复杂，买房岂不是更加困难。这次回重庆的一个重要的目的就是买房，哎！一直没有买房，这下就真的是成了接盘侠。</p><h2 id="回老家"><a href="#回老家" class="headerlink" title="回老家"></a>回老家</h2><p>回了重庆必须去老家看望年迈的奶奶、外公这些。小时候在爷爷奶奶的照顾下长大，自然对他们的感情更深一些。出门在外这么多年，每次回到老家都会有一种莫名的感动。</p><p>周六的早上，六点多钟就要开始整理行李。回乡对我们这种常年飘在外面的人来讲，如果挣钱了还好，比较有面子，如果在外面没挣着钱，自己都会感觉很失落。</p><p>这次回乡，同乡的一位哥哥很早就联系到要来接我们。他也算是农村里面混得比较好的，老爸开猪场赚了不少钱，这次非洲猪瘟损失有点严重。<strong>更为让人惊讶的是，结婚不到两年，他就要离婚了。孩子才刚出生，和他的交谈中很明显的感觉到他对生活的失望。找我合计想走一走偏路，搞什么在线麻将之类的。</strong></p><p>一路上讲了很多关于当下生活和他所接触的人和事。说到现在很多人买了房子，每个月都需要还钱，压力非常大。我们要赚就赚这样人的强。最终得出了一个结论，赚穷人的钱比赚富人的钱更容易。<strong>甚至他可以为了钱铤而走险，不惜进去坐几年。</strong></p><blockquote><p>人到走投无路的时候非常可怕，容易失去理智。</p></blockquote><h3 id="乡村的感觉"><a href="#乡村的感觉" class="headerlink" title="乡村的感觉"></a>乡村的感觉</h3><p>乡村给人一种亲切安静的感觉。之前都是看着别人带着一家老少回老家探亲，如今也轮到了自己。</p><p>回到乡下，百分之八十几都是老年人和小孩，年轻人太少了。不过也能够实实在在的看到乡村的发展，公路四通八达，还有一点就是重视环境。当地政府也搞了很多措施来治理环境。</p><p>由于乡村的发展，而是上学的那条路已经被掩盖了，被水泥路所取代。<strong>不由让人感慨岁月的无情。</strong></p><h3 id="停电"><a href="#停电" class="headerlink" title="停电"></a>停电</h3><p>这次运气有些好，回老家晚上刚好遇到停电。小时候在农村也经历过停电，那个时候一停电就听两三天，这次停电就停了半个小时。</p><p>奶奶拿出了久未的“煤油灯”，这种灯现在估计只能在电视上看到了，油用的不是煤油，现在换成了可食用油。用一个碟子盛油，然后找一张纸，揉成一条线作为灯芯。只要把灯芯点燃放在碟子里面就可以了。<strong>小时候奶奶经常用这种方式给我们照明。</strong></p><p>隔壁的小孩见我回来了一个劲的找我闹。自己并不是那么喜欢小孩子，所以也就应付一下。说来这个小孩也是坎坷，本来家里的情况挺好的，因为老爸不务正业经常赌钱，最终闹到离婚。<strong>这样的例子在农村非常常见。</strong></p><p>此情此景特别让人怀恋。</p><h2 id="回重庆市区"><a href="#回重庆市区" class="headerlink" title="回重庆市区"></a>回重庆市区</h2><p>去外公家拜访了一下，吃过午饭就该回去了。去的时候恰逢外公出去干活，已经快八十的老年人，身子骨还硬朗，跟着年轻人去公路上干活挣钱，不知道该为此感到高兴还是悲哀。舅舅、舅娘在家里打红薯粉，这种场景已经不为多见了，这次还帮忙提了几桶水，也算是帮了一点小忙吧。</p><p>在回重庆的路上回经过县城，总得来讲县城发展得很好。走的时候体育馆内正在举行中国和巴西的女子足球比赛。前不久堂弟才在县城里面买了一套房，<strong>有时候想想自己居然还没买房，人与人之间会默认的就去对比。</strong></p><p>县城里的房价肯定比重庆便宜，所以很多亲戚都劝说在县城里面买。老婆一直坚持在重庆市区里面买，这样对以后的小孩教育好，而且到丈母娘家也近一些。对于房价感触最深的就是我们四人（我，老婆，堂弟，弟媳）在万达吃完晚饭的时候，堂弟之前本来想在万达对面买的，当时还不算贵，由于稍微犹豫了一下，过了两个月房价直接涨了两三千一平米。<strong>这种切身的感受最能说明房价的疯狂，我面对这幢楼就是经历了这样的疯狂。联想到后面自己会在重庆买房，不寒而栗。为国接盘成了我们90后不能逃避的选择。</strong></p><h1 id="现在的忧虑与彷徨"><a href="#现在的忧虑与彷徨" class="headerlink" title="现在的忧虑与彷徨"></a>现在的忧虑与彷徨</h1><p>人无远虑必有近忧，尤其在这个年纪。年龄将近三十，存款不多，买房，生娃….</p><h2 id="是工作还是自己干？"><a href="#是工作还是自己干？" class="headerlink" title="是工作还是自己干？"></a>是工作还是自己干？</h2><p>什么样的工作是好工作？对自己而言每个年龄阶段对这个问题的理解是不一样的。</p><ul><li>刚毕业的时候，肯定是钱多就是好工作。就如同自己刚从恒生出来的时候，工资一下翻倍，那个高兴劲不摆了。由于家庭环境并不是那么宽裕，所以从小到大都很节约，小到一瓶矿泉水，大到买衣物等等。</li><li>现在有一定小小的继续，好工作就是能够支持家庭开销，并且有一份不错的薪水，可以低一点，但是最好不能打乱家里的生活。然后这种奢求是很难实现的，尤其是IT行业，加班是家常便饭。<strong>更让人恐惧的是重庆的IT薪资普遍不高，并且所用的技术也很老旧。</strong>这一点目前自己是最担心的。</li></ul><blockquote><p>很早就知道要想赚钱，肯定要当老板才行，这个观念自己一种都时刻提醒着自己。<strong>然而很多时候是身不由己，比如现在要买房，如果用公积金就会少一部分钱，而且还有社保，如果不工作社保都用不了。所以这不得不让自己做出让步，必须去企业里面打工</strong></p><p>可是自己还是有着不灭的梦想，一直想象着拥有一番自己的失业。<strong>老婆常说，先成家再立业，而且很多人都是在买了房子，生了小孩之后才开始创业的。</strong>这让自己非常动容，一方面有技术能够做东西出来，但是会没收入，一旦没收入，家里的开支怎么办。<strong>还要买房，还房贷！</strong></p><p>总是这么矛盾。</p></blockquote><p>目前来看只能先硬着头皮去找工作，以自己的学习能力和工作经验在重庆找一份工作应该不难。难的就是找到工资高一点的，<strong>在很急需钱的情况下，甚至自己都有一个人干三个人的活这样的冲动。</strong></p><h2 id="没有收入的坚持"><a href="#没有收入的坚持" class="headerlink" title="没有收入的坚持"></a>没有收入的坚持</h2><p>最近四个月都没有任何收入。说自己不慌那是骗人的，尤其是在每天都有开销情况下，老婆和自己的消费观念还一直停留在杭州有着三四万月收入的时候。回到重庆也是这样的去消费，几个月下来，发现支付宝里的钱居然少了这么多。说好不动银行卡的钱，那是用来买房的也用了小部分。</p><p>也算是自己提前感受了一次所谓的中年危机吧。<strong>在没有被动收入的情况下离职，每天都是净支出，没有几个人会一直坚持下去学习。</strong>最近这几个月，可以说这种感觉对自己的启发是最大的。</p><blockquote><p>一定要有自己的被动收入。</p></blockquote><p>在回到重庆这段时间，还有一个观念被颠覆了。IT的工资很高，能够一直维持下去。殊不知儿时的一个发小，高中没毕业，靠着炒房早就实现了财务自由。</p><blockquote><p>作为IT人，不要把自己想得多高大上。程序员也就是一个工具而已，类似于90年的裁缝师傅，裁缝师傅的工具是裁缝机，而程序员的工具就是电脑。我们仅仅是一个工具而已。<strong>还有很多行业比这个赚钱的，有很多方式去赚钱比写代码来得快。</strong></p></blockquote><p>没有收入的这种状态最多还能再坚持半个月，自己也在这段时间学习了很多知识。<strong>就算是对自己一次职业生涯，人生规划的一次充电。一次短暂的停歇是为了下一次更远的腾飞。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Https</title>
      <link href="/2019/11/09/2019/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHttps/"/>
      <url>/2019/11/09/2019/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHttps/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络，Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——红黑树</title>
      <link href="/2019/11/08/2019/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2019/11/08/2019/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>红黑树的目的是为了高效地进行增删改查，本质是一种二叉查找树，其次也是一种完美平衡二叉树。所以本文从二叉树，完美平衡二叉树开始介绍。</p><p>除了红黑树，后面也会陆续介绍其他几种在实际工作中常用到的树。</p><ol><li>AVL树，平衡二叉树</li><li>B/B+树，用在磁盘文件组织，数据索引和数据库索引</li><li>Trie树（字典树）：用在统计和排序戴亮字符串</li></ol><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>我们知道线性查找、二分查找、哈希查找这些都能试下查找。但线性查找效率比较低，二分又要求必须是有序的序列，为了维持有序插入的代价比较高、哈希查找效率很高但是浪费空间。</p><p>能不能有一种插入和查找都比较快的数据结构呢？二叉查找树就是这样一种结构，可以高效地插入和查询节点。</p><p>二叉查找树的性质如下：</p><ol><li>左子树上所有节点的值小于或等于它根节点得值</li><li>右子树上所有节点的值大于或等于它根节点的值</li><li>左右子树每个也必须是二叉查找树</li></ol><p>那么根据这个性质我们就可以非常快的查找了——类似于二分查找。</p><p>如果对一个有序的序列进行查找，那么效率非常低。二分查找的优势没有了，这种现象可以理解为失去了平衡。<strong>所以需要平衡二叉树来弥补这种缺陷</strong></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树的性质</p><ol><li>从任何一个节点出发，左右子树深度之差的绝对值不超过1。</li><li>左右子树仍然为平衡二叉树</li></ol><p>平衡二叉树在查找的时候就有二叉查找树的优势，同时也保持了平衡。</p><p>但是平衡二叉树的劣势在于：</p><ol><li>删除：对于平衡二叉树来说，在最坏情况下，需要维护从被删节点到根节点这条路径上所有节点的平衡性，旋转的量级是O(logN)。但是红黑树就不一样了，最多只需3次旋转就会重新平衡，旋转的量级是O(1)。</li><li>保持平衡：平衡二叉树高度平衡，这也就意味着在大量插入和删除节点的场景下，平衡二叉树为了保持平衡需要调整的频率会更高。</li></ol><blockquote><p>所以在大量查找的情况下，平衡二叉树的效率更高，也是首要选择。在大量增删的情况下，红黑树是首选。</p></blockquote><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树就是用来解决平衡二叉树的缺点。</p><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><ol><li>每个节点是红色的，或者是黑色的</li><li>根节点是黑色的</li><li>每个叶节点(nil)是黑色的</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的</li><li>对每个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点</li></ol><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://zhuanlan.zhihu.com/p/80647496" target="_blank" rel="noopener">红黑树完全攻略</a></p><p><a href="https://zhuanlan.zhihu.com/p/84451987" target="_blank" rel="noopener">5分钟深入理解红黑树</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="noopener">从B树、B+树谈到R树</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode初级算法题解——动态规划</title>
      <link href="/2019/10/31/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/10/31/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>动态规划相信很多同学都知道，LeetCode有很多关于动态规划的题都是经典。从简单的斐波拉契数列到最长公共子序列，再都背包问题，都有动态规划的影子。</p><p>但动态规划却是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。<strong>动态规划遵循了一整套流程，只要按照流程去分析问题，一般都能找到解决问题的方法。</strong></p><p>分析动态规划的问题一般是从递归的暴力解法，到带有备忘录的递归解法，然后到动态规划，层层递进。只有有了前面的递归思路才能很自然的想到动态规划，不然就很难理解非递归解决问题的思路。</p><blockquote><p>动态规划的问题有下面两个很明显的特征，最优子结构（使用递归公式），重叠子问题（使用辅助空间dp表）</p></blockquote><p><strong>①最优子结构</strong></p><p>用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。</p><hr><p><strong>②重叠子问题</strong></p><p>在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。</p><hr><p>在解决动态规划问题的时候有几个关键步骤：</p><ol><li>分析最优解的结构特征——》重叠子问题，最优子结构</li><li>建立最优解的递归公式——》状态转移方程</li><li>自底向上计算最优值，并记录</li><li>构造最优解</li></ol><blockquote><p>步骤(1)—(3)是动态规划算法的基本步骤。在只需要求出最优值的情形，步骤(4)可以省略，若需要求出问题的一个最优解，则必须执行步骤(4)。此时，在步骤(3)中计算最优值时，通常需记录更多的信息，以便在步骤(4)中，根据所记录的信息，快速地构造出一个最优解。</p></blockquote><h1 id="例子1——斐波拉契数列"><a href="#例子1——斐波拉契数列" class="headerlink" title="例子1——斐波拉契数列"></a>例子1——斐波拉契数列</h1><p>这个例子再熟悉不过了。</p><pre><code>斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........</code></pre><p>我们可以很快速的写出递归的方式</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">or</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是仔细分析之后会发现有很多重复的计算。为了优化用变量保存一下</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        cache  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> helper<span class="token punctuation">(</span>cache<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> helper<span class="token punctuation">(</span>cache<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> cache<span class="token punctuation">[</span>n<span class="token punctuation">]</span>        r <span class="token operator">=</span> helper<span class="token punctuation">(</span>cache<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做自顶向下，动态规划叫做自底向上。</p><p>接着上一步备忘录的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算更加简单。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="例子2——最长公共子序列"><a href="#例子2——最长公共子序列" class="headerlink" title="例子2——最长公共子序列"></a>例子2——最长公共子序列</h1><p>这道题是动态规划的一道经典题目。</p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><pre><code>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。示例 1:输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。示例 2:输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。示例 3:输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。提示:1 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000输入的字符串只含有小写英文字符。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>动态规划和高中数学的数学归纳法分析步骤很类似。第一步我们为了分析是否具有最优子结构，往往通过假设法进行论证。下面按照动态规划的步骤分析</p><h3 id="分析最优解的结构特征"><a href="#分析最优解的结构特征" class="headerlink" title="分析最优解的结构特征"></a>分析最优解的结构特征</h3><p>我们假设已经知道 $Z_k = (z_1,z_2,z_3, …,z_k)$ 是 $Y_n = (y_1, y_2, y_3, …,y_n)$ 和<br>$X_m = (x_1,x_2, x_3,…,x_m )$  的最长公共子序列。我们可以分为三种情况讨论，至于为什么需要分为三种情况，这是因由$z_k,y_m,x_n$ 三者之间的关系决定。</p><ul><li>第一种情况：$x_m=y_n=z_k$  ，那么$z_{k-1} = (z_1, z_2…,z_{k-1})$ 就是  $X_{m-1},Y_{n-1}$ 的最长公共子序列。<ul><li>用反正法证明：如果 $z_{k-1} = (z_1, z_2…,z_{k-1})$ 不是 $X_{m-1},Y_{n-1}$ 公共子序列 。那么必然存在一个公共子序列，假设为M是 $X_{m-1},Y_{n-1}$  的公共子序列。那么M的长度大于肯定大于 $z_{k-1}$。这个时候在M,X,Y,Z末尾加上一个字符 $z_k$ 。则 $|M + z_k| &gt;| Z_{k-1} + z_k| = |Z_k| $ 。则 $Z_k$ 不是X，Y的最长子序列，和条件矛盾，问题得正。</li></ul></li><li>第二中情况：$x_m \not= y_n , x_m \not= z_k$。我们可以直接把 $x_m$删除。<strong>那么$z_k$是$Y_n$和$X_{m-1}$的最长公共子序列。</strong><ul><li>同样可以用反证法证明</li></ul></li><li>第三种情况：$x_m \not= y_n , y_n \not= z_k$。我们可以直接把$y_n$删除。<strong>那么$z_k$是$X_m$和$Y_{n-1}$的最长公共子序列。</strong><ul><li>同样可以用反证法证明</li></ul></li></ul><h3 id="建立最优的递归公式——状态转移方程"><a href="#建立最优的递归公式——状态转移方程" class="headerlink" title="建立最优的递归公式——状态转移方程"></a>建立最优的递归公式——状态转移方程</h3><p>我们用$C[i][j]$表示$X_i,Yj$的最长公共子序列长度。</p><ol><li>$x_m=y_n=z_k$;那么$c[i][j]=c[i-1][j-1]+1$</li><li>$x_m \not= y_n$;那么我们只需要求解<strong>$(X_i,Y_{j-1}),(X_{i-1},Y_j)$</strong>最长的序列。用公式表示就是$c[i][j]=max(c[i][j-1],c[i-1][j])$</li></ol><h3 id="自底向上计算最优值"><a href="#自底向上计算最优值" class="headerlink" title="自底向上计算最优值"></a>自底向上计算最优值</h3><p>i = 1时，$(x_1)$和$(y_1,y_2…,y_n)$中的字符一一比较。按照递归公式求解并记录</p><p>i = 2时, $(x_2)$和$(y_1,y_2…,y_n)$中的字符一一比较。按照递归公式求解并记录</p><p>i = m时, $(x_2)$和$(y_1,y_2…,y_n)$中的字符一一比较。按照递归公式求解并记录</p><h3 id="构造最优解——一些题目中可选"><a href="#构造最优解——一些题目中可选" class="headerlink" title="构造最优解——一些题目中可选"></a>构造最优解——一些题目中可选</h3><p>上面我们只是得到了最长公共子序列的长度。并不知道具体的子序列是多少。那么如何得到最终序列呢？</p><p>我们已经知道序列的长度，而序列的长度是由三种情况决定。可以在第三步自底向上计算的时候用一个dp[]数组记录这三个来源。比如：</p><pre><code>c[i][j] = c[i-1][j-1] + 1——》b[i][j]=1——》输出x_ic[i][j] = c[i][j-1]——》b[i][j]=2——》追踪c[i][j-1]c[i][j] = c[i-1][j]——》b[i][j]=3——》追踪c[i-1][j]直到i=0或j=0</code></pre><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>根据上面的分析，我们先来完成递归解法。递归解法并不难，自顶向下思考。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">lcs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#退出条件</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#第一种情况</span>        <span class="token keyword">if</span> s1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lcs<span class="token punctuation">(</span>s1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#第二、三种情况</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lcs<span class="token punctuation">(</span>s1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>lcs<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归的思路很直接，但是效率很低。下面使用动态规划的方式提高效率。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>可以使用备忘录的方式记录每一次迭代的结果。这样就可以稍微优化一下。在设计的时候有一些技巧，比如</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dynamic_lcs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#长度加1，第一位是0</span>        len_s1 <span class="token operator">=</span> len<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        len_s2 <span class="token operator">=</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">#dp数组，保存结果</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_s2<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_s1<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_s1<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_s2<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">elif</span> s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len_s1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len_s2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里为了计算的方便。引入了<code>i == 0 or j == 0</code>情况下dp为0，所以需要在原来字符串的长度基础上加1。</p><h2 id="例子3——钢条切割"><a href="#例子3——钢条切割" class="headerlink" title="例子3——钢条切割"></a>例子3——钢条切割</h2><h3 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h3><p>这里直接从《算法导论》截图</p><p><img src="/Users/kingcode/Downloads/new_hexo/source/_posts/2019/10/e5e20b30ly1g8p9lgxfmwj20k005hq3m.jpg" alt="img"></p><p><img src="/Users/kingcode/Downloads/new_hexo/source/_posts/2019/10/e5e20b30ly1g8p9lgx92sj20k007bjs1.jpg" alt="img"></p><p><img src="/Users/kingcode/Downloads/new_hexo/source/_posts/2019/10/e5e20b30ly1g8p9lgyj86j20k004ugmi.jpg" alt="img"></p><p><img src="http://ww1.sinaimg.cn/large/e5e20b30ly1g8p9lgxw9vj20k0064gmo.jpg" alt="img"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>上图已经有分析过程。——记住计算机只会做重复的事情，而算法优化就是减少做重复事情的次数。</p><p>关键点是找到递归关系。这里就是上面描述的公司<br>$$<br>r_n = max(pi + r_{n-i})  \\ 1&lt;=i&lt;-n<br>$$</p><h3 id="递归解法-1"><a href="#递归解法-1" class="headerlink" title="递归解法"></a>递归解法</h3><p>把关系转换为递归公式，遍历所有的情况。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">cut</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>pi<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>         r <span class="token operator">=</span> <span class="token number">0</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            r <span class="token operator">=</span> max<span class="token punctuation">(</span>r<span class="token punctuation">,</span> self<span class="token punctuation">.</span>cut<span class="token punctuation">(</span>pi<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> pi<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://zhuanlan.zhihu.com/p/68409952" target="_blank" rel="noopener">最长公共子序列和最长公共子串</a></p><p><a href="https://zhuanlan.zhihu.com/p/68228645" target="_blank" rel="noopener">动态规划算法题</a></p><p><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode初级算法题解——其他类型</title>
      <link href="/2019/10/30/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/10/30/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1. 有效的括号"></a>1. 有效的括号</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]{}&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;{[]}&quot;输出: true</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>做这道题的时候如果没有选准思路，非常容易陷入多层<code>if else</code>的无尽循环中。</p><p>可以把这类型的提归纳为匹配为题，通常需要用到栈、队列。具体到这道题就是用栈的方式。</p><blockquote><p>栈具有一个特殊的功能，那就是记忆功能。比如在函数调用的时候，存在函数调用栈，用于记录调用的信息。同理这里也用到这种思路。</p></blockquote><p>接下里就是如何借用栈来解决这个问题。我么可以注意到括号必须匹配，我们是否可以只要遇到左符号就入栈，如果不是左符号，那么就弹出栈顶元素。如果刚好匹配，而且最终栈是空栈那么久合法；如果不匹配，或者栈最终不是空栈那就不合法。</p><p>举个例子：</p><pre><code>输入: &quot;([)]&quot;输出: false示例 5:</code></pre><ol><li><code>(</code> 左符号  入栈     stack = [‘(‘]</li><li><code>[</code>左符号  入栈       statck = [‘(‘, ‘[‘]</li><li><code>)</code>  右符号 statck 出栈 弹出‘[’   和’)’不匹配 ，则返回False</li></ol><p>在比如：</p><pre><code>输入: &quot;(&quot;输出: false示例 4:</code></pre><ol><li><code>(</code> 左符号 入栈 stack = [‘(‘]</li><li>结束了，stack不为空</li></ol><p>接下里就是用代码描述这种关系</p><p>对应关系可以用key-value形式，也就是哈希表。于是很快我们能写出下面的代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'('</span><span class="token punctuation">:</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">:</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">:</span><span class="token string">']'</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#是否匹配</span>            <span class="token keyword">elif</span> dic<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> c<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是在提交之后，会失败，因为没有考虑到一开始不是左符号的情况。这种情况下，栈就是空栈，不能pop。</p><blockquote><p>我们采用一个取巧方法，给 stack 赋初值 ? ，并在哈希表 dic 中建立 <code>?:?</code>的对应关系予以配合，这是处理当栈只剩 <code>?</code> 的时候能正常返回。因为手动添加了辅助的字符，所以最后判断长度是等于1。</p></blockquote><p>添加辅助字符的最终代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'{'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">,</span>  <span class="token string">'['</span><span class="token punctuation">:</span> <span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">:</span> <span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">:</span> <span class="token string">'?'</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>               stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">elif</span> dic<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> c<span class="token punctuation">:</span>               <span class="token keyword">return</span> <span class="token boolean">False</span>         <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不使用辅助字符，我们还可以直接判断栈是否为空的情况。这种思路比较简单，但是没使用辅助字符效率高。因为在添加第一个字符的时候需要判断是否为左符号。</p><p>最终代码为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'('</span><span class="token punctuation">:</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">:</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">:</span><span class="token string">']'</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                <span class="token keyword">elif</span> dic<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> c<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了用哈希表来表示对应关系，我们也可以直接用字符+数组表示。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'()'</span><span class="token punctuation">,</span> <span class="token string">'[]'</span><span class="token punctuation">,</span> <span class="token string">'{}'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#处理为空的情况</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#模拟弹栈判断</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token keyword">in</span> helper<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法的弊端就是要所有字符全部遍历完才知道结果。 </p><h2 id="解法1——字符串匹配"><a href="#解法1——字符串匹配" class="headerlink" title="解法1——字符串匹配"></a>解法1——字符串匹配</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>                stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'()'</span><span class="token punctuation">,</span> <span class="token string">'[]'</span><span class="token punctuation">,</span> <span class="token string">'{}'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#处理为空的情况</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#模拟弹栈判断</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token keyword">in</span> helper<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法2——哈希表辅助字符"><a href="#解法2——哈希表辅助字符" class="headerlink" title="解法2——哈希表辅助字符"></a>解法2——哈希表辅助字符</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'{'</span><span class="token punctuation">:</span> <span class="token string">'}'</span><span class="token punctuation">,</span>  <span class="token string">'['</span><span class="token punctuation">:</span> <span class="token string">']'</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">:</span> <span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'?'</span><span class="token punctuation">:</span> <span class="token string">'?'</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'?'</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>               stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">elif</span> dic<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> c<span class="token punctuation">:</span>               <span class="token keyword">return</span> <span class="token boolean">False</span>         <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法3——哈希表不用辅助字符"><a href="#解法3——哈希表不用辅助字符" class="headerlink" title="解法3——哈希表不用辅助字符"></a>解法3——哈希表不用辅助字符</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'('</span><span class="token punctuation">:</span><span class="token string">')'</span><span class="token punctuation">,</span> <span class="token string">'{'</span><span class="token punctuation">:</span><span class="token string">'}'</span><span class="token punctuation">,</span> <span class="token string">'['</span><span class="token punctuation">:</span><span class="token string">']'</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                <span class="token keyword">elif</span> dic<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> c<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决有效括号问题核心用到栈。处理是否匹配的时候可以用哈希表，或者使用字符串截取与数组。</p><blockquote><p>有一个非常值得注意的问题，栈的边界问题。解决得方式有两种。</p><ul><li>一种是使用辅助字符，防止空栈异常；</li><li>一种是直接判断栈是否为空，为空则添加字符（添加的时候如果不是左符号可以直接返回False）</li></ul></blockquote><h1 id="2-最小栈"><a href="#2-最小栈" class="headerlink" title="2.最小栈"></a>2.最小栈</h1><h2 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h2><pre><code>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。示例:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这题总体的思路并不复杂，用list就可以实现栈的功能。</p><blockquote><p>但是有一点非常容易忽略。很直观的知道在push得时候更新最小元素；但是同样在pop的时候有的同学就很容易忘记同样需要去更新最小元素。</p><p>谈到更新最小元素，可以每次都去查找当前list中最小元素，但是这种效率太低太低；还有一种思路用空间换时间，用单独的list记录最小元素，并且和主list进行同步。在添加push的时候，如果小于上次最小则将该元素添加到最小list中，在push得时候，如果是当前最小，同样需要更新记录最小的list。</p></blockquote><h2 id="解法1——辅助栈-同步"><a href="#解法1——辅助栈-同步" class="headerlink" title="解法1——辅助栈+同步"></a>解法1——辅助栈+同步</h2><p>思路简单，辅助栈的元素个数和数据栈元素个数保持一致。在数据栈push，pop的时候，辅助栈也同样进行push，pop。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 辅助栈和数据栈同步</span>    <span class="token comment" spellcheck="true"># 思路简单不容易出错</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 数据栈</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 辅助栈</span>        self<span class="token punctuation">.</span>helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>helper<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> x <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>helper<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法2——辅助栈-不同步"><a href="#解法2——辅助栈-不同步" class="headerlink" title="解法2——辅助栈+不同步"></a>解法2——辅助栈+不同步</h2><p>辅助栈不同步，只需要记录当前最小值。如果遇到更小的才加到辅助栈里面。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 辅助栈和数据栈不同步</span>    <span class="token comment" spellcheck="true"># 关键 1：辅助栈的元素空的时候，必须放入新进来的数</span>    <span class="token comment" spellcheck="true"># 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）</span>    <span class="token comment" spellcheck="true"># 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即"出栈保持同步"就可以了</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 数据栈</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 辅助栈</span>        self<span class="token punctuation">.</span>helper <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 关键 1 和关键 2</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>helper<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> x <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 关键 3：【注意】不论怎么样，数据栈都要 pop 出元素</span>        top <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>helper <span class="token operator">and</span> top <span class="token operator">==</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>helper<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> top    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getMin</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>helper<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>虽然这是一道并不难得题，但是从这道题中可以折射出很多原则。</p><blockquote><p>在涉及到数据的增删改查的时候，<strong>与此同时还需要重点考虑，对其他问题的影响。</strong>——思维的完整性，不能只考虑单单一个地方。一个完整的步骤应该是：</p><ol><li>确定对数据操作的方式。CRUD</li><li>分析会对数据造成其他影响。比如最大，最小，中位数。——考虑周边</li><li>处理周边问题</li></ol></blockquote><p>可以用思维的对称性，完成性来总结这种类型的题。在解决其他问题也需要用到这种思维方式，对数据的增查删改，都要考虑一下整个数据的变化。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二十年前，二十年后</title>
      <link href="/2019/10/29/2019/10/%E4%BA%8C%E5%8D%81%E5%B9%B4%E5%89%8D%E4%BA%8C%E5%8D%81%E5%B9%B4%E5%90%8E/"/>
      <url>/2019/10/29/2019/10/%E4%BA%8C%E5%8D%81%E5%B9%B4%E5%89%8D%E4%BA%8C%E5%8D%81%E5%B9%B4%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="至今二十年"><a href="#至今二十年" class="headerlink" title="至今二十年"></a>至今二十年</h1><p>年近三十，倒退二十年，自己正在年小学。索性还算听话，成绩不算差。到了高中才正式感觉到了什么是学习，什么是聪明的孩子。到了大学开始认识这个社会，可惜自己并没有所谓的社会实践经验，时间花在实验室与寝室太多。工作至今进入社会，体会到了现实的残酷。最后也成立自己的家庭，似乎这就是为所有人预先设定了路线，而我也成为了走这条路线的路人。</p><h2 id="求学"><a href="#求学" class="headerlink" title="求学"></a>求学</h2><p>求学总共的时间差不多占用了过去时间的三分之二，小学到大学（6+3+3+4）。从小到大，<strong>得益于自己听话，</strong>所以一直没有走弯路，老师叫做什么就做什么，成绩自己不会太差。小学全年级第一第二，初中全年级前五，但是到了高中就不行了。还记得高中第一次月考，居然排在全部二十多名。</p><p>改变自己求学路的有两次事件，一次是小学六年级的时候和班上的同学一起去游戏厅通宵玩游戏，然后被抓得经历，这次让我彻底拒绝了游戏厅，一朝被蛇咬十年怕井绳；另一次是初中的第一个班主任，再一次周记里面我写到班主任很漂亮也很细心，从那以后班主任就很关心自己的学习。可是后面的几次考试都不是很理想，直到初二一次分班考试，<strong>自己也不知道为什么就考了除了数学不是第一，其余全是全班第一的成绩。从那以后成就就从来没有低于全班前三。</strong></p><p>后来考上了当地最好的高中，可是高中不像初中那样简单。由于家里的环境，当时没有人能指导自己如何去学习。如果那时候有现在的条件，自己肯定能够考上国内前十的大学。没有人会给你讲什么学习方法，也没有人会叫你如何去思考问题。高中的时候，有一年多是处于失眠的状态在学习。<strong>记得又一次全身长红点，自己冒着必死的心去检查，结果是血小板减少，当时不敢告诉家里人，去网上查了一下，很有可能是紫癜。把我下滑了，当时年少，留守儿童家里只有老人，父母常年在外，所以自己最有是真的做好了GG的准备。</strong></p><p>初中的荣誉一去不返。现在来看高中的自己，就是过得太累了，心理太压抑，或者说没有找对学习方法，每天睡眠不好，导致思维，记忆力下降，学习很难上去。后来自己花了很多时间在锻炼身体上，经常跑步，身体才慢慢好了起来。曾经一度觉得自己很笨，根本不适合学习。后来发现自己真的有一个致命的缺点，<strong>那就是经常心是口非，想对了但是写错了。</strong></p><p>最终高考也考得一般，到了大学自己的压力没有那么大。由于高考并没有考好，所以只能靠大学的努力来弥补。实际上自己也很努力，每年奖学金，期末考试年级前五。<strong>最幸运的是当时自己自告奋勇的进了实验室，跟着老师做项目。回想起当时的项目是C/S架构，用.net来写的。这也算基本上是入了编程的门。</strong></p><p>到了后来自己开始研究一些其他的技术，慢慢的在实验室开始带小学弟，学妹。终于让自己找到了成就感。于是在这条路上越走越远。从Asp.net，C# B/S，Kinect，人脸识别，到iOS移动开发，大学玩了不少技术。至今也还是对技术有这浓厚的兴趣，虽然深知技术就是一种工具，程序员也就是一种工具而已。<strong>但目前的条件下，自己也就只能做一个高级一点的工具</strong></p><p>求学路就这样一点一滴走了过来。放到现在去考试，真能把当时的高中成绩增加100到150。学习方法比努力学习更重要。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>校招进了一家所谓的世界金融100强的IT企业。然后把三个月的培训期过完，正式进入工作之后才明白这不是我所期望的工作。自己大学毕业的时候，当时iOS很火，重点技术积累在iOS开发上面。但是当时部门的状态就是iOS没有一个很牛的人，而且所用的技术是前端技术。我深刻知道当时自己必须离开这里，但是自己才工作不到半年。</p><p>这是一个非常现实的问题，干着一份不喜欢的工作。用非常陈旧的技术来开发业务，没有人可以给你当师傅，全靠自己摸索。于是自己下定决心一定要出去。每个周末都来公司加班，学习，看资料。然后就投简历，面试也面了五六家。因为刚毕业，工作经验真的很有限，别人一问就知道这个人的水平。</p><p>到了面试第七家公司的时候，自己基本上知道大部分面试题内容了。苍天不负有心人，经过了一个月多月的面试与学习。终于找到了当时给我机会的公司——一家我至今也感激的公司。</p><p>薪资从之前的6k直接到了12k。进入公司之后，自己也拼命的学习，毕竟经验有限，看代码，写代码。最后在一次别人都不敢重构模块上，自己重构顺利完成。从那次以后，自己在小组的位置顺利确定了。直到后面leader离职，自己开始正式担任了当时iOS的leader，<strong>这对我的成长起了助推作用。在一年年会上，公司还颁发了一个优秀员工的荣誉奖杯。</strong></p><p>工作于是就上路了，iOS，后台开发，前端这些陆陆续续都接触过。可是自己也知道人的精力有限，必须有一个方向是精通才行。毕竟iOS是老本行，所以一直是iOS小组的Leader。虽然后台也写，前端也弄，说真的，工资却没涨。</p><p>一入行就干了五六年了，慢慢的又有了新的想法，这样打工又不是办法，一直打工也不是个出路。想创业又没点子，没人脉，没资金。只有技术是没卵用的。<strong>目前正在上下求索，能否找到出路。</strong></p><h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p>去年终于完成了人生的一件大事——结婚。结婚并没有想象那样高大上，老婆虽然希望来一次至少看得过去的婚礼，但当时又没有买房，也没车，钱也不多。关键是什么都得靠自己。于是这出婚礼很草率，也很感激老婆的理解。虽然当天发生了一些有些不愉快的事情，主要是习俗上的。不过都过去了。</p><p>自己是一个天性自由的人，也可说是对家庭的责任心不强，反而对工作更加上头一点。也不知道为什么，总感觉家里有人照料，所以自己才肆无忌惮吗？</p><p>成家之后吃饭就是两个人一起了。去餐馆吃饭，每次几乎都不低于四十。</p><p>很多问题都是结婚之后才有的：</p><ul><li>买房：钱是最主要的问题。现在这房价虚高，但刚需没办法，恨自己没找点买</li><li>家庭关系：年轻人和上一代人肯定是有代沟的，生活习惯也不同。老婆是一个劲的不想住一起，而父母却很传统，非要住一起。</li><li>小孩：这个就先不谈，长期投资。</li><li>生活开支：又是钱的问题</li><li>……</li></ul><h1 id="二十年后"><a href="#二十年后" class="headerlink" title="二十年后"></a>二十年后</h1><p>二十年后的自己又会怎样的呢？这个问题在二十年前自己没有好好想过，现在可以好好想想二十年后自己会是怎样。</p><blockquote><p>有些遗憾，自己没有一个很好的规划，一个长期的规划。现在也只停留在一个周要做完什么事情，而对于一年，两年这种的长远规划是没有的。更别说二十年的规划了，没有一个目标自己坚持过一年的，除了锻炼身体。——自己真不是一个很有耐力的人。虽然锻炼上自己很有耐力。</p></blockquote><p>畅想一下二十年。</p><h2 id="家庭-1"><a href="#家庭-1" class="headerlink" title="家庭"></a>家庭</h2><blockquote><p>难以想象，甚至有点害怕。卧槽，瞬间感觉自己弱爆了。二十年后自己将近五十，闭上眼，真的难以想象。</p></blockquote><h3 id="孩子"><a href="#孩子" class="headerlink" title="孩子"></a>孩子</h3><p>那时候孩子也应该有了十几岁，学习不需要很好，但是一定要有一个快乐的童年。一定要教他如何学习，玩游戏，跆拳道。</p><p>周末带着他去户外运动，如果喜欢计算机，传授一些写代码的技巧。嘿嘿！</p><h3 id="父母"><a href="#父母" class="headerlink" title="父母"></a>父母</h3><p>父母身体还好，老爸将近七十（尼玛真的难以想象），老妈也将近七十。——这个真的还没想过，卧槽，感觉压力三大。</p><h3 id="氛围"><a href="#氛围" class="headerlink" title="氛围"></a>氛围</h3><p>不吵架，和谐共处。</p><h2 id="事业"><a href="#事业" class="headerlink" title="事业"></a>事业</h2><p>再怎么也得有自己的公司了。不求很大，但求能够持续发展。最好能上个市神马的——是不是真的在做梦？</p><h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>算得上中上阶层。至少让家里人不会太因为钱而担心什么。每年能够出去旅游一下。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>回忆过去总比想象未来简单，因为已经发生，不再带有未知。而未来带着未知，也就带着担忧。随着年龄的增加，越发感受到现实的残酷，甚至现在不敢想象二十年后某些场景。现在面临一大堆问题房子，车子，孩子，票子…..</p><p>认识到了人的差距，甚至有些妄自菲薄。深刻感受到自己的弱小，人潮人海中不过是一颗小水滴。总有人比你好，也有人比你差。如果自己早点想这个问题，会自己更有危机感，早点预防。</p><p>可能还是自己太过于理想化，或者说还没成长到那样强大，想到二十年后的某些事情都有点怯弱。但敢于想象才会有未雨绸缪的动力。如果想象都不敢，那就真的没有希望了。好在这个节点还有二十年的时间。</p></blockquote><h2 id="未来已来，躲是躲不了的。为自己，为家人Fight"><a href="#未来已来，躲是躲不了的。为自己，为家人Fight" class="headerlink" title="未来已来，躲是躲不了的。为自己，为家人Fight"></a>未来已来，躲是躲不了的。为自己，为家人Fight</h2>]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode初级算法题解——二叉树</title>
      <link href="/2019/10/27/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/10/27/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="链表与二叉树"><a href="#链表与二叉树" class="headerlink" title="链表与二叉树"></a>链表与二叉树</h1><p>二叉树是从链表的结构上扩展而来的。所以他们有很多相似的地方，最大不同就是二叉树是非线性的，或者我们可以这样来理解二叉树，二叉树是一种特殊的链表，特殊在于这个链表有两个子节点，一左一右。</p><p>链表的遍历有两种方式，一种是递归，一种是用循环。</p><p>递归的方式</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">access</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>         self<span class="token punctuation">.</span>access<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>循环的方式</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">access</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> head <span class="token operator">!=</span> None<span class="token punctuation">:</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应到二叉树的遍历，同样也有两种，递归和循环。</p><p>递归方式(DFS)</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">access</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>         self<span class="token punctuation">.</span>access<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>access<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环的方式(BFS)</p><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">def</span> <span class="token function">access</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        deque <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> deque<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链表和二叉树再循环中最大不同就是二叉树的循环遍历需要用的队列，用队列来保存下一层的节点。重点体会一下这里队列的使用。<strong>为什么需要使用队列，因为在一次循环中只能访问到当前的节点，而后续的节点是由当前节点决定的，需要保存这种关系。</strong></p><p>有了这种基本的思路，我们就可以去做题了。大部分的题目都是基于这两种思路，递归和循环的方式，或者说是深度优先遍历集广度优先遍历。</p><h1 id="1-二叉树的深度"><a href="#1-二叉树的深度" class="headerlink" title="1. 二叉树的深度"></a>1. 二叉树的深度</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。示例：给定二叉树 [3,9,20,null,null,15,7]，    3   / \  9  20    /  \   15   7返回它的最大深度 3 。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们先来看一下用递归的思路。</p><p>通常情况下，递归和分治经常联系在一起。</p><ul><li>节点的高度 = Max(左子树的高度，右子树的高度) + 1</li><li>以此类推，最后一个左或右节点高度为0 再反过来相加回去即可</li><li>时间复杂度：O(n)</li><li>空间复杂度<ul><li>最坏情况下 O(n) 退化为单链表</li><li>最好情况下 O(logn) 为平衡二叉树且高度为logn</li></ul></li></ul><p>另一种就是用广度优先，一层一层的遍历。给每个几点带上当前层数的信息（python可以用元组实现），不断取得最大值，直到遍历完成。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">findDeep</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> node <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>findDeep<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>findDeep<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        depth <span class="token operator">=</span> self<span class="token punctuation">.</span>findDeep<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> depth<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">findeDeepWithStack</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        deque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">]</span>        depth <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">:</span>            t <span class="token operator">=</span> deque<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            cur_depth<span class="token punctuation">,</span>tmp <span class="token operator">=</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            depth <span class="token operator">=</span> max<span class="token punctuation">(</span>cur_depth<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>            <span class="token keyword">if</span> tmp<span class="token punctuation">:</span>                deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>cur_depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>tmp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> depth     <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: int        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>findeDeepWithStack<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-验证二叉搜索树"><a href="#2-验证二叉搜索树" class="headerlink" title="2. 验证二叉搜索树"></a>2. 验证二叉搜索树</h1><h2 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。示例 1:输入:    2   / \  1   3输出: true示例 2:输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>首先就要知道什么是二叉搜索树。题目给出的特征如下：</p><pre><code>节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。</code></pre><p>这里有个容易忽略的地方：</p><blockquote><p>不仅右子节点要大于该节点，整个右子树的元素都应该大于该节点；不仅左子节点要小于该节点，整个左子树的节点都应该小于该节点。</p></blockquote><p>因为一个节点是否合法，现在受限于两个值。所以需要每次把这两个值都带去进去，进而比较是否满足。</p><p>同样有DFS和BFS两种。</p><p>之前的DFS递归函数中我们没有带参数，这里我们把最大最小值作为参数带进去。</p><p>循环的遍历的解法，可以借鉴二叉树的深度中解法。信息带到各个节点中（Python中可以使用元组），这里的信息就是最大，最小的限制值。</p><blockquote><p>注意下判断的时候，min,max可能是0。而在python中0代表布尔值False，所以需要单独判断。<strong>还有一种方法就是min,max初始值直接赋值为最大最小。<code>(root, float(&#39;-inf&#39;), float(&#39;inf&#39;))</code></strong></p></blockquote><h2 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: bool        """</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> min <span class="token operator">!=</span> None<span class="token punctuation">)</span> <span class="token operator">and</span> root<span class="token punctuation">.</span>val <span class="token operator">>=</span> max<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> max <span class="token operator">!=</span> None<span class="token punctuation">)</span> <span class="token operator">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">and</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">,</span> max<span class="token punctuation">)</span>        re <span class="token operator">=</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span>        <span class="token keyword">return</span> re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        deque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            root<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max <span class="token operator">=</span> deque<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> root<span class="token punctuation">:</span>                val <span class="token operator">=</span> root<span class="token punctuation">.</span>val                <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> min <span class="token operator">!=</span> None<span class="token punctuation">)</span> <span class="token operator">and</span> val <span class="token operator">&lt;=</span> min<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> max <span class="token operator">!=</span> None<span class="token punctuation">)</span> <span class="token operator">and</span> val <span class="token operator">>=</span> max<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span>                deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-对称二叉树"><a href="#3-对称二叉树" class="headerlink" title="3.  对称二叉树"></a>3.  对称二叉树</h1><h2 id="原题-2"><a href="#原题-2" class="headerlink" title="原题"></a>原题</h2><pre class="line-numbers language-python"><code class="language-python">给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 是对称的。    <span class="token number">1</span>   <span class="token operator">/</span> \  <span class="token number">2</span>   <span class="token number">2</span> <span class="token operator">/</span> \ <span class="token operator">/</span> \<span class="token number">3</span>  <span class="token number">4</span> <span class="token number">4</span>  <span class="token number">3</span>但是下面这个 <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> 则不是镜像对称的<span class="token punctuation">:</span>    <span class="token number">1</span>   <span class="token operator">/</span> \  <span class="token number">2</span>   <span class="token number">2</span>   \   \   <span class="token number">3</span>    <span class="token number">3</span>说明<span class="token punctuation">:</span>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路比较简单，就是递归比较左右两边是否相等。递归的思路比较好理解，除了递归之外当然还有迭代循环放的解法。大致的思路一样，就是在添加到队列的时候，取出的元素和添加的元素变了，一次取两个，一次添加两次。</p><h2 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: bool        """</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> None <span class="token operator">and</span> right <span class="token operator">==</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">and</span> right <span class="token operator">==</span> None<span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>left  <span class="token operator">==</span> None <span class="token operator">and</span> right<span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">return</span>  helper<span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">and</span> helper<span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        deque <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">,</span> root<span class="token punctuation">]</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            n1 <span class="token operator">=</span> deque<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            n2 <span class="token operator">=</span> deque<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> n1 <span class="token operator">==</span> None <span class="token operator">and</span> n2 <span class="token operator">==</span> None<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">==</span> None <span class="token operator">or</span> n2 <span class="token operator">==</span> None<span class="token punctuation">)</span> <span class="token operator">or</span> n1<span class="token punctuation">.</span>val <span class="token operator">!=</span> n2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n1<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n1<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-二叉树的层次遍历"><a href="#4-二叉树的层次遍历" class="headerlink" title="4. 二叉树的层次遍历"></a>4. 二叉树的层次遍历</h1><h2 id="原题-3"><a href="#原题-3" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。例如:给定二叉树: [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回其层次遍历结果：[  [3],  [9,20],  [15,7]]</code></pre><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>通过上面3道题的总结，我们可以发现，二叉树的题目基本上都可用DFS,BFS解决。掌握最基本的框架，剩下的事情就是往框架里面加东西。</p><p>题目要求得到一个包含每层元素的数组。所以我们肯定需要一个变量来记录层数。如果是一用DFS，我们是根据深度来遍历，可以按照之前用元组来携带额外信息的方法。这里我们携带的额外信息是层数（level）。然后在深度遍历的时候先判断是否已经有这个数组如果有就不用创建，如果没有就需要创建一个新的数组来保存记录。</p><p>因为DFS可以按照从左到右，从上到下的顺序进行，所以这样遍历出来的数组是有顺序的，刚好和题目要求的一样。</p><p>至于BFS的方式，比较难想到的就是需要用一个变量来记录当前这层一共有多少个元素，然后再添加子节点的时候就会更新deque里面的元素个数。这样就知道每一层有多少个元素了。没循环一次就创建一个新的数据加入到返回数组里面即可。</p><h2 id="DFS-3"><a href="#DFS-3" class="headerlink" title="DFS"></a>DFS</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        re <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        level <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                re<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">except</span><span class="token punctuation">:</span>                re<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                re<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            level <span class="token operator">+=</span> <span class="token number">1</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level<span class="token punctuation">)</span>            helper<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> level<span class="token punctuation">)</span>        <span class="token keyword">return</span> re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS-3"><a href="#BFS-3" class="headerlink" title="BFS"></a>BFS</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[List[int]]        """</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        deque <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        re <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        level <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> len<span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            re<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            lentgh <span class="token operator">=</span> len<span class="token punctuation">(</span>deque<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>lentgh<span class="token punctuation">)</span><span class="token punctuation">:</span>                node <span class="token operator">=</span> deque<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                re<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    deque<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            level <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-将有序数组转换为二叉搜索树"><a href="#5-将有序数组转换为二叉搜索树" class="headerlink" title="5. 将有序数组转换为二叉搜索树"></a>5. 将有序数组转换为二叉搜索树</h1><h2 id="原题-4"><a href="#原题-4" class="headerlink" title="原题"></a>原题</h2><pre><code>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。示例:给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：      0     / \   -3   9   /   / -10  5</code></pre><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>重点理解：<strong>一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</strong></p><p>第一直观感觉就是需要用到二分法。中间的数作为根节点。然后分别对左和右的子数组做二分法，找到中间的数，作为根节点。</p><p>当然也可以用循环的方式解决。读者自行按照之前例题的分析过程，先把框架写好再往框架里面塞对应的代码进去即可。</p><h2 id="DFS-4"><a href="#DFS-4" class="headerlink" title="DFS"></a>DFS</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: TreeNode        """</span>        <span class="token keyword">if</span> nums <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        begin <span class="token operator">=</span> <span class="token number">0</span>        end <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">if</span> begin <span class="token operator">></span> end<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        mid <span class="token operator">=</span> <span class="token punctuation">(</span>begin <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedArrayToBST<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>begin<span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedArrayToBST<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉树的题目就介绍这么几个，通过例题一定要抽象出他们的规律。递归和循环迭代的方法，循环迭代一般要用到队列进行辅助保存。</p><blockquote><p>因为有时候我们需要每个节点额外的信息，比如当前的深度，当前最大，最小值，当前父节点等等。在递归中我们可以通过参数传递，将参数带到下一次递归中去；如果是用循环迭代的方式，在python中，参数可以通过元组的形式最为一个整体，保存在循环迭代的队列里面。这样下次从队里取出节点的时候就可能同时取出当前节点的额外信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么心态会爆炸</title>
      <link href="/2019/10/26/2019/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%83%E6%80%81%E4%BC%9A%E7%88%86%E7%82%B8/"/>
      <url>/2019/10/26/2019/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%83%E6%80%81%E4%BC%9A%E7%88%86%E7%82%B8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode初级算法题解——链表</title>
      <link href="/2019/10/23/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/10/23/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-删除链表中的节点"><a href="#1-删除链表中的节点" class="headerlink" title="1. 删除链表中的节点"></a>1. 删除链表中的节点</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><pre><code>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 -- head = [4,5,1,9]，它可以表示为:</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt></p><pre><code>示例 1:输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例 2:输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.说明:链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题算是链表最简单的一题了吧。要删除传入的节点，因为已经给了节点，我们就不用查找了。常规的删除节点方法是，将前一个节点指向后一个节点。<strong>但是这里我们不知道前一个节点是什么，很多同学就懵逼了</strong></p><p>不能删除当前节点，但是我们可以修改当前节点呀，题目并不是要你一定要删除这个节点的内存地址，而是只要满足条件即可。我们把后一个节点的值赋给当前节点，然后把当前节点指向下一个的下一个节点就可以了。</p><p>有些同学想当然的直接用<code>node = node.next</code>。为什么这样的写法是错的。</p><blockquote><p>这涉及到函数传参值引用和地址引用的问题。基本上所有的编程语言，参数传递都是值传递，除非手动设置为地址传递，也就是默认传递的是当前值的一个副本。所以改变参数node的地址是改变不了原来链表中node的地址。</p></blockquote><h2 id="覆盖解法"><a href="#覆盖解法" class="headerlink" title="覆盖解法"></a>覆盖解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """</span>        node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val        node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-删除链表的倒数第N个节点"><a href="#2-删除链表的倒数第N个节点" class="headerlink" title="2. 删除链表的倒数第N个节点"></a>2. 删除链表的倒数第N个节点</h1><h2 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。进阶：你能尝试使用一趟扫描实现吗？</code></pre><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>如果没有限制扫描次数，很直观的思路就是先扫描一次链表，得到链表长度。然后根据输入的n得到要删除节点的位置。接下来进行第二次扫描，找到位置之后删除。</p><p><strong>首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。这点是困扰了很久，类似于几何题中，添加一条辅助线的感觉。。</strong></p><p>除此之外有一个非常巧妙的办法，用两个指针，第一个真真先走n步，然后第二个指针和第一个指针在同时走。当第一个指针走到末尾的时候说明第二个指针就走到了倒数第n个的位置。<strong>可以把这种解法理解为先后指针，和快慢指针有些类似。</strong></p><h2 id="两次循环哑结点解法"><a href="#两次循环哑结点解法" class="headerlink" title="两次循环哑结点解法"></a>两次循环哑结点解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        tmp <span class="token operator">=</span> head        <span class="token comment" spellcheck="true">#得到长度</span>        <span class="token keyword">while</span> tmp <span class="token operator">!=</span> None<span class="token punctuation">:</span>            count <span class="token operator">+=</span><span class="token number">1</span>            tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">#得到删除的索引位置</span>        index <span class="token operator">=</span> count <span class="token operator">-</span> n        helper_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        helper_node<span class="token punctuation">.</span>next <span class="token operator">=</span> head        <span class="token comment" spellcheck="true">#辅助节点</span>        tmp <span class="token operator">=</span> helper_node        <span class="token keyword">while</span> index <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            index <span class="token operator">-=</span> <span class="token number">1</span>            tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">#找到节点记性删除</span>        tmp<span class="token punctuation">.</span>next <span class="token operator">=</span> tmp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> helper_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前后指针一次遍历解法"><a href="#前后指针一次遍历解法" class="headerlink" title="前后指针一次遍历解法"></a>前后指针一次遍历解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type n: int        :rtype: ListNode        """</span>        helper_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        helper_node<span class="token punctuation">.</span>next <span class="token operator">=</span> head        node <span class="token operator">=</span> helper_node        count <span class="token operator">=</span> n        <span class="token comment" spellcheck="true">#移动n次</span>        <span class="token keyword">while</span> count <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            count <span class="token operator">-=</span> <span class="token number">1</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">#辅助节点，便于删除</span>        pre_node <span class="token operator">=</span> helper_node        <span class="token comment" spellcheck="true">#找到删除的位置</span>        <span class="token keyword">while</span> node<span class="token punctuation">.</span>next <span class="token operator">!=</span> None<span class="token punctuation">:</span>            pre_node <span class="token operator">=</span> pre_node<span class="token punctuation">.</span>next            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next        pre_node<span class="token punctuation">.</span>next <span class="token operator">=</span> pre_node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> helper_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h1><h2 id="原题-2"><a href="#原题-2" class="headerlink" title="原题"></a>原题</h2><pre><code>反转一个单链表。示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>翻转链表最常见的就是原地反转。需要定义一个辅助节点来保存当前的下一个节点。思路并不复杂。<strong>涉及到的操作就是，移动修改指向。</strong></p><p>基于这种思路，还有一些其他类似的方法。我们还可以添加一个辅助节点它的下一个就是当前头节点，每循环一次，就把该节点放到辅助节点后面并且把之前的节点连接到该节点之后。最后返回辅助节点的下一个节点即可。</p><h2 id="原地反转解法"><a href="#原地反转解法" class="headerlink" title="原地反转解法"></a>原地反转解法</h2><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        pre <span class="token operator">=</span> None        current <span class="token operator">=</span> head        <span class="token keyword">while</span> current <span class="token operator">!=</span> None<span class="token punctuation">:</span>            node <span class="token operator">=</span> current<span class="token punctuation">.</span>next            current<span class="token punctuation">.</span>next <span class="token operator">=</span> pre            pre <span class="token operator">=</span> current            current <span class="token operator">=</span> node        <span class="token keyword">return</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="辅助头结点解法"><a href="#辅助头结点解法" class="headerlink" title="辅助头结点解法"></a>辅助头结点解法</h2><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        current <span class="token operator">=</span> head<span class="token punctuation">.</span>next        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> head        <span class="token keyword">while</span> current<span class="token operator">!=</span> None<span class="token punctuation">:</span>            node <span class="token operator">=</span> current<span class="token punctuation">.</span>next            current<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> current            current <span class="token operator">=</span> node        head<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token keyword">return</span> pre<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-合并两个有序链表"><a href="#4-合并两个有序链表" class="headerlink" title="4. 合并两个有序链表"></a>4. 合并两个有序链表</h1><h2 id="原题-3"><a href="#原题-3" class="headerlink" title="原题"></a>原题</h2><pre><code>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>思路比较简单，就是不断比较，每次移动其中其中一个链表的节点。<strong>注意遍历完之后可能还有多余部分，需要把多余的部分添加到末尾。</strong></p><h2 id="新节点"><a href="#新节点" class="headerlink" title="新节点"></a>新节点</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        """</span>         head_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        head <span class="token operator">=</span> head_node        <span class="token keyword">while</span> l1 <span class="token operator">!=</span> None <span class="token operator">and</span> l2 <span class="token operator">!=</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                head_node<span class="token punctuation">.</span>next <span class="token operator">=</span> l1                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                head_node<span class="token punctuation">.</span>next <span class="token operator">=</span> l2                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next            head_node <span class="token operator">=</span> head_node<span class="token punctuation">.</span>next        <span class="token keyword">if</span> l1 <span class="token operator">!=</span> None <span class="token operator">and</span> l2 <span class="token operator">==</span> None<span class="token punctuation">:</span>            head_node<span class="token punctuation">.</span>next <span class="token operator">=</span> l1        <span class="token keyword">if</span> l2 <span class="token operator">!=</span> None <span class="token operator">and</span> l1 <span class="token operator">==</span> None<span class="token punctuation">:</span>            head_node<span class="token punctuation">.</span>next <span class="token operator">=</span> l2        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-回文链表"><a href="#5-回文链表" class="headerlink" title="5. 回文链表"></a>5. 回文链表</h1><h2 id="原题-4"><a href="#原题-4" class="headerlink" title="原题"></a>原题</h2><pre><code>请判断一个链表是否为回文链表。示例 1:输入: 1-&gt;2输出: false示例 2:输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>如果不考虑时间复杂度、空间复杂度。思路就很简单了。遍历链表，同时取出各个几点的值，保存到list中。然后判断list是否是左右对称即可。</p><p>还有一种取巧的方式可以满足$O(1)$的空间复杂度。<strong>用快慢指针，一个指针每次走一步，一个指针一次走两步。当第二个指针走到末尾的时候，第一个指针刚好走到一半的位置。然后翻转前一半链表。进而和后一步进行比较。</strong></p><p>其实也可以不用快慢指针，可以先得到链表的长度，然后除2得到一半的位置。<strong>然后在翻转后一半（当然前一半也是可以的），思路就和快慢指针一样了。</strong>问题的关键在于如何得到链表的中心点，得到中心点之后然后翻转各个部分，进而比较。</p><blockquote><p>快慢指针在写代码的时候有个隐藏问题，因为事先不知道链表个数是偶数还是奇数个。所以在翻转的时候需要统一规则。比如奇数1-&gt;2-&gt;1，fast最后在右边1的位置，slow在2的位置，为了比较的方便，需要将slow往后挪动一个位置。因为是翻转后一半，需要把中间位置去掉。</p></blockquote><h2 id="转为list判断解法"><a href="#转为list判断解法" class="headerlink" title="转为list判断解法"></a>转为list判断解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> head <span class="token operator">!=</span> None<span class="token punctuation">:</span>            l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> l<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> l<span class="token punctuation">[</span>len<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment" spellcheck="true">#找到中间节点</span>        slow<span class="token punctuation">,</span>fast <span class="token operator">=</span> head<span class="token punctuation">,</span>head        <span class="token keyword">while</span> fast <span class="token operator">!=</span> None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> None<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 奇数长，fast指针在最后一个，slow在最中间，slow需要往后过一个</span>        <span class="token comment" spellcheck="true"># 偶数长，fast为空，slow指针中点过一个</span>        <span class="token keyword">if</span> fast <span class="token operator">!=</span> None<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true">#翻转前半部分</span>        pre <span class="token operator">=</span> None        current <span class="token operator">=</span> slow        <span class="token keyword">while</span> current <span class="token operator">!=</span> None<span class="token punctuation">:</span>            node <span class="token operator">=</span> current<span class="token punctuation">.</span>next            current<span class="token punctuation">.</span>next <span class="token operator">=</span> pre            pre <span class="token operator">=</span> current            current <span class="token operator">=</span> node        <span class="token comment" spellcheck="true">#比较是否相等</span>        <span class="token keyword">while</span> pre <span class="token operator">!=</span> None <span class="token operator">and</span> head <span class="token operator">!=</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> pre<span class="token punctuation">.</span>val <span class="token operator">==</span> head<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next                head <span class="token operator">=</span> head<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-环形链表"><a href="#6-环形链表" class="headerlink" title="6. 环形链表"></a>6. 环形链表</h1><h2 id="原题-5"><a href="#原题-5" class="headerlink" title="原题"></a>原题</h2><pre class="line-numbers language-python"><code class="language-python">给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 <span class="token number">0</span> 开始）。 如果 pos 是 <span class="token operator">-</span><span class="token number">1</span>，则在该链表中没有环。示例 <span class="token number">1</span>：输入：head <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">1</span>输出：true解释：链表中有一个环，其尾部连接到第二个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt></p><pre><code>示例 2：输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt></p><pre><code>示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt></p><pre><code>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</code></pre><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>一个简单的思路记录一下当前遍历过的节点，如果这个节点之前出现过，那么就肯定有环。</p><p>另一种思路就比较取巧了。用一对快慢指针，如果没有环，那么快指针肯定比慢指针先到末尾，如果有环，那么快慢指针肯定会碰头。<strong>如何理解必定相遇，就如同两个人绕着圆圈跑步，a速度就是比b快。那么无论是a在b前，还是a在b后，因为是圆形，最终肯定能追到b</strong></p><blockquote><p>需要注意如果链表元素不足两个那么就不可能存在环，需要提前判断。</p></blockquote><h2 id="记录是否出现过"><a href="#记录是否出现过" class="headerlink" title="记录是否出现过"></a>记录是否出现过</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        node <span class="token operator">=</span> head        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> node <span class="token operator">!=</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> node <span class="token operator">not</span> <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token keyword">if</span> head <span class="token operator">==</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        slow <span class="token operator">=</span> fast <span class="token operator">=</span> head        <span class="token keyword">while</span> fast <span class="token operator">!=</span> None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> None<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            <span class="token keyword">if</span> slow <span class="token operator">==</span> fast<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>链表基本的操作是移动和连接。</p><p>移动</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> node <span class="token operator">!=</span> None<span class="token punctuation">:</span>    node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>连接</p><pre><code>node.next = node</code></pre><p>基本上所有的链表题都是基于这两个操作。</p><p>比如翻转就要用到链接。但是如果改变了当前节点的下一个那么原来后面的元素就无法取到。<strong>所以一般在进行改变当前下一个节点的时候定义一个临时的节点，保存当前下一个节点。这样就可以找到之后节点了。</strong></p><p>因为链表就这些节点，有时候才操作时非常不方面，很多情况下我们都会定义辅助节点来简化逻辑。比如在删除倒数第n个节点这题中。定义一个辅助接点，它的下一个就是当前头结点，这样就解决了元素只有一个的情况。</p><p>快慢指针是常见的技巧，通常一共来定位。因为链表不能随意访问元素，只能一次一次遍历，所以用快慢指针来确定元素的索引。比较经典的就是用快慢指针来检查链表是否有环、删除倒数第n个元素。</p><blockquote><p>但是在使用快慢指针的时候，需要非常注意结束的位置。形式如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> fast <span class="token operator">!=</span> None <span class="token operator">and</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> None<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如上代码慢指针移动一次，快指针移动两次。因为不知道链表元素的个数，不知道快指针会停在什么地方。当不存在环的时候。</p><p>如果是偶数个，fast最终等于None。slow停在正中间过1个的位置</p><p>如果是奇数个，fast最终会停在最后一个节点。slow停在正中间的位置</p><p>这也是为什么在移动快指针的时候需要用<code>fast != None and fast.next != None</code>两个条件来限定。<code>fast != None</code>是处理偶数的情况，<code>fast.next != None</code>是处理奇数的情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程Netty开篇</title>
      <link href="/2019/10/23/2019/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BNetty%E5%BC%80%E7%AF%87/"/>
      <url>/2019/10/23/2019/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BNetty%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近的焦虑</title>
      <link href="/2019/10/22/2019/10/%E6%9C%80%E8%BF%91%E7%9A%84%E7%84%A6%E8%99%91/"/>
      <url>/2019/10/22/2019/10/%E6%9C%80%E8%BF%91%E7%9A%84%E7%84%A6%E8%99%91/</url>
      
        <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g87bml0swsg30dw0dw413.gif" alt></p><h1 id="回顾这段时间"><a href="#回顾这段时间" class="headerlink" title="回顾这段时间"></a>回顾这段时间</h1><p>这段时间重点做了下面四件事：</p><ol><li>离职</li><li>仲裁</li><li>旅游</li><li>学习</li></ol><p>在Instanza呆了三年，从一个程序员的角度来看，在一家公司呆三年确实不容易。从入职到离职，目睹了公司从巅峰跌入万劫不复整个过程。融资C轮，阿里加持，哈弗博士，浙大博士这些光环也无法挽回一个失去了灵魂的公司。<strong>总结出一个道理：一个公司有一个灵魂人物，如果这公司的灵魂都走了，那就没戏了；不懂互联网的投资人来管换联网必将失败。</strong></p><p>好在最后跟公司也算是好聚好散，离职那天还有些怀念。刚来公司的时候压力着实不小，左边、右边一个是清华硕士，一个是浙大硕士。慢慢地在后面的工作中适应之后也暗自觉得——不过如此。在这里见识了各种各样的牛人，技术上的成长不得不说是小公司无法比拟的。</p><p>当时计划离职之后一方面仲裁，一方面计划去旅游一下。</p><p>有些遗憾，当时匆匆忙忙结婚，两个人一次旅行都没有。而这次旅行也是老婆催了很久才决定的。其实自己是一个宅男，对旅行这件事情一直都是可有可无的。这次也是刚好碰上自己离职的空窗期。所以最后决定去一趟北京，看看长城，故宫。</p><p>回来之后便开始自己每天的学习，其实在出发之前就开始了这个习惯。鉴于自己之前没有系统的学习过算法，大学也就学了数据结果。所以给自己的计划是在这段时间把LeetCode上面的基础部分全部刷完。</p><p>为什么首要就选择算法。因为工作这么多年之后，面试过形形色色的人，还是觉得算法才是对人才真真的考察，或者说分析问题的能力、数学能力。<strong>框架没什么难的，底层的原理才是核心，而所谓的原理最终落大部分都是基于基础的算法、数据结果。</strong></p><p>出了算法，还有一个打算那就是把网络编程系统的整理一遍。虽然工作中很少自己亲手去写网络库，但是不觉得正是因为网络才会有今天发达的互联网么，对于网络的理解也是一个程序员必须掌握的部分。</p><p>最近人工智能很火，加上前段时间刚把计算机图形学从头到尾捋了捋，索性就把线性代数好好复习了一遍。要学的东西太多了，时间不够用。与此同时自己也产生了一个非常不安的想法——我学习这么多，<strong>最终能赚钱么，能对以后有帮助么</strong></p><p>最后除了上面列举出来的事情，还有一件事就是玩游戏。<strong>真不知道为什么待在电脑旁边，代码写完就像来一局放松一下。自己统计了一下，一天多则五六局，少则两三局，每一局二十分钟到半个小时。</strong>有时候回想起来有些后悔。</p><blockquote><p>游戏这个东西真的应该好好限制一下了。</p></blockquote><h2 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h2><blockquote><p>百分之九十九的烦恼都是因为钱。</p></blockquote><p>由于自己根本没有被动收入，离职之后就一直在花钱，杭州的物价不低，平均一天两个人节约着花要花一百人民币。因为没有收入，加上每天都在开销，而且工作也没准备去找，还有仲裁的事情烦着。哎！心情是真的烦。</p><p>有些事情想得太细，太多人就会变得很忧虑。老婆强烈要求回重庆，光搬家这件事就很繁琐。什么转租，租房，社保，公积金什么的。好在自己比较乐观，心态没有太过于崩溃。</p><p>现在最关心的就是钱的事情。一方面自己不断的在学习一些东西，但是担心我所学的对未来没有帮助，只是暂时了满足了自己的学习需求，<strong>至少自己学的这些知识，比如算法，网络，让自己感觉很踏实，说白了也就是好奇心与成就感。</strong></p><p>人总要吃饭，兴趣是一方面。不可否则自己的等级确实很低，还在想着怎么找到一个分薪资高的工作。已经有同事靠着炒房实现了财务自由，而自己由于一直在杭州，房子一直没买。人与人的差距就是这么大，虽然他代码写得没我好，但就是有钱。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>回重庆肯定是要找工作的。在没有离职的时候，自己还搞了个网站卖一些数字资源，PDF、教学视频、破解软件什么的。一是因为没时间去运营，二是因为支付渠道没搞好（必须要企业）。所以后面就没怎么维护了，到最后因为服务器是香港的，国庆节前夕直接给我服务器封掉了。这下彻底没有继续下去。</p><p>首先技术上还是很有自信的，单单只是开发一些业务功能。服务端java、php写过，php是在用wordpress的时候好好研究了一下，java是在上家公司写后台接触的；客户端iOS就不用说了老本行，安卓也写过模块，但不如iOS熟练；至于前端，只是自己学习Vue的时候弄过，没有输出产品。</p><blockquote><p>为什么想要做一个全栈，因为自己最开始是想自己做一款产品。但是直到现在也没把这个产品弄出来，深刻知道技术不是那么重要，<strong>互联网公最重要的运营，运营，运营。</strong></p><p>势单力薄，一个人包揽全栈，精力有限。随着年龄增加，是不是也在思考技术这条路还能走多久？不过一定要在放弃技术的之前，做出一款自己的产品出来。</p></blockquote><p>重庆的互联网肯定没有杭州浓厚，但那时自己的家乡，始终还是得回去。至于工作，虽然有些担心，但是凭自己的实力我还是可以一战的。更为深远的问题是：我还能做多久的技术？被动收入又在哪里？</p><h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p>家庭的琐事太多了，和老婆也是每天都要动动嘴皮子。本来两个人的性格就差距很大，一个急躁，一个淡定。最大的矛盾还是在于房子，父母，孩子。</p><p>这次回重庆最大的事情就是要把房子搞定。当初没有新房老婆就同意结婚，这令我非常感激。所以这次买房大部分都听老婆大人的。每次吵就出现在什么工作地点，户口，学校这些。我是对这些真的非常不上心，但是还是必须面对。</p><p>其次就是父母，都说婆媳关系很难处理。结婚之后才深有体会，为什么就不能和谐共处了。隔了一代人，很多生活习惯不一样了。老爸他们是想住在一起，而老婆却不是很乐意。虽然我是无所谓，但是总得考虑到他们的感受。想好了，还是住在一起吧，到时候家里就贴一个条子，规定一些规则，大家都按照这个来。</p><p>虽然有些理想化，现在也不能想太多。工作是为生活服务的，而生活恰恰有很多一部分是家庭。家家都有难念的经！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>人生苦短，大部分的苦是因为钱。偶尔问问自己，一直努力工作赚钱，那钱究竟是什么，这一切的意义究竟在哪里？</p><p>如果眼里只有钱，那还有什么意义呢。</p><blockquote><p>希望自己保存好这样一份心情：生活不只有苟且，还有诗和远方。</p></blockquote><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——用空间视角看矩阵</title>
      <link href="/2019/10/21/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%94%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/10/21/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%94%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵与向量相乘"><a href="#矩阵与向量相乘" class="headerlink" title="矩阵与向量相乘"></a>矩阵与向量相乘</h1><h2 id="行角度"><a href="#行角度" class="headerlink" title="行角度"></a>行角度</h2><p>之间讨论过将下面的方程组，转换为矩阵<br>$$<br>\begin{cases}<br>x+2y=3 \\<br>4x+5y=6 \\<br>\end{cases}<br>$$<br>转换之后的矩阵（抽出方程组的系数）<br>$$<br>\begin{bmatrix} 1 &amp; 2 \\ 4 &amp; 5 \end{bmatrix} \ \cdot \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} 3 \\ 6 \end{bmatrix}<br>$$</p><p>然后我们右边的值用方程代替<br>$$<br>\begin{bmatrix} 1 &amp; 2 \\ 4 &amp; 5 \end{bmatrix} \ \cdot \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix}x+2y \\<br>4x+5y \end{bmatrix}<br>$$<br>这样就得到了矩阵与向量相乘的定义，如下图所示，用左边的每一行去乘右边的向量，矩阵与向量相乘最终也是一个向量。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a4jl6j30nu05eaa7.jpg" alt="1570278566408"></p><p>上面的内容是从行的角度来思考。</p><h2 id="列角度"><a href="#列角度" class="headerlink" title="列角度"></a>列角度</h2><p>我们把右边的方程还可以拆分为系数和未知数之间相乘的关系。<br>$$<br>\begin{bmatrix} 1 &amp; 2 \\ 4 &amp; 5 \end{bmatrix} \ \cdot \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix}x+2y \\<br>4x+5y \end{bmatrix} = \begin{bmatrix} 1 \\ 4 \end{bmatrix}x + \begin{bmatrix} 2 \\ 5 \end{bmatrix}y<br>$$</p><blockquote><p>x前面的列向量就是前面系数矩阵的第一列；y前面的列向量就是系数矩阵第二列。</p><p>因此我们可以用列的视角来看到系数矩阵，对应的列和向量中对应的元素相乘。</p></blockquote><p>下面是更加形象的图示。把向量的每一个元素拆开，每一个列向量都乘以没给元素，然后再相加。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85ymrzrmwj30jv04h0sl.jpg" alt="1571648670788"></p><h3 id="结合单位矩阵"><a href="#结合单位矩阵" class="headerlink" title="结合单位矩阵"></a>结合单位矩阵</h3><p>如果一个向量和单位矩阵相乘，结果还是原向量。<br>$$<br>\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \ \cdot \begin{bmatrix} x \\ y \end{bmatrix} =  \begin{bmatrix} 1 \\ 0\end{bmatrix}x + \begin{bmatrix} 0 \\ 1 \end{bmatrix}y = \begin{bmatrix} x \\ 0\end{bmatrix} + \begin{bmatrix} 0 \\ y \end{bmatrix} = \begin{bmatrix} x \\ y\end{bmatrix}<br>$$<br>之前介绍过可以把$[1,0]^T$看作是标准单位向量。二维空间中有$\bar{e_1}=(1,0) \bar{e_2}=(0,1)$。这两个标准单位向量就指向了二维坐标轴x,y的这方向。</p><p>上面的等式就相当于是<br>$$<br>\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \ \cdot \begin{bmatrix} x \\ y \end{bmatrix} = x\cdot\bar{e_1} + y\cdot\bar{e_2}<br>$$<br>那么对应的几何图形上就是</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85ymrznydj307v04g745.jpg" alt="1571649364112"></p><blockquote><p>由此我们可以把系数矩阵的每一列看做是每个轴的方向向量。<strong>相当于矩阵定义了两个坐标轴，也就是矩阵定义了一个二维空间。</strong></p></blockquote><p>比如现在有一个矩阵<br>$$<br>\begin{bmatrix} 4 &amp; 2 \\ 1 &amp; 3 \end{bmatrix}<br>$$<br>从列视角来看就是两个向量，$\bar{u}=(4,1)\bar{v}=(2,3)$，在标准空间可以画出如下图。<strong>这两个向量也定义了一个空间。</strong></p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85yms0ef8j308f07ia9z.jpg" alt="1571649736821"></p><p>现在乘以一个新的向量<br>$$<br>\begin{bmatrix} 4 &amp; 2 \\ 1 &amp; 3 \end{bmatrix} \cdot \begin{bmatrix} 2 \\ 2 \end{bmatrix}<br>$$<br>相当于是在u,v分量上移动了两倍，也就是$(2,2)$这个坐标带你在u,v上对应的分量。那么$(2,2)$这个点最终的就是就是对角线指向的地方。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85yms0crwj308i07imx4.jpg" alt="1571649845652"></p><p>最终得到的结果就是</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85yms1iidj309z07jmx9.jpg" alt="1571649988347"></p><blockquote><p>于是我们可以这里理解矩阵与向量的乘法：矩阵定义了一个空间，且每一列就对应空间中的每一个坐标轴，乘以新的向量表示的就是这个新的向量在矩阵定义的这个新的空间里面具体位置在哪里。</p><p>最终就是：矩阵与向量相乘代表这个向量在这个由矩阵组成的空间中的位置。</p></blockquote><p>于是上面的新的坐标轴可以表示为</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85yms6uqgj309e07k3ym.jpg" alt="1571650235849"></p><h2 id="结合图形变换"><a href="#结合图形变换" class="headerlink" title="结合图形变换"></a>结合图形变换</h2><p>  比如图片沿着y轴翻转</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85yms2khmj305y05rmx1.jpg" alt="1571650374985"></p><p>变换矩阵是<br>$$<br>T = \begin{bmatrix} -1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}<br>$$<br>这个矩阵代表的空间就是下图表示的空间</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g85yms2clcj3048044jr5.jpg" alt="1571650462975"></p><p>最终翻转就是将标准坐标轴的点放到新的空间坐标轴里面。</p><h2 id="多维空间"><a href="#多维空间" class="headerlink" title="多维空间"></a>多维空间</h2><p>多维空间和二维空间的坐标轴定义类似。各个坐标轴就是矩阵的每一列，n维空间就应该用n个轴来定义。</p><blockquote><p>因为每一个轴都是一个标准单位向量，<strong>所以用矩阵来表示空间，那么这个矩阵一定是一个方阵。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些优质文章的摘录</title>
      <link href="/2019/10/20/2019/10/%E4%B8%80%E4%BA%9B%E4%BC%98%E8%B4%A8%E6%96%87%E7%AB%A0%E7%9A%84%E6%91%98%E5%BD%95/"/>
      <url>/2019/10/20/2019/10/%E4%B8%80%E4%BA%9B%E4%BC%98%E8%B4%A8%E6%96%87%E7%AB%A0%E7%9A%84%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法——-labuladong"><a href="#算法——-labuladong" class="headerlink" title="算法—— labuladong"></a>算法—— labuladong</h1><h2 id="递归详解"><a href="#递归详解" class="headerlink" title="递归详解"></a><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484528&amp;idx=1&amp;sn=2a892f1eb4531e33d22956a136e66065&source=41#wechat_redirect" target="_blank" rel="noopener">递归详解</a></h2><p>首先说明一个问题，简单阐述一下递归，分治算法，动态规划，贪心算法这几个东西的区别和联系，心里有个印象就好。</p><ul><li>递归是一种编程技巧，一种解决问题的思维方式；</li><li>分治算法和动态规划很大程度上是递归思想基础上的（虽然动态规划的最终版本大都不是递归了，但解题思想离不开递归），解决更具体问题的两类算法思想；贪心算法是动态规划算法的一个子集，可以更高效解决一部分更特殊的问题。</li></ul><p>递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。<strong>我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的</strong>。</p><p>如何理解递归</p><ol><li>如何给一堆数字排序？答：分成两半，先排左半边再排右半边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。</li><li>孙悟空身上有多少根毛？答：一根毛加剩下的毛。</li><li>你今年几岁？答：去年的岁数加一岁</li></ol><p>递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。</p><blockquote><p>递归运用最成功的是什么？是<strong>数学归纳法</strong>。我们高中都学过数学归纳法，使用场景大概是：我们推不出来某个求和公式，但是我们试了几个比较小的数，似乎发现了一点规律，然后编了一个公式，看起来应该是正确答案。</p><p>递归代码的精髓在于调用自己去解决规模更小的子问题，直到到达结束条件；而数学归纳法之所以有用，就在于不断把我们的猜测向上加一，扩大结论的规模，没有结束条件，从而把结论延伸到无穷无尽，也就完成了猜测正确性的证明。</p></blockquote><h3 id="写递归的技巧"><a href="#写递归的技巧" class="headerlink" title="写递归的技巧"></a><strong>写递归的技巧</strong></h3><p><strong>明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节，</strong>否则就会陷入无穷的细节无法自拔。</p><p>先举个最简单的例子，遍历二叉树的框架代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> nullptr<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这几行代码就足以扫荡任何一棵二叉树了。对于递归函数 traverse(root)，我们只要相信：给它一个根节点 root，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？所以我们只需要把这个节点的左右节点再甩给这个函数就行了，因为我相信它能完成任务的。那么遍历一棵 N 叉数呢？太简单了好吧，和二叉树一模一样啊。</p><h3 id="例子——二叉树pathSum"><a href="#例子——二叉树pathSum" class="headerlink" title="例子——二叉树pathSum"></a>例子——二叉树pathSum</h3><p>原题</p><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1],sum = 8      10     /  \    5   -3   / \    \  3   2   11 / \   \3  -2   1Return 3. The paths that sum to 8 are:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13. -3 -&gt; 11</code></pre><p>解决问题的代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span> <span class="token operator">+</span>         <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token operator">+</span>         <span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先明确，递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架必然要出现在主函数 pathSum 中。那么对于每个节点，他们应该干什么呢？他们应该看看，自己和脚底下的小弟们包含多少条符合条件的路径。</p><p>根据刚才的分析来<strong>定义清楚每个递归函数应该做的事</strong>：</p><ul><li><p>PathSum 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，和为目标值的路径总数。</p></li><li><p>count 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。</p></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 有了以上铺垫，详细注释一下代码 */</span><span class="token keyword">int</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pathImLeading <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 自己为开头的路径数</span>    <span class="token keyword">int</span> leftPathSum <span class="token operator">=</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左边路径总数（相信他能算出来）</span>    <span class="token keyword">int</span> rightPathSum <span class="token operator">=</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 右边路径总数（相信他能算出来）</span>    <span class="token keyword">return</span> leftPathSum <span class="token operator">+</span> rightPathSum <span class="token operator">+</span> pathImLeading<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 我自己能不能独当一面，作为一条单独的路径呢？</span>    <span class="token keyword">int</span> isMe <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">==</span> sum<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左边的小老弟，你那边能凑几个 sum - node.val 呀？</span>    <span class="token keyword">int</span> leftBrother <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> sum <span class="token operator">-</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 右边的小老弟，你那边能凑几个 sum - node.val 呀？</span>    <span class="token keyword">int</span> rightBrother <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> sum <span class="token operator">-</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  isMe <span class="token operator">+</span> leftBrother <span class="token operator">+</span> rightBrother<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 我这能凑这么多个</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是那句话，明白每个递归函数能做的事，并相信他们能够完成。</p><blockquote><p>总结下，PathSum 函数提供的二叉树遍历框架，在遍历中对每个节点调用 count 函数，看出先序遍历了吗（这道题什么序都是一样的）；count 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。</p></blockquote><h2 id="动态规划详解"><a href="#动态规划详解" class="headerlink" title="动态规划详解"></a><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484524&idx=1&sn=302941466dbf594709b5436a59f8b06c&chksm=9bd7fa64aca07372a8da4b9c4a5f1bab33ee0a93643bf8529c73f43c06b5e3adbbd42877775e&scene=21#wechat_redirect" target="_blank" rel="noopener">动态规划详解</a></h2><p>动态规划遵循一套固定的流程：<strong>递归的暴力解法 -&gt; 带备忘录的递归解法 -&gt; 非递归的动态规划解法</strong>。</p><blockquote><p>任何技巧都需要练习</p></blockquote><h3 id="例子——斐波那契数列"><a href="#例子——斐波那契数列" class="headerlink" title="例子——斐波那契数列"></a>例子——斐波那契数列</h3><p>暴力解法</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> N <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>存在很多重复的计算——》动态规划中的重叠子问题</p><p>用vector优化</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 备忘录全初始化为 0</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化最简情况</span>    memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> memo<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 未被计算过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">helper</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目前还是置顶向下推论，所以需要vector来保存结果</p><p>动态规划</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> curr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自下而上的方式。只需要保存两个数即可。</p><h3 id="例子——凑零钱"><a href="#例子——凑零钱" class="headerlink" title="例子——凑零钱"></a>例子——凑零钱</h3><p>原题</p><pre><code>题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。</code></pre><p>状态转移方程<br>$$<br>f(n)=\begin{cases}<br>0 ,n=0\\<br>1+ min(f(n-c_i) | 1&lt;=i&lt;=k) \\<br>\end{cases}<br>$$</p><p>这个方程就用到了<strong>「最优子结构」性质：原问题的解由子问题的最优解构成。</strong>即 f(11) 由 f(10), f(9), f(6) 的最优解转移而来。</p><blockquote><p>记住，<strong>要符合「最优子结构」，子问题间必须互相独立。</strong></p><p>什么是子问题必须独立？</p><p>比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高” 这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：<strong>你的语文成绩和数学成绩会互相制约，此消彼长</strong>。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p></blockquote><p>递归代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token punctuation">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 金额不可达</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 子问题无解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带备忘录的递归代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 备忘录初始化为 -2</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">helper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token punctuation">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 金额不可达</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> subProb <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 子问题无解</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>subProb <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> subProb <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 记录本轮答案</span>    memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> INT_MAX<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> ans<span class="token punctuation">;</span>    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态规划代码</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 内层 for 在求所有子问题 + 1 的最小值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token punctuation">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考 “如何穷举”，然后再追求 “如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决 “如何穷举” 的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求 “如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode初级算法题解——字符串</title>
      <link href="/2019/10/20/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/10/20/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><pre><code>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。示例 1：输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2：输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>翻转字符串在很多编程语言内置的库就已经有了，比如在python中，直接用<code>reverse</code>即可解决。如果直接用系统库，那只是考察队队系统的熟练度，并没有考察到自己的思维能力。虽然可以通过LeetCode，但不应该止步于此。</p><p>如何自己实现字符串翻转，就是把字符串左右分别交换就实现了字符串的翻转。解法也非常简单。右边的索引就是<code>len(s) - i - 1</code>,左边的索引就是<code>i</code>。</p><p><strong>关键是什么时候停止呢，只需要翻转一半的元素，否则就回到原样了。如果是偶数那么一半就是<code>len(s) // 2</code>，如果是奇数，最中间的那个数不用管，依然是<code>len(s) // 2</code>的时候停止。</strong></p><p>除了直接对半分还有一种比较简单的思路，想象成为左右两个指针，也就是左边的指针碰到右边的指针就停止。</p><h2 id="系统库解法"><a href="#系统库解法" class="headerlink" title="系统库解法"></a>系统库解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: List[str]        :rtype: None Do not return anything, modify s in-place instead.        """</span>        s<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前后交换解法"><a href="#前后交换解法" class="headerlink" title="前后交换解法"></a>前后交换解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: List[str]        :rtype: None Do not return anything, modify s in-place instead.        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> i            right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i            s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: List[str]        :rtype: None Do not return anything, modify s in-place instead.        """</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        left <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2. 整数反转"></a>2. 整数反转</h1><h2 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h2><pre><code>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><blockquote><p>复习一下python和其他语言在除法上的一些不同</p><ul><li><p><strong>python的取模是根据向下取整法</strong>的，<strong>而c/c++/java是基于向零取整的</strong>。<br>例如：</p><ul><li><p>在python除以 ：<code>-53 // 10 = -6</code><br>在c语言中，<code>-53 / 10 = -5</code></p></li><li><p>在python取模：<code>-53 % 10 = 7</code></p><p> 在c语言中，<code>-53 % 10 = -3</code></p></li><li><p>python3中， /是精确除法，//是向下取整除法，%是求模，四舍五入取整round, 向零取整int, 向下和向上取整函数math.floor, math.ceil）</p></li></ul></li></ul></blockquote><p> 整体思路有两种，一种是用将整数转为字符串，进而反转字符串；一种是直接通过数学计算反转整数。</p><p>如果是直接反转整数，需要考虑到两个问题：</p><ol><li>溢出：题目要求<code>环境只能存储得下 32 位的有符号整数</code>。就需要在最后得到数字的时候判断是否在这个范围内，如果不在这个范围内就返回0。</li><li>正负：因为可能是负数，可以先记录下这个整数是否为负数，然后把这个数取绝对值，剩下的流程和整数操作一样。在最后根据这个整数是否为负数，如果是就在输出的基础上乘以<code>-1</code>。</li><li>如何反转：利用整除，取模，不断从整数末尾取出数字，然后迭代。<ol><li>这个过程中需要注意后面以0结尾的情况，比如输入<code>120</code>，反转之后输出<code>21</code>。这一步我们可以直接对需要处理的整数进行过滤处理，舍弃掉最后的0.</li><li>整除的作用是去掉最后一位</li><li>取模的作用是得到最后一位</li></ol></li></ol><p>如果是转换为字符串来操作，因为在python中有丰富的库可以操作字符串核心思路就是先转为str，然后再把str转换为数字。需要用到字符串核心的几点，<code>翻转（::）、去除字符串起始，结束为止的特定字符串(strip)</code></p><h2 id="直接反转整数解法"><a href="#直接反转整数解法" class="headerlink" title="直接反转整数解法"></a>直接反转整数解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type x: int        :rtype: int        """</span>        r <span class="token operator">=</span> <span class="token number">0</span>        negative <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token comment" spellcheck="true">#去除末尾的0</span>        <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">10</span>        <span class="token comment" spellcheck="true">#负数判断</span>        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            negative <span class="token operator">=</span> <span class="token boolean">True</span>            x <span class="token operator">=</span> abs<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#反转</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span>            x <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">10</span>            r <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> r <span class="token operator">+</span> tmp        <span class="token keyword">if</span> negative<span class="token punctuation">:</span>            r <span class="token operator">*=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token comment" spellcheck="true">#是否溢出</span>        <span class="token keyword">if</span> r <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">and</span> r <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> r        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上诉python代码还可以用非常简洁的代码，把<code>if else合并写在一行</code></p><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        y<span class="token punctuation">,</span> res <span class="token operator">=</span> abs<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        of <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span>        <span class="token keyword">while</span> y <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> y <span class="token operator">%</span> <span class="token number">10</span>            <span class="token keyword">if</span> res <span class="token operator">></span> of<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            y <span class="token operator">//=</span> <span class="token number">10</span>        <span class="token keyword">return</span> res <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是用其他语言解决，就可以不用判断负数的情况。比如在java中，<code>-53 % 10 = -3</code>这样就得到了最后一位，而python中<code>-53 % 10 = 7</code>。</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> pop <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            temp <span class="token operator">=</span> temp <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> pop<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">></span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">||</span> temp <span class="token operator">&lt;</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="翻转字符串解法"><a href="#翻转字符串解法" class="headerlink" title="翻转字符串解法"></a>翻转字符串解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type x: int        :rtype: int        """</span>        <span class="token keyword">if</span> x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        str_x <span class="token operator">=</span> str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">if</span> str_x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>            x <span class="token operator">+=</span> <span class="token string">'-'</span>        x <span class="token operator">+=</span> str_x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> int<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">&lt;</span>x<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x        <span class="token keyword">return</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-字符串中第一个唯一字符"><a href="#3-字符串中第一个唯一字符" class="headerlink" title="3. 字符串中第一个唯一字符"></a>3. 字符串中第一个唯一字符</h1><h2 id="原题-2"><a href="#原题-2" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。案例:s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2.注意事项：您可以假定该字符串只包含小写字母。</code></pre><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>要判断字符是否重复，肯定需要遍历一次字符串。时间复杂度$O(n)$是少不了的了。</p><p>如何确定字符是否重复，常规思路就是用一个哈希表记录每个字符出现的次数。因为哈希表有序，遍历哈希表直到value为1的时候停止。</p><p>得益于python有很多内置的库，比如<code>collections</code>下面的<code>Counter</code>可以值统计出字符串每个数字出现的次数，这样就可以不用哈希表来统计了。除此之外，<strong>我们可以注意到，“您可以假定该字符串只包含小写字母”这个条件，是否可以以这个点角度出发呢。</strong></p><p>判断字符是否重复还有一种方式就是分别从左边、右找到第一个字符的索引，如果索引相同则说明没有重复。<strong>恰恰python提供了这样寻找索引的方法，分别是find、rfind。</strong>那么思路就简单了，遍历一下字符串，如果左边和右边得到的索引相同则说明没有重复。</p><p>代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> index            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过验证如果直接去循环字符串，在字符不是很多的情况下非常快。但是当字符很多，循环就会走很多次。<strong>这个时候可以考虑到小写字母，小写字母一共只有26个，那么如果我们只遍历小写字母，最多也就26次。所以我么可以改进一下之前的代码。</strong></p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span>str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        min_index <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">:</span>            index <span class="token operator">=</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">if</span> index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> index <span class="token operator">==</span> s<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>                min_index <span class="token operator">=</span> min<span class="token punctuation">(</span>min_index<span class="token punctuation">,</span> index<span class="token punctuation">)</span>        <span class="token keyword">return</span> min_index <span class="token keyword">if</span> min_index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h2><p>这种思路简单，而且代码也不复杂</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        h <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> h<span class="token punctuation">:</span>                h<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                h<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> h<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用<code>collections</code>下面的<code>Counter</code>简化</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#统计字符出现次数</span>        counter <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span>c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#找到并返回首个满足出现次数为一的字符</span>            <span class="token keyword">if</span> counter<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> index        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="左右查找解法"><a href="#左右查找解法" class="headerlink" title="左右查找解法"></a>左右查找解法</h2><p>核心就是一个元素唯一那么从左、右两边查找得到的索引是相同的。优化点就是遍历26个小写字母，减少遍历的次数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> index            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用小写字母优化</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span>str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        min_index <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">:</span>            index <span class="token operator">=</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span>c<span class="token punctuation">)</span>            <span class="token keyword">if</span> index <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">and</span> index <span class="token operator">==</span> s<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>                min_index <span class="token operator">=</span> min<span class="token punctuation">(</span>min_index<span class="token punctuation">,</span> index<span class="token punctuation">)</span>        <span class="token keyword">return</span> min_index <span class="token keyword">if</span> min_index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-有效的字母异位词"><a href="#4-有效的字母异位词" class="headerlink" title="4. 有效的字母异位词"></a>4. 有效的字母异位词</h1><h2 id="原题-3"><a href="#原题-3" class="headerlink" title="原题"></a>原题</h2><pre><code>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。示例 1:输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true示例 2:输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false说明:你可以假设字符串只包含小写字母。进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</code></pre><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>首先要理解字母异或词的含义，异或词就是s和t两个字符串由相同的字符组成，知识字符的位置不一样。相等于不关系字符顺序，只关心字符。</p><p>第一反应就是：一个简单的思路就是遍历字符串s，然后判断字符是否在另一个字符串t中出现过。然后以相同的方式遍历另一个字符t，判断字符是否在s中出现过。<strong>但是忽略了重复字符的问题，如何解决重复字符了，可以用两个哈希表记录每个字符出现的次数。然后对比哈希表。得益于Python中可以直接用<code>collections.Counter</code>统计出字符串各个字符出现的个数。所以可以更加简洁。</strong></p><p>出了统计个数这种方式来判断是否相等，我们还可以换个思路，遍历字符串s，与此同时另一个字符串t就删除这个字符。如果最后另一个字符串t为空，则说明所有字符都出现过。用这种方式替换掉了需要统计字符数量的过程。</p><p>进一步的因为题目说的是只包含小写字母。上一题中我们用里个小写字母这个条件优化了哈希表的方式，同理我们同样可以在这里优化。思路就是开辟一个长度为26的数组，下标代表当前字符，数组值就是出现的次数。一加一减，然后判断这个数组的每个值是否为0。</p><blockquote><p>最后字符串其实也可以排序，而且在python中是天然支持的，直接一个sort就解决。然后判断排序之后两个字符串是否相等。直接一行代码<code>return sorted(s) == sorted(t)</code></p></blockquote><h2 id="哈希表统计次数解法"><a href="#哈希表统计次数解法" class="headerlink" title="哈希表统计次数解法"></a>哈希表统计次数解法</h2><p>哈希表可以用collections模块代替。核心思路就是相同的，统计字符出现数量，对比字符及数量</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        couter1 <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>s<span class="token punctuation">)</span>         couter2 <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>t<span class="token punctuation">)</span>         <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> couter1<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> couter2<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> value <span class="token operator">!=</span> couter2<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除字符是否为空解法"><a href="#删除字符是否为空解法" class="headerlink" title="删除字符是否为空解法"></a>删除字符是否为空解法</h2><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> l<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            l<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时间复杂度就比较大了，遍历+查找</p><h2 id="数组优化"><a href="#数组优化" class="headerlink" title="数组优化"></a>数组优化</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment" spellcheck="true">#长度只有26</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            index <span class="token operator">=</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">97</span>            l<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> t<span class="token punctuation">:</span>            index <span class="token operator">=</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">97</span>            l<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> l<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="系统库函数——排序字符串解法"><a href="#系统库函数——排序字符串解法" class="headerlink" title="系统库函数——排序字符串解法"></a>系统库函数——排序字符串解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    <span class="token keyword">return</span> sorted<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> sorted<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="5-验证回文字符串"><a href="#5-验证回文字符串" class="headerlink" title="5. 验证回文字符串"></a>5. 验证回文字符串</h1><h2 id="原题-4"><a href="#原题-4" class="headerlink" title="原题"></a>原题</h2><pre><code>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。示例 1:输入: &quot;A man, a plan, a canal: Panama&quot;输出: true示例 2:输入: &quot;race a car&quot;输出: false</code></pre><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>抓住条件只考虑字母和数字，并且忽略大小写。首先对输入字符串清理一遍，全部转为小写，其次需要确定如何验证的字符的合法性。Python中，字符可以直接比较大小。所以比较简单，而其他语言需要先转换为ascii才行。</p><p>接下来就是就是判断左、右两边的字符是否对称。有两种方式一种就是在一开始就把字符串处理为只包含数字和字母的，其他的字符全部删除掉，然后左右判断；另一种就是判断如果当前不是合法字符就移动自己的指针，另一边的指针不动。</p><h2 id="对字符预处理解法"><a href="#对字符预处理解法" class="headerlink" title="对字符预处理解法"></a>对字符预处理解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isNumOrLetter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>  <span class="token string">'a'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span> <span class="token operator">or</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>        tmp <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> tmp<span class="token punctuation">:</span>            s <span class="token operator">=</span> s<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>        left  <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="直接左右移动解法"><a href="#直接左右移动解法" class="headerlink" title="直接左右移动解法"></a>直接左右移动解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isNumOrLetter</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>  <span class="token string">'a'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span> <span class="token operator">or</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span>     <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>isNumOrLetter<span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>判断字符是否为字母与数字组合在python中可以直接用<code>isalnum</code>。</p></blockquote><p>最终可以简化为</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    l <span class="token operator">+=</span> <span class="token number">1</span>                    r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="终极版"><a href="#终极版" class="headerlink" title="终极版"></a>终极版</h2><p>结合起那么的特种特性。</p><ul><li>用系统库判断是否为字母、数字。</li><li>左右移动逻辑改为直到找到合法数字才停止移动，也就是先找到合法数字，进而直接比较，而不是每次都去移动。将前面的四个if，变成一个if，简化了逻辑。</li></ul><pre class="line-numbers language-python"><code class="language-python">   <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token operator">and</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token operator">and</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> right <span class="token operator">-=</span> <span class="token number">1</span>             <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-字符串转换整数-atoi"><a href="#6-字符串转换整数-atoi" class="headerlink" title="6. 字符串转换整数 (atoi)"></a>6. 字符串转换整数 (atoi)</h1><h2 id="原题-5"><a href="#原题-5" class="headerlink" title="原题"></a>原题</h2><pre><code>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。示例 1:输入: &quot;42&quot;输出: 42示例 2:输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3:输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。示例 4:输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。     因此无法执行有效的转换。示例 5:输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。</code></pre><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>抽取题目中信息：</p><ol><li>丢弃无用的开头空格字符——python知己二用<code>lstrip()</code></li><li>找到第一个非空字符——可能是数字，字母，其他特殊字符</li><li>第一个非空字符是正号、负号、数字。则可以进一步处理。</li><li>有效整数部分多余的字符直接忽略</li><li><strong>只能存储 32 位大小的有符号整数</strong></li></ol><p>字符是否可以转为整数，我们可以用<code>try except</code>捕获。</p><p>为了处理字符连续部分，我们可以利用python字符串截取的快速操作——<code>:</code>。</p><p>现在有个问题如何去处理连续字符，如果找到了第一个字符是数字，那么如果将接下来的部分连续起来。——我们就用字符串截取，从找到第一个合法数字开始截取，只要是可以转为整形，那么一直截取。</p><p>那么重要的就是找到开始截取的位置。考虑有<code>+-</code>号，是否可以先对这种情况做个判断，用一个数字记录一下开始截取的位置。如果是<code>+</code>，截取位置往后移动1位，为<code>-</code>可以直接转为整数，所以可以不管。</p><blockquote><p>注意python中<code>:</code>截取，右边的数字代表截取到第几个元素为止。而不是索引值。</p></blockquote><p>最后就是判断是否溢出。</p><p>上面我们用了强转判断是否可以转为整形，我们也可以直接判断当前字符是否在<code>0-9</code>。而如何组成最终的数字了，用一个数保持当前的值，然后每次乘10，加上当前字符的值就是结果。<strong>整体思路和上面类似，把强转用判断是否是<code>0-9</code>替换掉而已。</strong></p><blockquote><p>一些优化点：比如使用异或得到上下边界，可以直接写死，这样就不用异或了。</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token keyword">if</span> r <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">2147483648</span> <span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2147483648</span>        <span class="token keyword">if</span> r <span class="token operator">></span> <span class="token number">2147483647</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">2147483647</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>除了上面这种老老实实的去计算，<code>if else</code>判断。有大佬直接用正则表达式一行解决。牛逼！自己对正则也用的不多。这里简单介绍下</p><blockquote><p>一行代码：<code>max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;, s.lstrip())), 2**31 - 1), -2**31)</code></p><p>使用正则表达式：</p><p>^：匹配字符串开头<br>[+-]：代表一个+字符或-字符<br>?：前面一个字符可有可无<br>\d：一个数字<br>+：前面一个字符的一个或多个<br>\D：一个非数字字符<br><em>：前面一个字符的0个或多个<br>max(min(数字, 2<em>*31 - 1), -2</em></em>31) 用来防止结果越界</p><p>为什么可以使用正则表达式？如果整数过大溢出怎么办？</p><p>题目中描述： 假设我们的环境只能存储 32 位大小的有符号整数</p><p>首先，这个假设对于 Python 不成立，Python 不存在 32 位的 int 类型。其次，即使搜索到的字符串转32位整数可能导致溢出，我们也可以直接通过字符串判断是否存在溢出的情况（比如 try 函数 或 判断字符串长度 + 字符串比较）</p></blockquote><h2 id="强转异常捕获解法"><a href="#强转异常捕获解法" class="headerlink" title="强转异常捕获解法"></a>强转异常捕获解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type str: str        :rtype: int        """</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        index <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">or</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token keyword">else</span> <span class="token number">1</span>        r <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#这里index不是索引，而是截取的停止点</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> int<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>                index <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">except</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">if</span> r <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span>        <span class="token keyword">if</span> r <span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="每次乘10解法"><a href="#每次乘10解法" class="headerlink" title="每次乘10解法"></a>每次乘10解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type str: str        :rtype: int        """</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#记录是否为负数</span>        flag <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token keyword">else</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">#是否为+-号，如果是就往后移一位才开始判断</span>        index <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">or</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token keyword">else</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">#这里index不是索引，而是截取的停止点</span>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> r <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>                index <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>        r <span class="token operator">*=</span> flag        <span class="token keyword">if</span> r <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span> <span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span>        <span class="token keyword">if</span> r <span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正则表达式解法"><a href="#正则表达式解法" class="headerlink" title="正则表达式解法"></a>正则表达式解法</h2><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">def</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>min<span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token operator">*</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'^[\+\-]?\d+'</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="7-实现strStr"><a href="#7-实现strStr" class="headerlink" title="7. 实现strStr()"></a>7. 实现strStr()</h1><h2 id="原题-6"><a href="#原题-6" class="headerlink" title="原题"></a>原题</h2><pre><code>实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2示例 2:输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</code></pre><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>咋看这题如果用库函数来解决，就一行代码的问题<code>return haystack.find(needle)</code>。但是肯定不能这样做，不然这道题根本就没有意义了。</p><p>自己写的时候用的就是暴力破解，一个一个字符去匹配。具体步骤就是遍历haystack，needle。分别对比当前的字符，如果相等则继续移动，不相等则needle重置索引，haystack往后一移位再比较。<strong>而对应到代码中比较麻烦的就是不等的时候如何去计算haystack的索引值。</strong></p><p>当然可以用一个变量记录一下当前i的值，下一次不等的时候直接从这个i的位置加1重新开始匹配。最开始也是这样写的，但是感觉很别扭</p><pre class="line-numbers language-python"><code class="language-python">        <span class="token comment" spellcheck="true">#记录当前匹配的位置    </span>        current <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>haystack<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> current <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    current <span class="token operator">=</span> i                    r <span class="token operator">=</span> i                i <span class="token operator">+=</span> <span class="token number">1</span>                j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>haystack<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span> <span class="token operator">and</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    i <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span>                    j <span class="token operator">=</span> <span class="token number">0</span>                    current <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这个时候需要注意到i和j的关系。因为都是同时加一，所以i-j就得到了i当前匹配的起始位置。在不等的时候需要将i移到下一位，所以还需要加1。所以最终可以把代码简化到不用额外的变量记录当前i的位置。</strong></p><pre class="line-numbers language-python"><code class="language-python">            <span class="token keyword">if</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                i <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>                j <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后遍历完之后，还需要判断一下needle有没有走完。needle遍历完了，则其实位置的索引就是<code>i-j</code>。如果没走完则返回-1。</p><p>除此之外还有一种KMP解法，对KMP都忘了。后面再补上。</p><h2 id="使用库函数解法"><a href="#使用库函数解法" class="headerlink" title="使用库函数解法"></a>使用库函数解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">strStr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> haystack<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> haystack<span class="token punctuation">.</span>find<span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>当时在写这块代码的时候在如何确定<code>i</code>的值上面纠结了很久。显示用一个变量记录当前i的值，如果不相等就从这个位置加1。</p><p>后来考虑到i的值可以直接由j得到。代码就更加简单了</p><p>第一版，比较难看</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">strStr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> haystack<span class="token punctuation">:</span> str<span class="token punctuation">,</span> needle<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        r<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>        current <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>haystack<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> current <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                    current <span class="token operator">=</span> i                    r <span class="token operator">=</span> i                i <span class="token operator">+=</span> <span class="token number">1</span>                j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>haystack<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span> <span class="token operator">and</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    i <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span>                    j <span class="token operator">=</span> <span class="token number">0</span>                    current <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> j <span class="token operator">!=</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">:</span>            r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二版，用j标识i的值，简洁了很多</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">strStr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> haystack<span class="token punctuation">,</span> needle<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>haystack<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                i <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>                j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> len<span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> i <span class="token operator">-</span> j        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>得到一个教训：分析好变量与变量之间的关系，循环变量与变量之间是否存在着某种数量关系，这对简化代码非常重要。比如这里还有一个隐藏关系——字符长度。其实还可以把遍历的范围缩小。</p></blockquote><h2 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h2><p>TODO</p><h1 id="8-报数"><a href="#8-报数" class="headerlink" title="8. 报数"></a>8. 报数</h1><h2 id="原题-7"><a href="#原题-7" class="headerlink" title="原题"></a>原题</h2><pre><code>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：1.     12.     113.     214.     12115.     1112211 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。示例 1:输入: 1输出: &quot;1&quot;示例 2:输入: 4输出: &quot;1211&quot;</code></pre><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>这道题的重点就是明确题意。总结起来就是：从左往右数，数字个数+数字本身=下一个数字。这就是生成后续数字的方法。</p><p>我们可以写出第6个数：”three 1 two 2 one 1”，那么就是312211。如果存在重复的则把该次重复的数走完才进行下一个。</p><p>既然我们知道如何得到下一个数那么就可以模拟出整个过程。<code>r += str(count) + pre[index]</code>这句话就是核心。</p><p>为了代码清晰，这里抽出了一个方法通过传入上一个得到下一个数<code>next_num</code>。需要判断是否重复，如果重复则统计出现的次数（<strong>count默认是1，因为遍历到了肯定有一个</strong>），并且不断往右移动，如果不重复，就将之前的加到结果字符串上，同时也需要往右移动。</p><p>最开始想不开辟新的方法来实现，搞了半天，不是很好操作。后来模块独立出来，思路就很清晰了。</p><h2 id="系统库解法-1"><a href="#系统库解法-1" class="headerlink" title="系统库解法"></a>系统库解法</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> itertools <span class="token keyword">import</span> groupby<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countAndSay</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token string">'1'</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            result <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>str<span class="token punctuation">(</span>len<span class="token punctuation">(</span>list<span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> k <span class="token keyword">for</span> k<span class="token punctuation">,</span> g <span class="token keyword">in</span> groupby<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模拟整个过程解法"><a href="#模拟整个过程解法" class="headerlink" title="模拟整个过程解法"></a>模拟整个过程解法</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">countAndSay</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type n: int        :rtype: str        """</span>        <span class="token keyword">def</span> <span class="token function">next_num</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">:</span>            r <span class="token operator">=</span> <span class="token string">''</span>            index <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">:</span>                count <span class="token operator">=</span> <span class="token number">1</span>                <span class="token keyword">while</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>pre<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">and</span> pre<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> pre<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>                    index <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true">#不等的情况</span>                r <span class="token operator">+=</span> str<span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">+</span> pre<span class="token punctuation">[</span>index<span class="token punctuation">]</span>                index <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> r        r <span class="token operator">=</span> <span class="token string">'1'</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            r <span class="token operator">=</span> next_num<span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-最长公共前缀"><a href="#9-最长公共前缀" class="headerlink" title="9. 最长公共前缀"></a>9. 最长公共前缀</h1><h2 id="原题-8"><a href="#原题-8" class="headerlink" title="原题"></a>原题</h2><pre><code>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。说明:所有输入只包含小写字母 a-z 。</code></pre><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>处理的是字符串数组，<strong>要求是最长公共前缀。</strong>最朴素的方法就是每次都取出每个字符串对应位置的字符进行比较，如果相等则继续，如果不等则返回。需要注意的是最短的字符串不一定在末尾尾，那么就需要每次遍历的时候判断其中是否有字符串遍历完成。否则会出现越界的情况。</p><blockquote><p>在上面的基础上还可以做优化。我们只需要遍历最短字符串的长度即可。我们可以默人以第一个字符串以基准进行比较。只要发现后面的有一个字符对应不上则立即返回。</p></blockquote><p>如果结合python特有的字符串处理特性。还有两种让人拍案叫绝的方法。</p><ol><li><p>利用python的max()和min()，在Python里字符串是可以比较的，<strong>按照ascII值排</strong>，比如<code>abb</code>， <code>aba</code>，<code>abac</code>，最大为<code>abb</code>，最小为<code>aba</code>，那么公共前缀及时<code>ab</code>。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀。<strong>有些同学不知道为什么，比如上面的例子，因为是排好序的，wu</strong></p></li><li><p>利用python的zip函数，把str看成list然后把输入看成二维数组，左对齐纵向压缩，然后把每项利用集合去重，之后遍历list中找到元素长度大于1之前的就是公共前缀</p><blockquote><p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表</p><p>例子：</p><p>a = [1,2,3]<br>b = [4,5,6]<br>c = [4,5,6,7,8]<br>zipped = zip(a,b)     # 打包为元组的列表<br>[(1, 4), (2, 5), (3, 6)]<br>zip(a,c)              # 元素个数与最短的列表一致<br>[(1, 4), (2, 5), (3, 6)]<br>zip(<em>zipped)          # 与 zip 相反，</em>zipped 可理解为解压，返回二维矩阵式<br>[(1, 2, 3), (4, 5, 6)]</p></blockquote></li></ol><h2 id="先确定最短字符串解法"><a href="#先确定最短字符串解法" class="headerlink" title="先确定最短字符串解法"></a>先确定最短字符串解法</h2><pre class="line-numbers language-python"><code class="language-python">  <span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type strs: List[str]        :rtype: str        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">''</span>        min_len <span class="token operator">=</span> min<span class="token punctuation">(</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> strs<span class="token punctuation">]</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>min_len<span class="token punctuation">)</span><span class="token punctuation">:</span>            c <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">for</span> s <span class="token keyword">in</span> strs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> c <span class="token operator">!=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> r            r <span class="token operator">+=</span> c        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用python库"><a href="#使用python库" class="headerlink" title="使用python库"></a>使用python库</h2><h3 id="min、max"><a href="#min、max" class="headerlink" title="min、max"></a>min、max</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> strs<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">""</span>        s1 <span class="token operator">=</span> min<span class="token punctuation">(</span>strs<span class="token punctuation">)</span>        s2 <span class="token operator">=</span> max<span class="token punctuation">(</span>strs<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span>x <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">!=</span> s2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> s2<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> strs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> strs<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">""</span>        ss <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>set<span class="token punctuation">,</span> zip<span class="token punctuation">(</span><span class="token operator">*</span>strs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token string">""</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> x <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> list<span class="token punctuation">(</span>x<span class="token punctuation">)</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            res <span class="token operator">=</span> res <span class="token operator">+</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的9道初级题，感受了字符串在LeetCode上的初级难度。整体来讲大部分题目的思路是有的，<strong>难点在于如果把思路转换为代码。</strong></p><p>纵观这些题目，常用的技巧有</p><ul><li>使用系统函数库：对于字符的操作，大部分语言都有丰富的库函数，比如python中，str有常用的<code>strip,find,indexof</code>。除此之外还有集合<code>collections,min,max</code>等等。有时候使用这些库函数，非常之简单。<strong>但是不能完全考察我们的分析能力，编码能力。所以最好还是在系统库的基础上，自己在用朴实的代码解决一次，这样更有意义。</strong></li><li>哈希表与数组：哈希表在数组的题目中也经常用到，在字符串的题目中频率不是特别高。因为大部分题目限定了是小写字母，那么就可以仅仅用数组就能达到保存信息的目的。<strong>常见的技巧就是用[255]个数组保存各个字符出现的次数。如果限定是小写，那么用26个字母即可。</strong></li><li>双指针：双指针在数组的题目中经常用到。在字符串的题目中也经常用。比如从字符的前后分别扫描。几个字符串中进行字符比较等，扩展一下就是所谓的左右查找，扫描。</li><li>数字与字符：有些题目结合了数字的特点。常见的需要将字符转为数字。思路有两种，一种是直接判断字符是否在字符<code>0-9</code>之间（python可以直接比较字符）；还有一种就是用<code>try except</code>捕获强转实现。关于数字的操作，无非就是取余，乘除10。</li><li>考虑边界及逻辑优化：这类题比较烧脑筋。需要考虑的情况很多，比如字符串转整数，先把正负号单独拿出来做处理，提前把移动的初始位置确定好（也就是前提条件的确定）。<strong>在取字符的下一位的时候可以强转下一位字符，也可以强转截取到当年位置的字符，后者更加便捷。</strong><ul><li>在实现strStr()题目中，由于没有细致的分析道i,j循环变量的关系。用了一个非常不优雅的方法来记录新的起始位置。后来观察到新的起始位可以用i，j直接表示代码就好看多了。这种思路很重要，<strong>寻找变量之间的关系，一般是循环变量，往往起到事半功倍的效果。</strong></li><li>报数这道题也有值得好好回味的地方。<strong>字符串的循环操作中，更多建议使用<code>while</code>，以为你<code>while</code>中更改index看起来更加合理。常见格式<code>while i &lt; len(str1) and j &lt; len(str2)</code>。</strong>在判断是当前值和下一个值是否相等的时候用<code>while</code>和<code>==</code>实现了if的效果，避免了其他冗余的判断。</li></ul></li><li>发现规律：有些题目是必须在发现规律的前提下才能解决。比如报数，这类型的题需要仔细，反复推敲例子才行。有了规律，剩下比较麻烦的就是用代码吧规律写出来。技巧有递归，while循环，while加多重条件。</li></ul><p>综上自己感觉在<code>考虑边界及逻辑优化</code>这上面好好提升下。尤其是如何用代码把思路表达出来，报数这题还是非常有提升意义的。</p><p>最后谈谈如何优化。</p><blockquote><p>优化很多时候就是去找边界，隐藏着的信息。比如最后公共前缀这题。如果老老实实一个一个遍历，性能不佳。那么考虑到先找到最短的字符串，然后以最短的长度去遍历就会提升一大截。而隐藏的条件就是靠平时的积累了。比如提到字符串，字符串长度，字符串是否有序，字符必须是小写等等。一步一步缩小问题范围。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对学习的一些理解</title>
      <link href="/2019/10/19/2019/10/%E5%AF%B9%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>/2019/10/19/2019/10/%E5%AF%B9%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你不能用简单的语言描述自己学的知识，你就没有真正学会。</p></blockquote><h1 id="1-什么是学习"><a href="#1-什么是学习" class="headerlink" title="1. 什么是学习"></a>1. 什么是学习</h1><p>记忆和学习我们很容易搞混</p><ul><li>记忆：容量有限，难以集齐</li><li>学习：找出知识，<strong>压缩信息</strong></li></ul><blockquote><p>通过例子找出规律压缩成知识 nice！</p></blockquote><p>一些有价值的讨论</p><blockquote><ul><li>学习不等于理解或记住结论。 <strong>而是要让自己体验一番找出这些结论的那个过程</strong>。 “此过程”才是学习，或者说体验问题然后总结结论的能力就叫做学习。</li><li>学习包含记忆的过程，但是是对记忆的提取、压缩、总结。记忆是学习的基础，而学习是比记忆更高级的信息加工过程？人看到事物、例子先用记忆储存，然后再用学习加工记忆到的信息，提取出知识、模型，最后再用记忆把知识、模型储存在大脑中。</li><li>如果没有用简单的语言去描述它，你就没有学会它——放之四海皆准的学习奥义</li></ul></blockquote><h1 id="2-如何学习"><a href="#2-如何学习" class="headerlink" title="2. 如何学习"></a>2. 如何学习</h1><p>例子，问题，答案，体会问题和答案之间的关系</p><p>学习步骤（机器学习的步骤类似）：</p><ul><li>明确问题和答案</li><li>用例子构建知识</li><li>验证知识的有效性</li></ul><p>一些有价值的讨论：</p><blockquote><ul><li>读厚书应该就是积累一些例子，读薄书就是从这些例子中找出它们的关系</li><li>学习的是一个故事，认知到的是简化后的一个成语，故事是例子，知识是成语，而且故事是具体单一的，成语却是抽象可用到各种不同语境。</li><li>死记硬背只是记住了知识的描述，并非知识本身。</li><li><strong>先积累知识，再根据自己精简总结。</strong></li><li>大概就是，通过足够多的例子，构建自己解决这一套方法的模型，并不断的作用模型解决问题，并修正模型。</li><li>聪明的学生并不需要刷太多题，因为善于找规律。——刷题就是为了寻找规律</li></ul></blockquote><h1 id="3-学习的误区"><a href="#3-学习的误区" class="headerlink" title="3. 学习的误区"></a>3. 学习的误区</h1><p>明确学习的输入输出，这是非常重要的。</p><p>学习的误区：</p><ol><li>错误的输入、输出——对应关系</li><li>不用例子学习</li><li>错误的学习方式</li></ol><p>视频文字完整版：</p><blockquote><p>学习最重要的两步明确问题，输入和答案输出，用例子构建知识学习方式分为两大类，运动类（语言，运动）和思考类（数学，逻辑）。</p><p>区别在于是否依靠意识，<strong>因为意识是后进化出来的，擅长解决的是推断问题，但速度缓慢</strong>。学不会的原因都出在错误的输入、输出，错误的学习方式，用思考类方式来学习所有知识，比如看书学游泳，不通过例子仅记忆知识。</p><p>以语言为例四项能力的正确输入、输出、类型分别是（听声音-说想法-读文字-写想法），应试英语的普遍误区是输入、<strong>输出变成了完形填空，阅读选择</strong>等。这类从一些文字到到另一些文字做思考类问题，用百词斩背单词还容易产生另一种偏差输入输出变成了图片到中文，英语学习中作为致命的是插入的中文思考这个中间输出不仅输出错误，而且非常缓慢会让很多种懂外语但未经训练的人同时翻译中文的话，他们会反应不过来就是因为他们的大脑在这个过程中其实并不思考中文，当出国后就会发现所学英语的输入和真实英语的输入是不同的，根本用不了。</p><p>不通过例子仅记忆知识也是特别常见的错误<strong>由于语言的输入从来就不是一个单词，而是一个句子.</strong>要想把握句子中某个单词的真正含义.<strong>需要通过体会大量不同的列句，但多数时候，学生仅仅是记住了单词的中文描述</strong>，很多英语名师也都犯一样的错误，不管他们总结的再好，若仅仅是把他的总结告诉学生，学生永远都是把他的总结当成信息记忆，而不是作为知识学习。学不会英语，是因为搞错了输入输出。造成学到的是完全不同的知识。</p></blockquote><p>讨论</p><blockquote><ul><li>为什么当年张三丰要让张无忌忘了所有的招式，越教忘的越多，因为招式就是例子，剑法才是知识。</li><li>在国外学习多年后也发现这个了，听到英文并没有先想中文翻译是什么，先想到的是这句话的意思（￣▽￣）</li></ul></blockquote><h1 id="4-应用误区"><a href="#4-应用误区" class="headerlink" title="4. 应用误区"></a>4. 应用误区</h1><p>解决问题的方法：</p><ol><li>多学知识，知识是学不完的</li><li>分而治之，解决小问题然后解决大问题——强大的武器，将指数知识量变成线性知识</li></ol><p>问题复杂造成的现象：</p><ol><li>编程无头绪</li><li>写作不出文字</li><li>解题没有思路</li><li>工作难应付</li></ol><p>核心是：意识只能在某一个刻专注于一个思考类问题，而大脑习惯于搜索能够直接从输入得到输出的知识，如果某一个输入无法从脑中搜索出输出，那么问题就无法解决。解决办法可以多学知识，但是知识是无穷的。</p><blockquote><p>总结一下，首先大脑里面要有某个领域的基础知识，也就是能够解决小问题的知识。这些内容作为基础，只有有了这些基础，才能分而治之将大问题分为小问题，进而解决大问题。如果没有基础知识就会有没有头绪。</p></blockquote><p>视频文字完整版：</p><blockquote><p>我们可以同时运用多个运动类知识，比如某人可以边走路边聊天，但意识在某一刻，只能专注一个思考虑问题，因此在某一刻，若无法从脑中搜索到能直接从输入得到输出的知识，问题就无法解决，然而我们所掌握的知识又是有限的。</p><p>这种直接从输入得到输出的知识，往往会超过我们的知识范围，应对办法可以是学习更多的知识，但还有一个简单却又无比强大的办法，就是分而治之。</p><p>将问题拆分为脑中存有的，能直接从输入得到输出的小问题来解决。你一定听过这个办法，但恐怕你并不知道他为什么如此强大，原因在于，它可以将原本需要你掌握指数级知识量才能解决的问题，变成应用线性级知识量就可以解决。</p></blockquote><p>有价值的讨论</p><blockquote><ul><li>三阶魔方若不考虑中心块朝向，则总共有43,252,003,274,489,856,000个可还原的状态。若考虑中心块朝向，则总共有88,580,102,706,155,225,088,000个可还原的状态。<br>所以这个就是一个典型的指数级复杂的问题。<br>但是为什么我们能看到一个十多岁的孩子如果掌握一定的方法的话，能够轻松的将这个问题解决。<ul><li>原因就是up所说的分而治之。如果把三阶魔方分成上中下三层，每层分为棱和角，再讲棱和角的还原分为相对位置还原和自身朝向还原的话。那么一个三阶魔方的还原可以划分成七个步骤</li><li>底层棱块还原、底层角块还原、中层棱块还原、顶层棱块翻色、顶层角块翻色、顶层棱块侧边色块还原、顶层角块色块还原【由于当魔方还原了两层之后第三层还原时前两层不能被打乱，所以需要更多步骤】。</li><li>然后这七个步骤，每步再分为色块位置和朝向的调整，那么每个步骤的难度就讲到到一个让人发指的地步了。</li><li>比如第一层要还原底部棱块和角块，棱块的位置在魔方上只有12个，角块的位置在魔方上只有八个，棱块的朝向有两个，角快的朝向只有三个。</li><li>所以说只要掌握了一些简单的手法就可以很轻松还原，即使还原顶层相对来说复杂一些，必须要用到一定的公式才能保证前两层不会在第三层还原时被破坏，但是被拆解成四个步骤之后每个步骤也只会出现不超过五种情况。<br>就这样一个有着43,252,003,274,489,856,000可能性的复杂问题，被拆解成每个小步骤只需要面对不到十种情况的相对简单问题。</li><li>当然最后要说明一下，上面说的这些是为了解释这个问题拆分可以指数级降低问题难度的原理。【个人角度】不代表魔方这种复杂问题本来就是这么简单的，魔方也是通过前人的不断努力，<strong>和复杂的数学计算才能化繁为简的。所以思路是绝对正确的，但是并不是你懂得这个就能直接化身天才还是需要努力的，不过话说一般人的日常工作和生活会遇上的问题绝不会是魔方这种复杂度的问题</strong>。</li></ul></li><li>对于数学题我是先搞明白这是考啥，如果是综合题，就将其所考知识点拆分，再理清楚各知识点关系，进而解决问题。——<strong>也就是先分析问题，找出问题可以分解为哪些已经掌握的知识（小知识）</strong></li><li>一些小问题就是基础，所以基础好的人提分提的快，学的快。</li><li>上大学后才慢慢试着去拆解问题，尝试用白话结合现实中的例子讲给自己听，发现这种方式真的是高效的多，就算长时间不接触忘记了也能很容易推出来，思维方式真的很重要</li></ul></blockquote><p>一个非常好的例子来说明拆分问题的:</p><pre><code>问题：为什么有些人的信仰可以让他们放弃作为生物的本能。小问题1信仰是什么？信仰是一种精神依托，是心理上的一种需求。小问题2生物的本能是什么？简单来说就是求生欲。小问题3放弃是什么？我想要的大于我拥有的，我愿意为了我想要的丢下我拥有的。结论：当人的精神依托大于人的求生欲，便可以为了精神依托而抛弃求生欲。</code></pre><h1 id="5-思维导图——学习方法"><a href="#5-思维导图——学习方法" class="headerlink" title="5. 思维导图——学习方法"></a>5. 思维导图——学习方法</h1><p>思维导图是一种学习方法</p><p>先列出一个关键词，它是什么，然后用这个一个关键词描述所有的例子，这就是压缩信息的过程。进而不得不分析这些例子共同的输入输出，找出规律。</p><p>考虑它的目的是什么，就是在思考输入是怎样变成输出的。输入就是一种变量，变成就是从输入到输出的一种变换关系，这就是函数。输入和输出的关系是无限的但是可以用这样一个函数描述。要学习的知识就是这种不变的具体关系也就是最终的函数。</p><p><strong>当在思考这些问题的时候，大脑连接被这些例子所改变，最终关联到一个关键词上，便完成了一次学习的过程。</strong></p><p>可以用更好的关键词来代表找出来的关系，一种是动宾结构，描述了输入和函数，输出也随之确定了。</p><p>思维导图的作用是用于：</p><ul><li>复习知识</li><li>加深印象</li><li>更新知识</li></ul><p>思维导图最强大的地方在于对知识的拆分，对知识进行细化。就是上一节的内容，分而治之。</p><blockquote><p>知识网络的好处在于知识的重用性上。拆分的知识之间彼此独立。——》面向对象的三大原则，高内聚，低耦合，重用原则。</p></blockquote><p>思维导图的使用步骤</p><ul><li>列关键词——由关键词描述所有的例子</li><li>它是什么——明确输入</li><li>它的目的——明确输出</li><li>拆分知识——拆分知识</li></ul><p>学习的原则：</p><ul><li><p>例子重塑大脑连接</p></li><li><p>将信息压缩成为知识</p></li><li><p>明确任务的输入输出</p></li><li><p>二阶知识拆分知识</p></li></ul><p>一些有价值的讨论:</p><blockquote><ul><li>我们之前的学习都是在记住别人的例子，也许能够记住，但很难灵活使用。没有自主学习的学习果然还是效率低下的啊<code>!(&lt;_&lt;)怪不得看班上很多人比学霸努力刻苦很多，但终究没什么成效啊！( ´_ゝ｀)</code>孔老夫子说的真对“学而不思则罔，思而不学则殆”，这个思，就是要寻找对应的例子吧！(&gt;_&gt;)找了那么久的高效学习法，原来早在初中就被一句概括了</li></ul></blockquote><h1 id="6-绘制思维导图"><a href="#6-绘制思维导图" class="headerlink" title="6. 绘制思维导图"></a>6. 绘制思维导图</h1><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g83tixcbt3j308x072t91.jpg" alt="1571481560449"></p><p>设计思维导图的依据：</p><ol><li>明确输入输出</li><li>将信息压缩成知识——关键词</li><li>例子重塑大脑连接</li><li>二阶知识拆分知识</li></ol><p>一个描述</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g83tixiyntj30gq0jwdiq.jpg" alt="1571481881487"></p><h1 id="7-费曼技巧——学习方法"><a href="#7-费曼技巧——学习方法" class="headerlink" title="7. 费曼技巧——学习方法"></a>7. 费曼技巧——学习方法</h1><blockquote><p>在学习的基础上多一个解释的步骤。因为解释就是弥补学习过程的最后一步——验证。其余的步骤可以在思维导图中完成。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g83tixdfccj308g0c5wet.jpg" alt="1571482727145"></p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g83tixgarfj308k07y74x.jpg" alt="1571482758551"></p><ul><li>说白了就是学的知识，要去应用。简单来说，将自己学过的知识讲述给别人，直到他听懂</li><li>学习分几层<ul><li>第一层，爆炸性思维，以单点做辐射思考，直到思维的极限。</li><li>第二层，联系形思考，以思维导图每个节点之间的关系，进行思考，整合节点逻辑关系。</li><li>第三，筛选形思考，去除非重要逻辑环节，排出低于阈值的思考单位。</li><li>第四步，模型抽取，以图像，声音，计算，数据，表达来综合抽取事物的模型，以求达到所有人能应用模型，甚至跨区域跨领域的思维能力。典型的是哲学，比哲学低一等级的是美学和心理学，再低一等级是应用科学。应用科学的知识迁移率和抽象度是最低的。</li><li>第五步，循环型思考，通过持续的用户反馈，教授他人，探索已有模型的未知应用领域，并且深化模型的结构，循环思维是没有极限的。</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上门介绍关于学习的探讨大部分是借鉴于机器学习。这也就不难理解机器学习中的一些名词，甚至可以将人类学习和机器学习的过程对应起来。如下图所示：</p><p><img src="http://ww1.sinaimg.cn/mw690/005M4Qg4ly1g7ld4xte0nj30o90cp750.jpg" alt></p><p>回顾本文可以提炼出如下关键字：</p><p><code>学习、例子、压缩、规律、方法、输入，输出，验证，分而治之，思维导图</code></p><h1 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h1><p><a href="https://space.bilibili.com/344849038/channel/detail?cid=54015" target="_blank" rel="noopener">学习观视频合集</a></p>]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——矩阵在图形变换的应用</title>
      <link href="/2019/10/11/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/10/11/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="图形变换基础"><a href="#图形变换基础" class="headerlink" title="图形变换基础"></a>图形变换基础</h1><p>图形学上我们经常使用矩阵给图像做各种各样的变换。之所以可以通过矩阵来变换图像（<strong>之前我们讲过矩阵可以理解为向量的函数，实现一个向量映射到一个新向量。</strong>），是因为图像可以看做是一个一个的像素点组成，一个一个的像素的其实就是一个二维向量，所以我们只需要矩阵变换像素点就可以达到变换图像的目的。</p><p>平面坐标上的一个点我们可以通过$(x,y)$表示，而三维空间的一个点可以通过$(x,y,z)$。可以看到最终的形式都是一个一个的向量。多个点就是多个向量，多个向量组合在一起就是矩阵。</p><h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><p>缩放我们可以看成是对各个点的缩放。对<strong>一个向量</strong>进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。</p><p>比如缩放向量${\bar{v}} = (3,2)$。我们可以把向量沿着x轴缩放0.5，使它的宽度缩小为原来的二分之一；我们将沿着y轴把向量的高度缩放为原来的两倍。我们看看把向量缩放(0.5, 2)倍所获得的$\bar{s}$是什么样的。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7u7gohpipj308c08cmxg.jpg" alt="img"></p><p>下面构造一个变换矩阵来为我们提供缩放功能。之前介绍过单位矩阵，每个对角线元素会分别与向量的对应元素相乘。如果我们把1变为3会怎样？</p><p>这样子的话，我们就把向量的每个元素乘以3了，这事实上就把向量缩放3倍。如果我们把缩放变量表示为$(S1,S2,S3)$，那么我们可以为任何一个三维坐标的点定义一个缩放矩阵。<strong>注意通常三维空间操作的点除了x,y,z之后还有一个w分量为1。3D空间中缩放w分量是无意义的，详细介绍可以去看看相关的图形学知识，这不做介绍。</strong><br>$$<br>\begin{bmatrix} \color{red}{S_1} &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{S_2} &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}{S_3} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{S_1} \cdot x \\ \color{green}{S_2} \cdot y \\ \color{blue}{S_3} \cdot z \\ 1 \end{pmatrix}<br>$$</p><h3 id="W分量——齐次坐标"><a href="#W分量——齐次坐标" class="headerlink" title="W分量——齐次坐标"></a>W分量——齐次坐标</h3><p>向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：</p><ul><li><p>它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的）</p></li><li><p>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移。</p></li></ul><h1 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h1><p>与缩放同理，平移其实也是对各个点的进行平移。</p><p><strong>平移(Translation)是在原始向量的基础上加上另一个向量</strong>从而获得一个在不同位置的新向量的过程，从而在位移向量基础上<strong>移动</strong>了原始向量。之前介绍过向量的加法，有与标量相加，向量相加。</p><p>和缩放矩阵一样，在4×4矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的3个值。如果我们把位移向量表示为$(T_x,T_y,T_z)$。我们就能把位移矩阵定义为<br>$$<br>\begin{bmatrix}  \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}{T_x} \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}{T_y} \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}{T_z} \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x + \color{red}{T_x} \\ y + \color{green}{T_y} \\ z + \color{blue}{T_z} \\ 1 \end{pmatrix}<br>$$</p><blockquote><p>因为所有的位移值都要乘以向量的<strong>w</strong>行，所以位移值会加到向量的原始值上（想想矩阵乘法法则）。而如果你用3x3矩阵我们的位移值就没地方放也没地方乘了，所以是不行的。</p></blockquote><h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>在平移，缩放，旋转三种变换中，旋转(Rotation)稍复杂些。</p><p>首先我们来定义一个向量的旋转到底是什么。2D或3D空间中的旋转用角(Angle)来表示。角可以是角度制或弧度制的，周角是360角度或$2Pi$弧度。</p><p>转半圈会旋转360/2 = 180度，向右旋转1/5圈表示向右旋转360/5 = 72度。下图中展示的2D向量$\bar{v}$是由$\bar{k}$向右旋转72度所得的</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7u7golqysj305y06haa0.jpg" alt="img"></p><p><strong>在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)</strong>。物体会沿着给定的旋转轴旋转特定角度。</p><p>使用三角学，给定一个角度，可以把一个向量变换为一个经过旋转的新向量。这通常是使用一系列<strong>正弦和余弦函数</strong>（一般简称sin和cos）各种巧妙的组合得到的。旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用$\theta$表示。</p><h2 id="二维坐标中的旋转"><a href="#二维坐标中的旋转" class="headerlink" title="二维坐标中的旋转"></a>二维坐标中的旋转</h2><blockquote><p>推到的过程是由结果向量及原始向量开始然后反推出变化矩阵的行列。</p></blockquote><p>要处理旋转，我们需要知道角度，如下图所示;</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7u7goflwjj308407q3yo.jpg" alt="1570764721109"></p><p>二维坐标：<br>$$<br>T \cdot \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} ? \\ ? \end{bmatrix}<br>$$</p><p> 首先要明确，无论怎样旋转，向量的长度是不会变的，这里我们假设向量长度为$d$。根据三角函数，我们可以把$d$分别用原向量的x,y，夹角$\theta$和旋转后的$x^<code>, y^</code>, \alpha$表示出来。</p><p>那么就可以得到下面的等式：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7u7gofchyj30dd044mxi.jpg" alt="1570765157073"></p><p>有了这些等式就可以把$x，x^`, \theta , \alpha$建立关系</p><p>进一步推导</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7u7gogefkj30dm06ymxy.jpg" alt="1570765279551"></p><p>到现在解决了旋转之后$x$的值<br>$$<br>T \cdot \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} cos\theta \cdot x  + sin\theta \cdot y \\ ? \end{bmatrix}<br>$$<br>同理我们可以把旋转之后y的值用原$\theta,x,y$表示出来</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7u7gogvozj30dg06zgme.jpg" alt="1570765577295"></p><p>最终得到旋转之后的坐标<br>$$<br>T \cdot \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} cos\theta \cdot x  + sin\theta \cdot y \\ -sin\theta \cdot x + cos\theta \cdot y \end{bmatrix}<br>$$<br>有了这个最终的结果向量，我们就可以推断出变化矩阵首先是一个2 * 2的矩阵。<br>$$<br>T = \begin{bmatrix} cos\theta   &amp; sin\theta \\ -sin\theta &amp;cos\theta  \end{bmatrix}<br>$$</p><h2 id="三维坐标旋转"><a href="#三维坐标旋转" class="headerlink" title="三维坐标旋转"></a>三维坐标旋转</h2><p>三维坐标旋转的推导过程和二维旋转的类似，但是更加复有三种情况，因为三维有三个轴，绕不同轴旋转是不一样的。这里直接给出结论：</p><p>沿x轴旋转：<br>$$<br>\begin{bmatrix} \color{red}1 &amp; \color{red}0 &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}{\cos \theta} &amp; - \color{green}{\sin \theta} &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}{\sin \theta} &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\ \color{green}{\cos \theta} \cdot y - \color{green}{\sin \theta} \cdot z \\ \color{blue}{\sin \theta} \cdot y + \color{blue}{\cos \theta} \cdot z \\ 1 \end{pmatrix}<br>$$</p><p>沿y轴旋转:</p><p>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; \color{red}0 &amp; \color{red}{\sin \theta} &amp; \color{red}0 \\ \color{green}0 &amp; \color{green}1 &amp; \color{green}0 &amp; \color{green}0 \\ - \color{blue}{\sin \theta} &amp; \color{blue}0 &amp; \color{blue}{\cos \theta} &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x + \color{red}{\sin \theta} \cdot z \\ y \\ - \color{blue}{\sin \theta} \cdot x + \color{blue}{\cos \theta} \cdot z \\ 1 \end{pmatrix}<br>$$<br>沿z轴旋转(<strong>这种情况就是上面推导的二维旋转</strong>)：<br>$$<br>\begin{bmatrix} \color{red}{\cos \theta} &amp; - \color{red}{\sin \theta} &amp; \color{red}0 &amp; \color{red}0 \\ \color{green}{\sin \theta} &amp; \color{green}{\cos \theta} &amp; \color{green}0 &amp; \color{green}0 \\ \color{blue}0 &amp; \color{blue}0 &amp; \color{blue}1 &amp; \color{blue}0 \\ \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}0 &amp; \color{purple}1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \color{red}{\cos \theta} \cdot x - \color{red}{\sin \theta} \cdot y  \\ \color{green}{\sin \theta} \cdot x + \color{green}{\cos \theta} \cdot y \\ z \\ 1 \end{pmatrix}<br>$$</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>矩阵变换在图形学应用非常之多。在图形学中，矩阵不仅仅可以用来表示一个点，一个位置，还可以表示颜色，光照等等。</p><blockquote><p>这一小节加深了矩阵是向量的函数的理解，用矩阵来改变一个向量。并且用了一个二维旋转的例子，利用三角函数与坐标之间的关系，先用用原向量和旋转角表示旋转之后的向量。进而通过最终向量，推断出变换矩阵是？ *？的向量，并把各个维度的的值解出来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——矩阵乘法的性质</title>
      <link href="/2019/10/09/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8/"/>
      <url>/2019/10/09/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵乘法的性质"><a href="#矩阵乘法的性质" class="headerlink" title="矩阵乘法的性质"></a>矩阵乘法的性质</h1><h2 id="遵守的运算规则"><a href="#遵守的运算规则" class="headerlink" title="遵守的运算规则"></a>遵守的运算规则</h2><p><strong>矩阵乘法是不遵守交换律的。</strong> $ A \cdot B \neq B \cdot A$</p><p>矩阵乘法遵守交换律，分配率。比如： </p><p>$(A \cdot B) \cdot C = A \cdot(B \cdot C) \ \ A \cdot (B + C) = A \cdot B + A \cdot C  \  \  (B + C) \cdot A = B \cdot A + C \cdot A<br>$</p><p>下面代表O是零矩阵</p><p>并且对于任意的$r<em>c$的矩阵，存在$c </em> x$的矩阵O，满足</p><p>$A\cdot O_{cx}= O_{rx}$</p><p>同理对任意$r<em>c$的矩阵A，存在$x</em>r$的矩阵O，满足</p><p>$O_{xr}*A = O_{xc}$</p><blockquote><p>注意矩阵是否可以相乘，满足有意义。</p></blockquote><p>$(A+B)^2 \neq A^2 +2AB +B^2$，因为矩阵乘法具有先后顺序，所以不能合并同类项。</p><h2 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h2><p>矩阵的幂： $A^k = \underbrace{A\cdot A \cdots A}_{k}$</p><p>为了让上面有意义，所以只有方阵才能有矩阵的幂的说法。</p><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p>转置用<code>T</code>表示。转置的含义就是行和列相互交换。</p><p>因为我们习惯于从行的角度来看矩阵，所以在进行运算的时候，我们经常需要转置操作。</p><p>比如现在两个矩阵</p><p>$$<br>A=\begin{bmatrix} 1.5 &amp; 0 \\ 0 &amp; 2 \end{bmatrix} \<br>P=\begin{bmatrix} 0 &amp; 0 \\ 4 &amp; 0 \\ 5 &amp;3 \end{bmatrix}<br>$$<br>这两个矩阵是不能直接相乘的（前一个的列数等于后一个的行数）。所以我们需要将P转置一下才能进行运算。比如这里的我们分别定义P的第一列是x轴，第二列是y轴。那么每一个行就是一个点。根据前面讲的运算规则：<br>$$<br>P^T = \begin{bmatrix} 0 &amp; 4 &amp; 5 \\ 0 &amp; 0 &amp;3 \end{bmatrix}<br>$$<br>那么$P^T$就能和$A$进行运算了</p><p>用数学公式表示转置的过程：$A=(a_{ij})$变成了$A^T = (a_{ji})$</p><blockquote><p>对于向量来说，向量有列向量和行向量，提到向量默认是列向量。比如在横版印刷的使用使用符号：$(3, 4)^T$。这样就写成了一列了</p></blockquote><h3 id="转置的性质"><a href="#转置的性质" class="headerlink" title="转置的性质"></a>转置的性质</h3><p>有如下性质(<strong>注意下最后一条性质</strong>)：<br>$$<br>(A^T)^T = A \\<br>(A + B)^T = A^T + B^T \\<br>(k \cdot A)^T = k \cdot A^T  \\<br>(A \cdot B)^T = B^T \cdot A^T<br>$$<br>可以用假设法来这名。</p><blockquote><p>矩阵的形状非常重要，可用来验证两个矩阵相乘是否合理。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode初级算法题解——数组</title>
      <link href="/2019/10/07/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
      <url>/2019/10/07/2019/10/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="对算法题印象"><a href="#对算法题印象" class="headerlink" title="对算法题印象"></a>对算法题印象</h1><p>对算法题的印象一直觉得就是智力题、脑力题。大部分的算法题对数学思维要求比较高。业界也流传着这样一段话：</p><ul><li>一流程序员靠数学，</li><li>二流靠算法，</li><li>三流靠逻辑，</li><li>四流靠<strong>SDK</strong>，</li><li>五流靠<strong>Google</strong>和<strong>StackOverFlow</strong>，</li><li>六流靠百度和<strong>CSDN</strong>。</li><li>低端的看高端的就是黑魔法！</li></ul><p>可见数学对程序员来讲是多么的重要，要想进入高手行列，对数学、算法的练习必不可少。</p><p>但是有时候对自己的智商也很怀疑适不适合去搞数学和算法的研究，所以自己对算法的学习仅仅停留在满足<strong>LeetCode</strong>、以及工作需要而已。<strong>高深的我也不会。</strong></p><blockquote><p>  务必相信学习任何知识，只要你头脑健全，那只是时间问题。编程能力就像任何其他技能一样，也是一个可以通过<code>刻意练习</code>大大提高的。</p></blockquote><h1 id="初级题——数组"><a href="#初级题——数组" class="headerlink" title="初级题——数组"></a>初级题——数组</h1><h2 id="1-删除排序数组中的重复项"><a href="#1-删除排序数组中的重复项" class="headerlink" title="1. 删除排序数组中的重复项"></a>1. 删除排序数组中的重复项</h2><h3 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>两个重要条件：</p><ul><li>有序</li><li>重复</li><li>不要使用额外空间</li><li>需要修改原数组</li><li><strong>不需要考虑数组中超出新长度后面的元素。——非常关键</strong></li></ul><p>由于题目限定了不能使用额外空间，那么只能遍历了。</p><h3 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h3><p>要删除重复元素，直觉就是肯定需要判断重复元素，以及删除操作。</p><p>判断重复元素我们可以对比相邻两个元素值，那么如何删除元素呢？</p><p>我们知道如果直接删除数组元素需要移动数组，移动的时间复杂度是$O(n)$。结合题目要求（<strong>不需要考虑数组中超出新长度后面的元素</strong>）。</p><blockquote><p>这句话就是关键，它的意思就是我们可以不管修改之后数组超出的部分。那么就不需要删除元素这么昂贵的操作了。只需要前面部分有意义即可。</p></blockquote><h3 id="核心思路（双指针）"><a href="#核心思路（双指针）" class="headerlink" title="核心思路（双指针）"></a>核心思路（双指针）</h3><p>用两个指针$i,j$分别指向数组的第一个元素、第二个元素。然后判断第一个元素和第二个元素是否相等。</p><ul><li>如果相等，则移动$j$，$i$依然不变，跳过该元素。</li><li>如果不相等，把$j$当前指向的元素的值复制到 $i+1$的位置，同时$i,j$均向后移动。</li><li>重复这个过程指导$j$到达数组尾部。</li></ul><p>根据这个思路最终代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> nums <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-买卖股票的最佳时间-II"><a href="#2-买卖股票的最佳时间-II" class="headerlink" title="2. 买卖股票的最佳时间 II"></a>2. 买卖股票的最佳时间 II</h2><h3 id="原题-1"><a href="#原题-1" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>相当于开启了上帝视角，提前知道了股票的价格走势，然后要你算一算你最多能赚多少钱。题目有两个重要点：</p><ol><li>可以多次买卖一支股票——<strong>这个条件非常重要，含义就是我们可以同一天先卖出后买入。</strong></li><li>不能同时参与多笔交易。也就是在买新股的时候，手里必须没有股票。</li><li><strong>结合上面两个条件，在连续上涨的情况下，比如在[1, 2, 3]这种情况，我们可以第一天买，第二天卖，然后在第二天同样买入，然后在第三天卖出</strong>。也就是 <strong>2-1 + 3-2 = 3-1</strong>，这个思路是写后面代码的关键。</li></ol><blockquote><p>归纳一下股票买卖策略：</p><ul><li><p>单独交易日： 设今天价格 $p_1$明天价格 $p_2$，则今天买入、明天卖出可赚取金额 $p_2 - p_1$（负值代表亏损）。</p></li><li><p>连续上涨交易日： 设此上涨交易日股票价格分别为 $p_1, p_2, … , p_n $。则第一天买最后一天卖收益最大，即 $p_n - p_1 $等价于每天都买卖，即 $p_n - p_1=(p_2 - p_1)+(p_3 - p_2)+…+(p_n - p_{n-1})$</p></li><li><p>连续下降交易日： 则不买卖收益最大，即不会亏钱。</p></li></ul><p>算法流程：</p><p>遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。</p><p>设 tmp 为第$ i-1 $日买入与第 i 日卖出赚取的利润，即$ tmp = prices[i] - prices[i - 1] $；<br>当该天利润为正$ tmp &gt; 0$，则将利润加入总利润 profit；当利润为 0 或为负，则直接跳过；<br>遍历完成后，返回总利润 profit。</p><p>复杂度分析：</p><p>时间复杂度 $O(n)$ ： 只需遍历一次price；<br>空间复杂度 $O(1))$ ： 变量使用常数额外空间。</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 连续上涨交易日，比如考虑[1,2,3], 最大利润 = 3 - 1,</span>    <span class="token comment" spellcheck="true"># 实际上等价于(2 - 1) + (3 - 2)(违背卖出2再买入2的规则), 但这不影响最终的结果</span>    <span class="token comment" spellcheck="true"># 所以, 最大利润 = 每次升序的差值</span>    profit <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>         <span class="token keyword">if</span> tmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span> profit <span class="token operator">+=</span> tmp    <span class="token keyword">return</span> profit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这道题核心就是：由于可以在同一天卖出和买入，这相当于没有卖出，连续买。因此只要比对当前与前一天的价格（即这两天能获得的利润），如果是上升的就加上，如果是下降的则取0，最后所有的连续日利润的和就是最大利润。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        max_profit <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            max_profit <span class="token operator">+=</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> max_profit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-旋转数组"><a href="#3-旋转数组" class="headerlink" title="3. 旋转数组"></a>3. 旋转数组</h2><h3 id="原题-2"><a href="#原题-2" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。示例 1:输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]示例 2:输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]说明:尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>k是非负数并且代表移动的次数，首先需要对k处理。因为当$k &gt; n$的时候，相当于循环了一圈，这里我们可以直接通过<code>k=k%n</code>，取余操作得到最终需要移动的次数。</p><h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h3><p>最直观的思路就是一个一个移动。用一个变量记录最后一个元素（相当于挖一个坑），然后依次从后往前，<code>nums[j] = nums[j - 1]</code>。移动完之后把挖出来的值放到第一个位置即可。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种暴力破解的时间复杂度是$O(k*n)$，空间复杂度$O(1)$。满足题目的要求。</p><p>除了这种从后往前的移动，其实也可以从前往后的方式。思路依次把前一个的值赋给后面一个元素。思路和上面的大同小异，在每一次的移动中都改变了pre的值。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#取出前一个，分别与后面的交换</span>            pre <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                pre<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面这两种在提交LeetCode的时候会超出时间限制。</p></blockquote><h3 id="插入法"><a href="#插入法" class="headerlink" title="插入法"></a>插入法</h3><p>可以把整个过程想象为一个数组不断的取出最后一个元素，然后把这个元素插入的起始位置的过程。而循环的次数就是k的值。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> n        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拼接法"><a href="#拼接法" class="headerlink" title="拼接法"></a>拼接法</h3><p>直接想象成为把最后的k个元素拼接到数组的头部。这个思路和插入法有点类似，区别在于插入法师一个一个的头部添加，而拼接法是一次性全部接上去。</p><pre class="line-numbers language-python"><code class="language-python">     <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>            n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>            k <span class="token operator">%=</span> n            nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token operator">-</span>k<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意这里不用写<code>nums = nums[-k:] + nums[:-k]</code>，因为这样nums的地址就变了。</p></blockquote><h3 id="翻转法"><a href="#翻转法" class="headerlink" title="翻转法"></a>翻转法</h3><p>这种思路需要总结下规律比如[1, 2, 3, 4]往右移动2位，结果是[3, 4, 1, 2]。可以看做由下面几个翻转步骤完成：</p><ul><li>[1, 2, 3, 4]翻转为[4, 3, 2, 1]</li><li>以第二个元素为分割，分别翻转前后部分得到[3, 4 , 1, 2]</li></ul><p>最终得到了结果。<strong>在Python中数组的翻转可以直接用<code>::</code>实现非常方便。</strong></p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        k <span class="token operator">%=</span> n        nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-存在重复"><a href="#4-存在重复" class="headerlink" title="4. 存在重复"></a>4. 存在重复</h2><h3 id="原题-3"><a href="#原题-3" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。示例 1:输入: [1,2,3,1]输出: true示例 2:输入: [1,2,3,4]输出: false示例 3:输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这道题非常简单。很直观的就会想到如下几种方式：</p><ul><li>先排序，然后判断是否重复</li><li>用哈希表记录出现的，然后利用哈希表的特性，快速查找元素是否出现过</li></ul><h3 id="先排序再挨个比较"><a href="#先排序再挨个比较" class="headerlink" title="先排序再挨个比较"></a>先排序再挨个比较</h3><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: bool        """</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                flag <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> flag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码很简单，不用多讲。</p><blockquote><p>排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。</p></blockquote><p>时间复杂度：$O(nlogn)$——取决于排序的时间复杂度，如果用快排，那么就是$O(nlogn)$</p><p>空间复杂度：$O(1)$</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表具有链表与数组的特点，快速查找，快速插入。变量元素，如果元素没有出现在哈希表中，则说明没重复，如果存在了说明有重复。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: bool        """</span>        hashtable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> hashtable<span class="token punctuation">.</span>get<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hashtable<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 对应python而言，如果要判断一个元素是否已经存在，可以值直接用数组即可，数组提供了是否包含元素的方法。但是我在测试的时候，直接用数组的<code>contain</code>会导致超时，虽然测试代码能过</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> tmp<span class="token punctuation">.</span>__contains__<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#这句话可以用in来简化 nums[i] in tmp</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                tmp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了list。python还可以用set。代码就不写了原理是一样的，用set是可以通过的。</p><h3 id="一行代码搞定"><a href="#一行代码搞定" class="headerlink" title="一行代码搞定"></a>一行代码搞定</h3><p>我们可以利用数据结构set的特性，python中可以把一个list转化为set。而set的特性就是它不包含重复元素。<strong>所以我们可以直接判断转换后set和之前list的长度是否变化就知道是否有重复元素。</strong></p><p>最终一行代码解决</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">!=</span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-只出现一次的数字"><a href="#5-只出现一次的数字" class="headerlink" title="5. 只出现一次的数字"></a>5. 只出现一次的数字</h2><h3 id="原题-4"><a href="#原题-4" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4</code></pre><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>抓住除了某个元素出现一次外，其余每个元素出现过两次这个条件。比较直观的想法就是用一个哈希表记录一下每个元素出现的次数，遍历完后找出次数为1的元素即可。<strong>这样的时间复杂度虽然是$O(n)$，但是后面提出了更高的要求，不使用额外的空间。</strong></p><p>不使用额外的空间，就需要进一步分析出现一次和出现两次究竟可以从哪些角度来判断不同。<strong>如果能想到位运算，那就成功了一半了。</strong></p><p>我们知道两个位运算中的异或定义就是：<strong>相同为0不同为1。</strong>那么出现了两次的数字，用异或来操作就会化解为0，而出现一次的数字最终会保留下来。所以核心点就是分别对所有数字进行异或，然后保留得数，最终这个值就是为一次的数字。</p><h3 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h3><p>这种解法思路简单</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        hashTable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> hashTable<span class="token punctuation">.</span>get<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                hashTable<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hashTable<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token keyword">in</span> hashTable<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> key        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异或解法"><a href="#异或解法" class="headerlink" title="异或解法"></a>异或解法</h3><p>这种解法就是代码非常简单，但是比较难想到。关键点就是如何把出现两次与出现一次化解到异或关系上</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        result <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p>做完之后对比了其他人的解法，有几个比较有意思的这里简单介绍一下。</p><h3 id="类栈解法"><a href="#类栈解法" class="headerlink" title="类栈解法"></a>类栈解法</h3><p>这种解法重复利用了出现两次和一次的关系。用一个数组模拟栈，新遇到的元素就加到这个数组里面，如过已经出现了这个元素，则把原来的元素一处这个栈。遍历完之后再数组里面存在的元素就是出现次数为1的元素。</p><p>代码如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        no_duplicate_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">not</span> <span class="token keyword">in</span> no_duplicate_list<span class="token punctuation">:</span>                no_duplicate_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                no_duplicate_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> no_duplicate_list<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n^2)$。我们遍历<code>nums</code> 花费 $O(n)$ 的时间。我们还要在列表中遍历判断是否存在这个数字，花费 $O(n) $的时间，所以总循环时 $O(n^2)$。<br>空间复杂度：$O(n)$ 。我们需要一个大小为 n的列表保存所有的 <code>nums</code> 中元素。</p><p>紧接着这个思路，用数组的方式来解决这个问题最大问题是查找的时间复杂度，我们可以引入哈希表快速查找的特性，避免每次查找元素需要的 $O(n)$时间。</p><h3 id="加法求和解法"><a href="#加法求和解法" class="headerlink" title="加法求和解法"></a>加法求和解法</h3><p>这种解法在某些编程语言会出现溢出的问题。利用放大元素，然后做减法。简单来讲就是一个数学公式的变形。</p><p>$$<br>2*(a+b+c) - (a + a + b + b + c +c) = 0<br>$$</p><p>展开把其次一个$c$放到右边</p><p>$$<br>2*(a+b+c) - (a + a + b + b + c) = c<br>$$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> sum<span class="token punctuation">(</span>set<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-两个数组的交集"><a href="#6-两个数组的交集" class="headerlink" title="6. 两个数组的交集"></a>6. 两个数组的交集</h2><h3 id="原题-5"><a href="#原题-5" class="headerlink" title="原题"></a>原题</h3><pre><code>给定两个数组，编写一个函数来计算它们的交集。示例 1:输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]示例 2:输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]说明：输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。进阶:如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先遇到数组相关的问题，第一反应先查看数组是否有序，如果无序，尽量让数组有序，有序之后进行其他分析就简单很多。</p><p>先来思考一下如果不对数组排序如何进行处理。</p><p>比较难处理的就是重复元素。数组里面的元素可以重复，重复元素出现在两个数组中出现了的不同次数会有不同的交集，最终是以元素出现次数最少一方为并集。</p><blockquote><p><strong>应该先对什么是交集搞清楚——找出两个数组的交集元素，同时应与两个数组中出现的次数一致。</strong></p></blockquote><p>我们可以分别用哈希表h1，h2记录nums1，nums2数组每一个元素出现的次数。然后判断h1的key是否在h2中出现过。如果出现过，则比较这两个key出现的次数。取小的次数为交集，最后构成一个新的数组，把key添加之前得到的最小次数即可。</p><p>另一种就是先排序，用两个指针分别扫描nums1,nums2。从第一个元素较大的数组开始，一直找到有相同元素的位置。</p><p>若$nums1(i) == nums2(i)$，则两个指针分别右移i += 1; j +=1。这个元素就是交集之一。<br>若$nums1(a) &lt; nums2(b)$，则 i += 1<br>若$nums1(a) &gt; nums2(b)$，则 j += 1</p><h3 id="两个哈希表解法"><a href="#两个哈希表解法" class="headerlink" title="两个哈希表解法"></a>两个哈希表解法</h3><p>哈希表解法的核心就是记录元素出现的次数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        """</span>        h1<span class="token punctuation">,</span> h2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        nums3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> h1<span class="token punctuation">.</span>get<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                h1<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                h1<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> h2<span class="token punctuation">.</span>get<span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                h2<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                h2<span class="token punctuation">[</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> h1<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> key <span class="token keyword">in</span> h2<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                times <span class="token operator">=</span> min<span class="token punctuation">(</span>h2<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">:</span>                    nums3<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> nums3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码可以稍微优化一下，可以不开辟两个哈希表，只用一个就可以。</p><blockquote><p><strong>需要用到小技巧，从h1我们知道在并集中每个元素最多出现的次数，那么就可以利用这一点。遍历num2的元素，如果出现过过一次就减去h1中一次次数。如果为0就可以直接删掉了，相当于h1保存的就是所有并集的元素。</strong></p></blockquote><p>优化过的代码如下：</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        """</span>        h1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        nums3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> h1<span class="token punctuation">.</span>get<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                h1<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                h1<span class="token punctuation">[</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            key <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> key <span class="token keyword">in</span> h1<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                nums3<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                value <span class="token operator">=</span> h1<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>                <span class="token keyword">if</span> value <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                    newValue <span class="token operator">=</span> value <span class="token operator">-</span> <span class="token number">1</span>                    h1<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newValue                <span class="token keyword">else</span><span class="token punctuation">:</span>                    h1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> nums3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h3><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        """</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums2<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        nums3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums3<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> nums3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种解法时间复杂度跟两个数组的长度相关，为$O(n+m)$</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>这种方式和第一中优化过得哈希表解法类似。需要用到删除操作，将元素加过一次就删除掉，保证不会重复添加。</p><blockquote><p>遍历第一个数组，然后在第二个数组查找是否有当前元素。如果有，把当前元素添加进返回数组。然后把该元素从第二个数组中删除，防止重复添加。</p></blockquote><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        """</span>        nums3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> nums2<span class="token punctuation">:</span>                nums3<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                nums2<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种暴力解法时间复杂度很高达到了$O(n^2)$。外层循环，内层查找。好在这种思路比较简单！</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>最开始没有想到可以利用删除元素的方式解决重复元素的问题，所以最开始用两个哈希表来保存两个数组元素出现的次数，然后分别笔记两个数组元素出现的次数，选择次数少的作为并集。</p><p>后来想到可以利用删除的方式处理重复元素的问题，这样就不用哈希表对nums2保存每个元素出现的次数了。可以判断通过nums2的元素是否在nums1中存在，如果存在就说明是该元素是在并集中，<strong>添加到返回数组之后然后从数组nums2中删除</strong>。</p><h2 id="7-加一"><a href="#7-加一" class="headerlink" title="7. 加一"></a>7. 加一</h2><h3 id="原题-6"><a href="#原题-6" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。示例 1:输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。示例 2:输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。</code></pre><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>注意两个条件</p><ul><li>整数</li><li>非空数组</li><li>非负整数</li><li>零</li></ul><p>这道题需要考虑的核心就是要处理进位的情况。总体来讲有如下情况</p><ul><li>末位无进位，则末位加一即可，因为末位无进位，前面也不可能产生进位，比如 45 =&gt; 46</li><li>末位有进位，在中间位置进位停止，则需要找到进位的停止的位置，即为当前位后为 0，则前一位加 1，直到不为 0 为止，比如 499 =&gt; 500</li><li>末位有进位，并且一直进位到最前方导致结果多出一位，对于这种情况，需要在第 2 种情况遍历结束的基础上，进行单独处理，比如 999 =&gt; 1000</li></ul><p>除了通过10来判断是否会进位之外，<strong>因为题目仅仅是通过加1，所以我们直接通过数字9判断是否就位就可以了。</strong></p><h3 id="10取余判断进位解法"><a href="#10取余判断进位解法" class="headerlink" title="10取余判断进位解法"></a>10取余判断进位解法</h3><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>digits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> <span class="token number">10</span>            <span class="token keyword">if</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#没有进位直接返回，如果有进位，第二次循环的时候就会加上1</span>                <span class="token keyword">return</span> digits        digits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        digits<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> digits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9判断进位解法"><a href="#9判断进位解法" class="headerlink" title="9判断进位解法"></a>9判断进位解法</h3><p>和用取余10判断进位类似，因为对10取余，当前就直接问赋值为0了。但是用9来判断的时候没有自动赋值为0。所以需要手动给当前位设置为0。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>digits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">9</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#没有进位直接返回</span>                digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">return</span> digits            <span class="token comment" spellcheck="true">#有进位,则手动把末尾设置为0</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        digits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        digits<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> digits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-移动零"><a href="#8-移动零" class="headerlink" title="8. 移动零"></a>8. 移动零</h2><h3 id="原题-7"><a href="#原题-7" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例:输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。</code></pre><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>题目要求保持非零元素相对顺序，而且必须在原数组上操作。这样的话就只能对原数组下手了。</p><p>为了在移动元素的时候不影响当前后续的元素，所以只能改变当前位置的值，我们可以用两个指针，一个指针用来指非零当前的位置，一个指针用来指向当前遍历到什么位置。当遍历完之后，用数组总长度减去当前指向非零位置的指针，就得到最后需要补零的个数，最后把数组后面具体多少位置位0即可。</p><h3 id="双指针解法-1"><a href="#双指针解法-1" class="headerlink" title="双指针解法"></a>双指针解法</h3><p>注意为什么不能把0移除，因为移除之后后面的元素index就变了。为了保证后续元素index不变，用赋值的方式把所有的非零元素移动到数组前面，剩下的就是零元素了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: None Do not return anything, modify nums in-place instead.        """</span>        p1 <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                p1 <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>p1<span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式可以优化，<strong>我们可以在直接p1和i不相等的时候同时修改nums[i] 的值以及把当前值移到前面</strong>。这样就不用循环补0了。代码如下</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        p1 <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">!=</span> p1<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                p1 <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="由后往前删除添加解法"><a href="#由后往前删除添加解法" class="headerlink" title="由后往前删除添加解法"></a>由后往前删除添加解法</h3><p> 不能改变元素的index是核心原则，前面讲的双指针解法都是从前往后扫描，然后依次去覆盖掉非0的值。这种解法稍微有点取巧，从后往前，每次把非零元素放在道歉元素末尾，因为会把当前的元素删除掉，那么就保证了不会影响还未遍历元素的索引，最终就把所有的0移动了最左边。<strong>遍历完之后，因为我们是从后向前走，那么添加的运算顺序就是从右向左，最后需要来一次翻转就达到了目的。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>     nums<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-两数之和"><a href="#9-两数之和" class="headerlink" title="9. 两数之和"></a>9. 两数之和</h2><h3 id="原题-8"><a href="#原题-8" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>两数之和是LeetCode早期非常经典的题，解法有很多。常见的有哈希表解法，暴力解法</p><p>要解决的为题就是查找，用哈希表可以快速查找。</p><h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>简单，先找到其中一个值，然后再去遍历找到第二个值。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">two_sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> m <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">while</span> j <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>                <span class="token keyword">if</span> target <span class="token operator">==</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    j <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表解法-1"><a href="#哈希表解法-1" class="headerlink" title="哈希表解法"></a>哈希表解法</h3><p>上面的暴力破解法耗时就耗在查找的部分，我们可以利用哈希表优化查找，用空间换时间</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> m <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            dict<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">for</span> i<span class="token punctuation">,</span> m <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target <span class="token operator">-</span> m<span class="token punctuation">)</span>            <span class="token keyword">if</span> j <span class="token keyword">is</span> <span class="token operator">not</span> None <span class="token operator">and</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表优化解法"><a href="#哈希表优化解法" class="headerlink" title="哈希表优化解法"></a>哈希表优化解法</h3><p>上面用了两个循环，第一个是用来建立哈希表，第二个用来查找。我们可以将两个过程写在一起，如果没有查找到就构建哈希表，查找到了就直接返回。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">two_sum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> m <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target <span class="token operator">-</span> m<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target <span class="token operator">-</span> m<span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span>            dict<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-有效的数独"><a href="#10-有效的数独" class="headerlink" title="10. 有效的数独"></a>10. 有效的数独</h2><h3 id="原题-9"><a href="#原题-9" class="headerlink" title="原题"></a>原题</h3><pre><code>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</code></pre><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><pre><code>上图是一个部分填充的有效的数独。数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。示例 1:输入:[  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true示例 2:输入:[  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。说明:一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。给定数独永远是 9x9 形式的。</code></pre><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>整体分为两种思路，一种是分别按照行、列、<code>3x3</code>的部分判断，这种需要每种情况都大循环也就是三次大循环。还有一种就是在一次循环中判断，每一个点都扫描一次，一次判断这个点的行，列，<code>3x3</code>的情况。</p><p>一共有9行，9列，9个小的<code>3x3</code>。</p><p>3x3这个区域可以用<code>for</code>循环搞定</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#遍历格子</span>                 <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>r <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> r <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>c <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> c <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                         <span class="token comment" spellcheck="true">#对应一个小格子的值</span>                        value <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如何判断数字是否已经出现过了呢。<strong>可以用哈希表，当然也可以用一个数组。二者是一样的。</strong></li></ul><p>如果只用一次循环，就需要对当前点从行列以及子数独来判断。</p><ul><li>判断子数独可以通过 <code>box_index = (row / 3) * 3 + columns / 3</code>，其中 <code>/</code> 是整数除法。</li></ul><h3 id="多次循环解法"><a href="#多次循环解法" class="headerlink" title="多次循环解法"></a>多次循环解法</h3><p>看起来代码比较笨重，但是思路很清晰。有很多可以优化的地方，比如多个循环可以用一个循环解决。判断是否存在可以用数组保存结果等。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#第i行</span>            h1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#第j列</span>                value <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">if</span> h1<span class="token punctuation">.</span>get<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                    h1<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#第j列</span>            h1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#第i行</span>                value <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">if</span> h1<span class="token punctuation">.</span>get<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                    h1<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> c  <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true">#遍历子数独</span>                h1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>r <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> r <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>c <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> c <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true">#第i行dij列的格子</span>                        value <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                        <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                            <span class="token keyword">continue</span>                        <span class="token keyword">if</span> h1<span class="token punctuation">.</span>get<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                            h1<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                        <span class="token keyword">else</span><span class="token punctuation">:</span>                            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一次循环解法"><a href="#一次循环解法" class="headerlink" title="一次循环解法"></a>一次循环解法</h3><p>这种解法只用一次大循环，一个一个遍历每一个格子。然后分别从行、列、所属子数独的去验证是否正确。</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#为每一行，每一列，每个子数独创建哈希表，保存是否出现过</span>        rowh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        columh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        childh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                value <span class="token operator">=</span>  board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> value <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true">#行</span>                    rowh<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> rowh<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token comment" spellcheck="true">#列</span>                    columh<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> columh<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token comment" spellcheck="true">#子数独</span>                    child_index <span class="token operator">=</span> i <span class="token operator">//</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> j <span class="token operator">//</span> <span class="token number">3</span>                    childh<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span>childh<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>                    <span class="token keyword">if</span> rowh<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">or</span> columh<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">or</span> childh<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>网上看到一个非常牛逼的方法来保存状态。上面两种方式都是用哈希表来保存是否出现过的状态。除了哈希表还可以用数组，当然数组可以用二维数组实现类似的功能。下面要介绍的这种方法很巧妙，用了移位的骚操作。让人耳目一新。</p><p>首先定义三个数组</p><pre class="line-numbers language-python"><code class="language-python">         rows <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        colums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        childs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p> 这三个数组里报错的是2进制的9个位数，如果是第一个数是1，那么统计标志就是0000000010(二进制 1左移1位)，<strong>如果第二个数是3那么统计标识变为0000001010(二进制 1左移3位再加上原来的)</strong>，每次判断有没有重复就右移相应位数之后整除2即可。</p><p>比如一串数：1，3，1</p><p>起始值： 0000 0001</p><ul><li><p>首先是1，代表着左移1位，那么就是0000 0010 </p></li><li><p>遇到3，先判断是否有重复，通过还原右移3位得到0000 0000 如果重复，最后一位是1，则除以就知道最后一个是不是1了（左移是2的倍数）。这里不等于1，则继续以 0000 0001 的基础上左移3 位得到0000 1000并且加上之前的0000 0010 。得到0000 1010</p></li><li><p>下一个是1，则先判断是否重复，把0000 1010右移1位得到0000 0101。除2等于1，则说明重复了。</p></li></ul><p>这种方式巧妙的先左移，然后右移还原来判断是否出现过。只要出现过该，那么对应位数上的值肯定是1。通过右移判断是否重复，通过左移用来赋值保存当前状态。</p></blockquote><p>对应代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        rows <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        colums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        childs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                value <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> value <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    move_count <span class="token operator">=</span> ord<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">48</span>                    <span class="token comment" spellcheck="true">#行</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>></span> move_count<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true">#从0000 0001开始移动</span>                        rows<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> move_count                    <span class="token comment" spellcheck="true">#列</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>colums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>></span> move_count<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true"># 从0000 0001开始移动</span>                        colums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> move_count                    <span class="token comment" spellcheck="true">#子数独</span>                    child_index <span class="token operator">=</span> i <span class="token operator">//</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> j <span class="token operator">//</span> <span class="token number">3</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>childs<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span> <span class="token operator">>></span> move_count<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                        <span class="token keyword">return</span> <span class="token boolean">False</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true"># 从0000 0001开始移动</span>                        childs<span class="token punctuation">[</span>child_index<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> move_count        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-旋转图像"><a href="#11-旋转图像" class="headerlink" title="11. 旋转图像"></a>11. 旋转图像</h2><h3 id="原题-10"><a href="#原题-10" class="headerlink" title="原题"></a>原题</h3><pre><code>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。示例 1:给定 matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],原地旋转输入矩阵，使其变为:[  [7,4,1],  [8,5,2],  [9,6,3]]示例 2:给定 matrix =[  [ 5, 1, 9,11],  [ 2, 4, 8,10],  [13, 3, 6, 7],  [15,14,12,16]], 原地旋转输入矩阵，使其变为:[  [15,13, 2, 5],  [14, 3, 4, 1],  [12, 6, 8, 9],  [16, 7,10,11]]</code></pre><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>核心就是找对应坐标的规律。</p><p>可以把旋转分解为两个步骤。</p><ol><li>沿中轴线上下翻转</li><li>沿对角线翻转（左上右下）翻转</li></ol><p>剩下就是找坐标对应关系</p><p>中轴线翻转的对一个关系：<code>(i,j) = ((n / 2 - i) * 2 + i,j) = (n - i - 1,j)</code></p><p>左上对角线翻转对应关系：<code>(i,j) = (j, i)</code></p><p>还需要注意的就是，翻转只需要翻转一般即可，并不需要遍历完。因为是交换，交换了一般，全部元素就已经变了。</p><p>除此之外还有一种方式，把旋转划分各个小矩阵的旋转。类似于下图：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g82gek3qgpj305003u749.jpg" alt="1571387537571.png"></p><p>找到对应坐标的关系即可，分别对应的是四个点，也就是四个点之间的交换</p><ul><li><p>第一个点：<code>(0, 0)——》（0, 3）——》(3, 3)——》(3, 0)——》(0, 0)</code></p></li><li><p>第二个点：<code>(0, 1)——》（1, 3）——》(3, 2)——》(2, 0)——》(0, 1)</code></p></li><li><p>第三个点：<code>(0, 2)——》（2, 3）——》(3, 1)——》(1, 0)——》(0, 2)</code></p></li><li><p>第四个点：<code>(0, 3)——》（3, 3）——》(3, 0)——》(0, 0)——》(0, 3)</code></p></li></ul><p>关系：<code>(i,j) ——》 (j, n-i-1)——》 (n-i-1, n-j-1)——》 (n -j-1, i)</code></p><p>对这四个数分别进行两两交换即可</p><h3 id="翻转解法"><a href="#翻转解法" class="headerlink" title="翻转解法"></a>翻转解法</h3><p>核心就是找到坐标对应关系</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        <span class="token comment" spellcheck="true">#中轴线翻转坐标对应关系 (i,j) = ((n / 2 - i) * 2 + i,j) = (n - i - 1,j)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> n <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#左上对角线翻转 i,j = j, i (矩阵转置)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>稍微优化一下，<code>if</code>完全可以去掉，直接写在for循环里面。代码看起来更加简洁</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        <span class="token comment" spellcheck="true">#中轴线翻转坐标对应关系 (i,j) = ((n / 2 - i) * 2 + i,j) = (n - i - 1,j)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#左上对角线翻转 i,j = j, i (矩阵转置)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四点矩阵旋转解法"><a href="#四点矩阵旋转解法" class="headerlink" title="四点矩阵旋转解法"></a>四点矩阵旋转解法</h3><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Do not return anything, modify matrix in-place instead.        """</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>         <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>n<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> \                matrix<span class="token punctuation">[</span>n<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LeetCode初级题数组篇到此结束。一共算来有是一道题，通过这十一道题我们可以总结出一些经验。</p><h2 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h2><p>这是一道题中很多时候都用到了哈希表，哈希表具有数组和链表的特性，查找、插入都很快。这就为我们提供了一个非常有利的工具。</p><p>哈希表是<code>key-value</code>的形式，这种形式如果只是单纯的处理数字之间映射关系，还可以直接用数组。因为数组有下标，这里的下标就可以看做哈希表中的<code>key</code>，数组里面保存的值就是<code>value</code>。</p><p>除此之外，如果保存的状态仅仅只有True,False。那么还可以用到二进制相关的运算。一个8位的二进制数就可以表示8种True，False的组合。</p><p>如果是字符类的，因为ascii一共有256个字符。那么就可以定义个一个长度为256的数组替代哈希表。而数组的值就可以表示这个字符出现的次数或者其他含义。</p><h2 id="看清题目，直奔结果"><a href="#看清题目，直奔结果" class="headerlink" title="看清题目，直奔结果"></a>看清题目，直奔结果</h2><p>在做某些题的时候，我们可能会看到不是很符合常规的一些题。比如《删除排序数组的重复项》这道题，直观感受就是处理完之后数组元素应该是一个完完全全没有多余元素，没有重复元素的数组。但是题目并不是这样要求的，仅仅是做了如下的限制：</p><pre><code>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>所以不用管超出之后的部分。</p><p>除了这道题，还有一些题比如直接返回True, False。中间过程不用太关系，只要得到这个结果即可。</p><p>再举一个例子《买卖股票的最佳时间 II》这道题并不要求给出具体买卖的方案，而只是要求返回一个最大值结果。所以不用具体的每一天怎么去操作。</p><h2 id="移动，交换"><a href="#移动，交换" class="headerlink" title="移动，交换"></a>移动，交换</h2><p>编程的世界说得简单点就是执行流程（分支，循环）加上赋值语句组成的。而在解决算法题的过程中，用的最多的就是赋值（<code>=</code>），因为赋值才能实现移动和交互。而解决算法题就是在有限的空间里面去移动，交换数据。</p><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>拿到题目的时候，有些题目让人不知道从何下手。这个时候善于去发现边界条件以及揣测题目的考点。</p><p>这分析题目最好的就是根据题目提供的例子还找规律，其实学习也就是根据大量例子然后找到规律的过程。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——矩阵高级运算</title>
      <link href="/2019/10/05/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97/"/>
      <url>/2019/10/05/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵与向量的乘法"><a href="#矩阵与向量的乘法" class="headerlink" title="矩阵与向量的乘法"></a>矩阵与向量的乘法</h1><p>上一篇中我们由简单的经济学系统最终得出了下面的线性方程组。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhjmybj30d2062757.jpg" alt></p><p>我们把等式左边的系数抽出来作为一个矩阵，等式右边作为一个列向量。最终得到了下面这个矩阵和列向量。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhnlb2j30js05mwf3.jpg" alt></p><p>现在我们把未知数x排成列向量。<strong>注意：在线性代数中多数情况，提到的向量都是列向量。</strong></p><p>最终变成了下图：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no89z8fcj30ja05udgn.jpg" alt></p><blockquote><p>我们把最开始的一个线性方程组转换成了一个系数矩阵去乘以一个未知数组成的列向量最终等于右边的结果列向量。</p><p>我们可以用符号来表示：$A \cdot \bar{x} = \bar{b}$</p></blockquote><p>接下来我们可以用向量的方式把最上面的线性方程组左边表示出来：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a09onj30q905z758.jpg" alt="1570278486912"></p><p>所以我们可以总结出矩阵与向量相乘的规律就是：矩阵的每一行都乘该向量。因为矩阵的每一行都是一个行向量，<strong>最终也就转换成了向量与向量的乘法</strong>。</p><p>之前我们讲过向量之间的乘法，<strong>前提是两个向量的元素个数必须是一样的</strong>，<strong>所以这里就矩阵的行数一定要和向量的列数相同，否则就是没有意义的</strong>。其次，向量之间的点乘就是两个向量的每个元素之间相乘，并且之前还结合了几何（投影与分解）性质讲解，如果忘了可以去看看前面的内容。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a4jl6j30nu05eaa7.jpg" alt="1570278566408"></p><blockquote><p>我们可以总结出：</p><ol><li>矩阵A的列向量必须和向量u的元素个数一样。</li><li>矩阵A的行数没有限制。</li><li>矩阵A的行数决定了结果向量的行数。</li></ol></blockquote><p>最终可以简化为：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a04okj30ab062dg2.jpg" alt="1570279122212"></p><h2 id="回顾向量之间的点乘"><a href="#回顾向量之间的点乘" class="headerlink" title="回顾向量之间的点乘"></a>回顾向量之间的点乘</h2><p>当矩阵A的行数为1的时候，那么这个时候矩阵A就成了一个向量。同样满足上面推到出来的性质。</p><blockquote><p>所以我们知道向量其实是一个特殊的矩阵，特殊在于这个矩阵只有一行。</p></blockquote><h2 id="换一个角度思考"><a href="#换一个角度思考" class="headerlink" title="换一个角度思考"></a>换一个角度思考</h2><p>对于一个矩阵来说，比如$m * n $的矩阵 ，那么乘以一个n个元素的向量，最终得到的结果向量就是n个元素的向量。</p><p>用公式表示就是：<br>$$<br>T \cdot \bar{a} = \bar{b}<br>$$</p><blockquote><p> 我们可以换另外一个角度来理解这个乘法，相当于用某种方式，把向量a转换为向量b。这个转换的方法就是由矩阵T决定的。</p><p><strong>所以可以把矩阵理解为向量的函数。</strong>高中数学中的函数定义就是把数转换为另一个数。函数视角来理解矩阵非常重要，尤其是后面高级线性代数，在空间变换中尤为重要。</p></blockquote><h1 id="矩阵与矩阵之间的乘法"><a href="#矩阵与矩阵之间的乘法" class="headerlink" title="矩阵与矩阵之间的乘法"></a>矩阵与矩阵之间的乘法</h1><p>之前我们讲过一个例子，在二维坐标系中将一个三角形括扩大两倍</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhhtvgj30am07xaao.jpg" alt><br>$$<br>P=\begin{bmatrix} 0 &amp; 0 \\ 4 &amp; 0 \\ 5 &amp;3 \end{bmatrix}<br>$$</p><p>使用的方法就是用一个标量2来乘以矩阵。</p><p>$$<br>2 \cdot P=\begin{bmatrix} 0 &amp; 0 \\ 8 &amp; 0 \\ 10 &amp; 6 \end{bmatrix}<br>$$</p><p>假设现在需要横坐标扩大1.5倍，纵坐标扩大两倍。</p><blockquote><p>这就是一个需要将向量转换为另一个向量的场景，<strong>根据上面讲的矩阵就是用来转换、向量的。所以我们就需要求这样一个矩阵。</strong></p><p>用数学方式表示就是：<br>$$<br>T * \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} 1.5x \\ 2y\end{bmatrix}<br>$$</p></blockquote><p>我们最终要求的就是这个矩阵T。</p><p>根据之前总结的矩阵与向量乘法的运算规律。很容易知道T是2 * 2 的矩阵（1. 矩阵列数必须等于向量行数 2 举证行数等于结果矩阵的行数）。</p><p>我们就可以写出一个等式：<br>$$<br>\begin{bmatrix} a &amp; b \\ c &amp; d   \end{bmatrix} * \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix}ax + by \\ cx +dy\end{bmatrix}<br>$$<br>根据等式我们很容易知道b,c都是为0。然后建立一个二次方程组，很容易求得$ a = 1.5 c = 2$</p><p>最终T向量就是：<br>$$<br>T = \begin{bmatrix} 1.5 &amp; 0 \\ 0 &amp; 2 \end{bmatrix}<br>$$<br>现在有一个问题，现在我们完成了一个向量的缩放，<strong>能不能批量的完成对三角形的缩放呢，虽然可以对每一个点都进行一次单独的矩阵乘法，但是有没有对所有的点都进行一次缩放的方法呢？</strong></p><blockquote><p>我们只需要把所有的点坐标组合为一个矩阵就可以了。</p></blockquote><p>此时我们组合的矩阵就应该是：<br>$$<br>P=\begin{bmatrix} 0 &amp; 4 &amp; 5 \\  0 &amp; 0 &amp;3\end{bmatrix}<br>$$<br>之前我们对一个点进行操作的时候是对这个点对应的列向量进行操作。这个列向量可以为2 * 1 的矩阵。其中的这个2表示的是有两个维度x 和y，1表示的就是处理一个点坐标。</p><p>这样就很好理解了，P就是所有点坐标的集合，行数代表两个维度x和y，列数代表多少个点。缩放就是用矩阵T乘以矩阵P就可以了，达到批量缩放向量的目的。<br>$$<br>T \cdot P = \begin{bmatrix} 1.5 &amp; 0 \\ 0 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} 0 &amp; 4 &amp; 5 \\  0 &amp; 0 &amp;3\end{bmatrix} = \begin{bmatrix} 0 &amp; 6 &amp; 7.5 \\  0 &amp; 0 &amp;6\end{bmatrix}<br>$$<br>最终得到的结果也是一个矩阵。这个结果矩阵就是用T的每一行去乘以P的每一列，改变每一个点的位置。 </p><p>最终在二维坐标画出</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a1ltij30c6095gmj.jpg" alt="1570281864233"></p><p>我们可以根据矩阵与向量之间的乘法定义进而得出矩阵与矩阵相乘的定义。</p><blockquote><p>把P矩阵拆成一个一个的列向量分别和矩阵T相乘。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a04cdj30pg05gglo.jpg" alt="1570281984608"></p><blockquote><p>针对T*P，矩阵T的列数必须与矩阵P的行数相等才能进行乘法运算。想一想为什么？因为向量相乘的前提是元素个数相等才能相乘。T是取行向量，而P取的是列向量，行向量的元素个数由多少列决定，列向量元素个数由多少行确定。所以才有矩阵T的列数必须与矩阵P的行数相等。</p></blockquote><p>最终给出一个统一的公式</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7no8a3t9vj30o90bodh6.jpg" alt="1570282331598"></p><p>根据这个图可以得出，结果矩阵的第i行第j列的元素只，就是A矩阵第i行行向量乘以B矩阵第j列列向量。</p><p>如果A是一个m <em> k的矩阵，B是k </em> n的矩阵，则结果矩阵就是m * n的矩阵。因为向量相乘得到的结果是一个数，所以最终m， n都没了。</p><h2 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h2><p>虽然向量乘法遵守交换律但是矩阵乘法不遵守交换律。也就是$ A \cdot B \not= B \cdot A$</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这一节主要讲了矩阵和向量之间的乘法以及矩阵与矩阵的乘法。</p><p>整个推论过程由浅入深，从矩阵是向量的函数的视角出发，矩阵就是用来改变向量的。</p><p>然后结合三角形缩放的例子，根据缩放比例，先求得变换矩阵T。接着思考对一个点的缩放，能否扩展到对多个点进行缩放。最终多个点缩放就是将多个点组合为一个新的矩阵。用矩阵函数T分别去改变多个点组成矩阵的列向量。</p><blockquote><p>通过上面的过程，可以感受到知识其实是非常连贯的，从最开始的向量，向量基本运算，加上一些几何性质的探究，再到矩阵的运算，矩阵的实际含义等等都是非常连贯的。整个过程就是一个不断扩展，不断丰富的过程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——矩阵基础</title>
      <link href="/2019/10/05/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/10/05/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面几篇把向量介绍完了，接下来开始介绍矩阵。向量其实是特殊的矩阵，先从基础开始。</p></blockquote><a id="more"></a><h1 id="什么是矩阵"><a href="#什么是矩阵" class="headerlink" title="什么是矩阵"></a>什么是矩阵</h1><p>向量是对数的扩展，一个向量就是一组数。那么矩阵就是对向量的扩展，一个矩阵表示一组向量。</p><p>可以分别从行、列两个视角来看待矩阵，分别是行向量、列向量</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zheuxgj30dr08ngm4.jpg" alt="1570244661907"></p><p>上图的矩阵叫做为$ 4 * 4$的矩阵。</p><p>如过行数等于列数，那么就叫做方阵。</p><p>一般情况下，使用大写字母来代表矩阵，里面的每一个元素用小写的字母表示。并且标注有下标。如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhfe3vj30bn05e0t3.jpg" alt="1570244803616"></p><blockquote><p>矩阵其实和编程中的二维数组是一样的。可以通过(i, j)进行索引，i是行，j是列，可以表示为$a_{ij}$</p></blockquote><h1 id="应用矩阵举例"><a href="#应用矩阵举例" class="headerlink" title="应用矩阵举例"></a>应用矩阵举例</h1><p>比如用矩阵表示一个班级的学习成绩。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhg7j2j30br048q3k.jpg" alt="1570245172126"></p><p>对于这个矩阵，每一个行向量就是表示的每一个同学在每一个学科上的成绩。每一个列向量表示每一个学科不同人的成绩。</p><p>那么就可以在不同维度上做一些事情，比如在行向量上对每个维度进行加，那么就得到了每个同学的总成绩；在列向量上，可以求每一个科目的平均分。</p><p>在大多数数据科学中，拿到的数据也就是这样一个矩阵，然后对矩阵进行处理。</p><h1 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h1><h2 id="矩阵与标量的加减法"><a href="#矩阵与标量的加减法" class="headerlink" title="矩阵与标量的加减法"></a>矩阵与标量的加减法</h2><p>标量值要加到矩阵的每一个元素上。矩阵与标量的减法也相似。<br>$$<br>\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix} + \color{green}3 = \begin{bmatrix} 1 + \color{green}3 &amp; 2 + \color{green}3 \\ 3 + \color{green}3 &amp; 4 + \color{green}3 \end{bmatrix} = \begin{bmatrix} 4 &amp; 5 \\ 6 &amp; 7 \end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \end{bmatrix} - \color{green}3 = \begin{bmatrix} 1 - \color{green}3 &amp; 2 - \color{green}3 \\ 3 - \color{green}3 &amp; 4 - \color{green}3 \end{bmatrix} = \begin{bmatrix} -2 &amp; -1 \\ 0 &amp; 1 \end{bmatrix}<br>$$</p><h2 id="矩阵的加减法"><a href="#矩阵的加减法" class="headerlink" title="矩阵的加减法"></a>矩阵的加减法</h2><p>矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法只对同维度的矩阵才是有定义的。<br>$$<br>\begin{bmatrix} \color{red}1 &amp; \color{red}2 \\ \color{green}3 &amp; \color{green}4 \end{bmatrix} + \begin{bmatrix} \color{red}5 &amp; \color{red}6 \\ \color{green}7 &amp; \color{green}8 \end{bmatrix} = \begin{bmatrix} \color{red}1 + \color{red}5 &amp; \color{red}2 + \color{red}6 \\ \color{green}3 + \color{green}7 &amp; \color{green}4 + \color{green}8 \end{bmatrix} = \begin{bmatrix} \color{red}6 &amp; \color{red}8 \\ \color{green}{10} &amp; \color{green}{12} \end{bmatrix}<br>$$</p><p>$$<br>\begin{bmatrix} \color{red}4 &amp; \color{red}2 \\ \color{green}1 &amp; \color{green}6 \end{bmatrix} - \begin{bmatrix} \color{red}2 &amp; \color{red}4 \\ \color{green}0 &amp; \color{green}1 \end{bmatrix} = \begin{bmatrix} \color{red}4 - \color{red}2 &amp; \color{red}2  - \color{red}4 \\ \color{green}1 - \color{green}0 &amp; \color{green}6 - \color{green}1 \end{bmatrix} = \begin{bmatrix} \color{red}2 &amp; -\color{red}2 \\ \color{green}1 &amp; \color{green}5 \end{bmatrix}<br>$$</p><p>一个应用例子：一个班级有上学期成绩的矩阵，下学期成绩的矩阵</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhg7j2j30br048q3k.jpg" alt="1570246001352"></p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhgw10j30b105i0th.jpg" alt="1570246011360"></p><p>现在要求整个学期成绩，那么直接用$A+B$即可。</p><h3 id="矩阵与标量的乘法"><a href="#矩阵与标量的乘法" class="headerlink" title="矩阵与标量的乘法"></a>矩阵与标量的乘法</h3><p>矩阵与标量的乘法就是，标量与矩阵的每一个元素做乘法。</p><p>一个例子，就拿上面的学习成绩来讲。现在要求两个学期的平均分。那么直接就可以用$\frac{1}{2} \cdot (A + B)$</p><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>我们还可以从几何的角度来理解加法，现在以行向量的视角来看下面这个$3 * 2$的矩阵<br>$$<br>P=\begin{bmatrix} 0 &amp; 0 \\ 4 &amp; 0 \\ 5 &amp;3 \end{bmatrix}<br>$$<br>每一个行向量是二维的向量，可以对应到二维坐标上的一个点。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhgb32j30aq0803yx.jpg" alt="1570246564500"></p><p>这个时候用一个标量2来乘矩阵P，得到<br>$$<br>2 \cdot P=\begin{bmatrix} 0 &amp; 0 \\ 8 &amp; 0 \\ 10 &amp; 6 \end{bmatrix}<br>$$<br>那么将会得到新的三角形</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhhtvgj30am07xaao.jpg" alt="1570246661340"></p><p>相当于在原来的三角形上进行了缩放。<strong>矩阵在图形学上应用非常多。</strong></p><blockquote><p>矩阵和向量也遵循加法交换律，加法结合律。并且也存在有零矩阵，而且也存在负矩阵。可以把数的范围推广到向量，然后再推广到矩阵。</p></blockquote><h1 id="矩阵的另一个视角——系统"><a href="#矩阵的另一个视角——系统" class="headerlink" title="矩阵的另一个视角——系统"></a>矩阵的另一个视角——系统</h1><p>之前我们用了学习成绩的例子，把矩阵看做是一个<strong>数据表格</strong>。还可以把矩阵看做是一个系统。这个系统里面有很多变量。</p><blockquote><p>为了构建这样一个系统，核心的就是找到各个变量之间的约束关系，它们之间通过等式关联起来。这样的系统也就做线性系统，生活中有很多这样的例子。下面举例介绍。</p></blockquote><h3 id="小型经济系统"><a href="#小型经济系统" class="headerlink" title="小型经济系统"></a>小型经济系统</h3><p>比如在经济系统中，对IT、电子、矿产、房产的投入，那么我们可以把投入的份额分别用$ x_{it} , x_e, x_m, x_h$来表示。</p><p>他们之间有如下的关系</p><p>IT行业：<br>$$<br>x_it = 100 + 0.2x_e + 0.1x_m + 0.5x_h<br>$$<br>这个公式可以解读为：在IT行业，最少投入100亿。因为其他行业对IT行业会有一定的影响，所以需要加入其他行业影响，比如电子行业依赖于IT行业的发展，为了发展电子行业，需要在IT行业加上$0.2x_e$。其他的同理。<strong>这里的影响其实就是关系约束。</strong></p><p>电子领域：<br>$$<br>x_e = 50 + 0.5x_it + 0.2x_m + 0.1x_h<br>$$</p><p>矿产行业：<br>$$<br>x_m = 20 + 0.4x_e + 0.3x_h<br>$$<br>房产行业：<br>$$<br>x_h = 666 + 0.2x_it<br>$$<br>那么上面四个方程，合起来就形成了一个方程组，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhjmybj30d2062757.jpg" alt="1570247436662"></p><p>上面就用一个方程组描述了一个系统。</p><blockquote><p>这个过程中约束就是等式的关键。</p></blockquote><h3 id="另外一个例子"><a href="#另外一个例子" class="headerlink" title="另外一个例子"></a>另外一个例子</h3><p>网络中有如下图</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhjhpij30b208jt9l.jpg" alt="1570247623638"></p><p>最左边的是不同网络环境中的数据包，起始是100，最终都需要把这个数据包发送到最右边节点上。中间的节点可以看做是路由。</p><p>那么就可以根据上图列出下面的约束，也就是可以形成方程组。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhlfdpj30dx08umxz.jpg" alt="1570247752741"></p><p>根据这些约束，最终也可以表示成矩阵。</p><h3 id="归总"><a href="#归总" class="headerlink" title="归总"></a>归总</h3><p>上面的系统最终都可以表示为一个方程组。比如第一个经济系统</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhjmybj30d2062757.jpg" alt="1570247436662"></p><p>我们把各个系数抽取出来，组成一个矩阵。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhovrlj30ad0543yt.jpg" alt></p><p>左侧部分就是一个矩阵，右侧部分就是一个列向量。<strong>这样就完全把上面的关系，转换为了矩阵关系。其实线性系统都可以用矩阵来表示。</strong></p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7n6zhnlb2j30js05mwf3.jpg" alt="1570247995915"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这一篇介绍了什么是矩阵，以及矩阵一些基本运算，包括与标量，矩阵之间的加减。</p><p>最为深刻的是我们用实际例子，可以把矩阵看成是数据表格，更为高级的是用系统的视角（加入了变量）。用系统的视角来看矩阵，需要先根据实际案例，抽象出约束方程，然后将方程转换为矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——向量高级运算</title>
      <link href="/2019/10/04/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E5%90%91%E9%87%8F%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97/"/>
      <url>/2019/10/04/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E5%90%91%E9%87%8F%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇介绍了什么是向量的基础运算。包含了向量与向量的加减，向量与标量的加减乘。<strong>核心的就是沿着各个分量(轴)进行运算(平移)。</strong></p></blockquote><a id="more"></a><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>在没有接触向量之前，我们一直研究的是一个数，接触了向量之后我们开始研究一组数。对比之前研究一个数的时候，可以把数分为正数、负数、零。同样的，我们在向量的世界里也有对应正向量，负向量、零向量。</p><blockquote><p>这种类比学习的思路在做科学研究的时候非常有用。也就是通过已有的模型推断位置的模型，扩展模型的范围。</p></blockquote><h1 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h1><p>之前讲过向量可以从两个视角来看待。一个是有向线段，一个是空间中一个点。<strong>因为可以看做是一个有向线段，那么就有对应的长度</strong>。</p><p>在二维平面上，向量的大小就是勾股定理求得。</p><p><img src="https://learnopengl-cn.github.io/img/01/07/vectors_triangle.png" alt></p><p>因为两条边（x和y）是已知的，如果希望知道斜边$\color{red}{\bar{v}}$的长度，我们可以直接通过勾股定理来计算<br>$$<br>||{\bar{v}}|| = \sqrt{x^2 +y^2}<br>$$<br>记住向量长度的表示方法是用双竖线，这个也叫向量的摸。</p><p>几何意义就是原点到这个向量指向终点的欧拉距离。</p><h2 id="多维向量的长度"><a href="#多维向量的长度" class="headerlink" title="多维向量的长度"></a>多维向量的长度</h2><p>在三维空间中</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gkeecj306g084q2y.jpg" alt></p><p>所求的向量长度其实就是OP的长度。连接OA做条辅助线，很容易用知道OA的长度。进而知道OP的长度。<br>$$<br>||\bar{OP}|| = \sqrt{||\bar{OA}||^2 +||\bar{AP}||^2}<br>$$<br>对应到n维向量，同样可以推导出求模公式。<br>$$<br>\bar{u}=(u1, u2, ……,u_n)^T<br>$$<br>它的模就是<br>$$<br>||\bar{u}|| = \sqrt{||\bar{u_1}||^2 +||\bar{u_2}||^2+….+||\bar{u_n}||^2}<br>$$</p><h1 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h1><p>指的是长度固定为一个单位的向量。</p><p>用向量的各个分量分别处以向量的模就得到单位向量。<br>$$<br>\hat{n} = \frac{\bar{v}}{||\bar{v}||}<br>$$<br><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gkez6j306c07hjrc.jpg" alt="1570153494747"></p><blockquote><p>单位向量的模永远等于1，相当于单位向量的长度不再重要，它只表示方向。这样的好处在于可以把向量拆分为两个部分，一个是向量的方向用单位向量表示，一个是向量的大小用向量的模表示。</p></blockquote><p>求单位向量的过程也就是归一化，规范化（normalize）。</p><p>单位向量有无数多个。比如在二维坐标系中，所有单位向量就构成一个半径为1的圆。这个范围内有两个特殊的单位向量，指向x正方向的单位向量与指向y正方向的单位向量，我们叫它标准单位向量。<br>$$<br>\bar{e_1}=(1, 0) ;\bar{e_2}=(0, 1)<br>$$<br>标准单位向量的特点就是只有0、1组成，相当于指向坐标轴的正方向。</p><h2 id="n维空间的单位向量"><a href="#n维空间的单位向量" class="headerlink" title="n维空间的单位向量"></a>n维空间的单位向量</h2><p>同理三维空间中也是这样规定的。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gkeecj306g084q2y.jpg" alt="1570153864729"><br>$$<br>\bar{e_1}=(1, 0, 0) ;\bar{e_2}=(0, 1, 0); \bar{e_2}=(0, 0, 1)<br>$$<br>那么n维也是同样的表示方法。</p><h1 id="向量的点乘"><a href="#向量的点乘" class="headerlink" title="向量的点乘"></a>向量的点乘</h1><p>注意两个向量点乘（也就做内积）之后不再是一个向量，而是一个数，也就是一个标量。</p><p>公式展开如下：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gloarj30nn06gt9d.jpg" alt="1570154271990"></p><p>上面这个公式是纯数字公式，恰好最终结果也等于$ ||\bar{v}|| \cdot ||\bar{k}|| \cdot \cos \theta$。这个$ ||\bar{v}|| \cdot ||\bar{k}|| \cdot \cos \theta$就具有几何含义了。</p><p>$\theta$是指这两个向量之间的夹角。</p><h2 id="证明向量点乘的几何意义"><a href="#证明向量点乘的几何意义" class="headerlink" title="证明向量点乘的几何意义"></a>证明向量点乘的几何意义</h2><p>证明的核心就是需要用到三角函数中的余弦定理。如果有同学忘了可以看看这里<a href="[https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E5%AE%9A%E7%90%86/957460?fr=aladdin](https://baike.baidu.com/item/余弦定理/957460?fr=aladdin)">余弦定理百科</a></p><blockquote><p>余弦定理是揭示三角形边角关系的重要定理，直接运用它可解决一类已知三角形两边及<a href="https://baike.baidu.com/item/夹角/2387878" target="_blank" rel="noopener">夹角</a>求第三边或者是已知三个边求夹角的问题。</p></blockquote><p>$$<br>\bar{u} \cdot \bar{v} = x_1 \cdot x_2 + y_1 \cdot y_2 = ||\bar{u}||\cdot||\bar{v}|| \cdot \cos\theta<br>$$</p><p>然后连接vu，得到第三边。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gocvbj306u05nglq.jpg" alt="1570154933833"></p><p>根据余弦定理就可以写出公式<br>$$<br>||\bar{u} - \bar{v}||^2 = ||\bar{u}||^2 +  ||\bar{v}||^2 - 2 \cdot ||\bar{u}|| \cdot ||\bar{v}|| \cdot \cos\theta<br>$$<br>然后展开把$||\bar{u}||\cdot||\bar{v}|| \cdot \cos\theta$放一边，另一边完全用x,y完全替换最终就会得到</p><p>结果。</p><h2 id="多维向量的点乘"><a href="#多维向量的点乘" class="headerlink" title="多维向量的点乘"></a>多维向量的点乘</h2><p>根据上面的推论，多维向量的点乘等于各自的模乘以向量之间的夹角。<br>$$<br>\bar{u} \cdot \bar{v} = u_1 \cdot v_2 + u_1 \cdot v_2 + … + u_n \cdot v_n = ||\bar{u}||\cdot||\bar{v}|| \cdot \cos\theta<br>$$</p><h2 id="向量点乘的投影理解（加深）"><a href="#向量点乘的投影理解（加深）" class="headerlink" title="向量点乘的投影理解（加深）"></a>向量点乘的投影理解（加深）</h2><p>这里以二维空间为例。</p><p>将v投影到u向量上，那么蓝色的长度就是$||\bar{v}|| \cdot \cos\theta$</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gjyk3j306u04e3yh.jpg" alt="1570155800903"></p><p>使用投影的方式就把两个向量变化到了同一个方向上。<strong>不同方向上的向量不能直接做乘法，那么就用投影的方法变到同一个方向上。</strong></p><p>同理可以把u投影到v上面</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gp44hj307w05aaa5.jpg" alt="1570155924363"></p><p>蓝色的长度就是$||\bar{u}|| \cdot \cos\theta$，<strong>也就是投影向量的长度</strong>。</p><blockquote><p>核心就是使用投影将两个向量的方向进行统一，因为不同方向的向量做乘法是没有意义的。</p></blockquote><p>还可以用投影的方式来理解$x_1 \cdot x_2 + y_1 \cdot y_2$</p><p>把向量分别投影到x,y轴上</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gnxxbj30950743yn.jpg" alt="1570156088113"></p><p>向量相互垂直，方向不一致相乘是没有意义的或者说等于0。</p><h1 id="向量点乘的应用"><a href="#向量点乘的应用" class="headerlink" title="向量点乘的应用"></a>向量点乘的应用</h1><p>点乘的应用就是变化公式。改变输入。</p><p>比如<br>$$<br>\cos\theta = \frac{\bar{u} \cdot \bar{v}}{||\bar{u}|| \cdot ||\bar{v]||}}<br>$$</p><ul><li><p>那么当$\theta = 90^。$,那么向量点乘为  0</p></li><li><p>如果向量点乘等于0，则两个向量垂直</p></li><li><p>如果向量点乘大于0，则向量夹角为锐角 </p></li><li><p>如果向量点乘小于0，则向量夹角为钝角</p></li></ul><h2 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h2><p>比如在推荐系统中，根据两个向量之间的夹角，进而来判断相似程度。</p><p>如何判断电影是否相似呢？</p><p>想象一下每一个电影有很多维度来衡量，也就是可以想象一部电影就是多维空间中的一个点。对于电影来说维度可以是时间、演员、导演等等这些维度。如果把一个电影看成一个点，那么每两个电影之前就会有一个夹角。当夹角是锐角的时候说明是相似的，如果是垂直的就说明无关的，如果是钝角就说明两个电影是背离的。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lz7gn778j30kv06fmxa.jpg" alt="1570156875268"></p><h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2><p>图形学大量使用向量。</p><p>比如在表示物体位置的时候，使用了三维向量。</p><p>在表示物体颜色的时候可以使用向量(r,g,b,a)。</p><p>在讨论光照的时候，计算光照强度的时候，根据向量求而二者之间的夹角。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这节主要讲了向量的长度、单位向量、向量点乘。</p><p>核心讲了向量点乘，通过投影的视角来理解向量点乘的意义（不同发现上的向量相乘是没有意义的，需要变化到相同方向上）。还结合了余弦定理，证明了点乘公式。</p><p>最后讲了向量点乘的实际应用（本质上就是变化输入）。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI监督学习到底是什么？</title>
      <link href="/2019/10/03/2019/10/AI%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%88%B0%E5%BA%95%E7%94%9F%E6%84%8F%E4%BB%80%E4%B9%88/"/>
      <url>/2019/10/03/2019/10/AI%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E5%88%B0%E5%BA%95%E7%94%9F%E6%84%8F%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>非常通俗易懂的解释AI监督学习是什么，由浅入深并有相关配图。</p></blockquote><a id="more"></a><h1 id="学习、问题、方法、应用之间的关系"><a href="#学习、问题、方法、应用之间的关系" class="headerlink" title="学习、问题、方法、应用之间的关系"></a>学习、问题、方法、应用之间的关系</h1><p>当遇到一个新问题的时候，我们通过方法得到一个新的预测，但是预测的结论不一定正常，我们希望通过已经掌握的方法得到正确的预测。</p><p>但是方法不能凭空的产生，需要从以往的经验中学习，找出问题和答案之间的<strong>正确关系</strong>。</p><blockquote><p>应用是指使用方法解决问题用来预测答案，而学习就是用问题和答案来获得方法。<strong>获得方法才是学习的目的这也是我们从小到大学习的目的</strong></p></blockquote><p>最终它们的关系如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7lcel0m0dj30oc082q36.jpg" alt></p><h1 id="高考学习"><a href="#高考学习" class="headerlink" title="高考学习"></a>高考学习</h1><p>这里用高考作为例子来解释上面的整个流程</p><p>念高中的时候，我们从大量的历年大量的高考题以及各个高考题对应的答案中学习某个问题的解决方法。<strong>高考的目的其实是希望学生学到一个能解决高考中任意该类问题的方法。但是在高考之前我们并不知道已经学到的方法是有有效。</strong></p><p>所以经常会有考试，也就是模拟考试来测试，检验我们的学习成果，用已经学到的方法来预测模拟问题的答案。通过和模拟问题的答案进行对比，<strong>最终得出考试分数，从而衡量学习的有效性。</strong></p><p>最终决定你高考成果的并不是解决学习时所用的旧问题，也不是解决模拟题，而是解决最后的高考题。<strong>而高考也是一次验证自己所学方法有效性的一次模拟</strong>，不同之处在于该次模拟的结果是给他人参考而用的。各个大学和企业会用该次的模拟的结果来判断你所学方法的有效性，进而判断将来你解决问题的能力，<strong>更多是判断你的学习能力。</strong></p><p>最终各个阶段的关系如下图：</p><p><img src="http://ww1.sinaimg.cn/mw690/005M4Qg4ly1g7lcqzd5qbj30od0b9q3g.jpg" alt></p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>上面介绍的高考学习同时也是机器学习中最重要的监督学习。<strong>指的是有明确答案可供寻找问题与答案之间关系的学习方式</strong>。只不过上面的概念在机器学习中换成了新的名词而已。</p><ul><li>描述问题与答案之间关系的方法叫作——模型</li><li>学习问题与答案之间关系的过程叫做——训练</li><li>解决问题的过程叫做——预测</li><li>衡量模型好坏的过程叫做——评估</li><li>训练所用的问题和答案叫做——训练集</li><li>评估所用的问题和答案叫做——测试集</li></ul><p>它们之间的对应关系如下：</p><p><img src="http://ww1.sinaimg.cn/mw690/005M4Qg4ly1g7ld4xte0nj30o90cp750.jpg" alt></p><p>训练集和测试集都是数据，需要提前收集。</p><blockquote><p>当前人工智能的核心也就是将我们从小学到高中做了12年的事情搬到计算机上来做而已。最终的目的是希望得到一个可以解决该任务下任意新问题的模型。也就是用数据训练处模型并再应用。</p><p>最终：</p><p><img src="http://ww1.sinaimg.cn/mw690/005M4Qg4ly1g7ld77wn36j30ns04twei.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——向量基本运算</title>
      <link href="/2019/10/03/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E5%90%91%E9%87%8F/"/>
      <url>/2019/10/03/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇结尾介绍了什么是向量。首先向量是一组有序数，其次用多维向量来描述世界更加合适，然后讲了转化视角分别从方向和点的角度去理解向量。这一片介绍向量相关的运算。</p></blockquote><a id="more"></a><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><h2 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h2><p>向量是一组有序的数，<strong>而单单的一个数字就是标量</strong>。为了和标量区分，向量用画箭头的符号表示：$\bar{V}$。</p><p>一些情况下，尤其是在几何学中，我们需要考虑向量的起始点。比如起始点是O，结束点是A那么就表示为$\vec{OA}$。</p><h2 id="向量类型"><a href="#向量类型" class="headerlink" title="向量类型"></a>向量类型</h2><p>向量通常还分为行向量，列向量。比如</p><p>$\bar{v} =(x, y)$</p><p>就是行向量。</p><p>$\bar{v} = \begin{pmatrix} \color{red}x \\ \color{green}y \\ \end{pmatrix}$</p><p>就是列向量</p><p>通常情况下论文，教程提到的向量都是指列向量。比如在书籍中会有$(x, y)^T$这种形式，这种方式就是将行向量转置为列向量。</p><p><img src="http://ww1.sinaimg.cn/large/005M4Qg4ly1g7kyfi2t3oj308c08cmxi.jpg" alt></p><h1 id="向量的基本运算"><a href="#向量的基本运算" class="headerlink" title="向量的基本运算"></a>向量的基本运算</h1><h2 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h2><p>向量的加法可以被定义为是分量的(Component-wise)相加，即将一个向量中的每一个分量加上另一个向量的对应分量。具体来讲就是：<br>$$<br>\bar{v} = \begin{pmatrix} \color{red}1 \\ \color{green}2 \\ \color{blue}3 \end{pmatrix}, \bar{k} = \begin{pmatrix} \color{red}4 \\ \color{green}5 \\ \color{blue}6 \end{pmatrix} \rightarrow \bar{v} + \bar{k} = \begin{pmatrix} \color{red}1 + \color{red}4 \\ \color{green}2 + \color{green}5 \\ \color{blue}3 + \color{blue}6 \end{pmatrix} = \begin{pmatrix} \color{red}5 \\ \color{green}7 \\ \color{blue}9 \end{pmatrix}<br>$$<br>高中的时候我们知道向量a加b结果以a，b为边的平行四边形的对角线。如何理解？</p><p>比如$(5, 2)^T+ (2, 5)^T$</p><p>默认位置</p><p><img src="https://www.wxlong.tech/post_images/1570081530300.png" alt="1570081530300"></p><p>加法意思就是：先从原点出发，移动到（5， 2）这个位置，<strong>然后再从（5， 2）往右走2，然后往上走5，如下图所示。</strong></p><p><img src="https://www.wxlong.tech/post_images/1570081570771.png" alt="1570081570771"></p><p>最终就是从原点位置移动到了$(7, 7)^T$这个位置</p><p><img src="https://www.wxlong.tech/post_images/1570081721506.png" alt="1570081721506"></p><p>把边其余的边都补上，就如上图所示，最终结果就是以a,b为边的平行四边形的对角线。</p><blockquote><p>两个向量相加其实就是沿着各个方向移动，而移动的距离以及方向就是根据具体向量的值来确定，最终位置就是平移完之后停留的位置。所以向量相加最终也得到一个新的向量。</p></blockquote><h3 id="多维向量的相加"><a href="#多维向量的相加" class="headerlink" title="多维向量的相加"></a>多维向量的相加</h3><p>同二维向量一样，多维向量的相加同样也是各个分量相加，<strong>相当于各个坐标轴分别相加（因为都会平移）。</strong></p><h2 id="向量与标量的运算"><a href="#向量与标量的运算" class="headerlink" title="向量与标量的运算"></a>向量与标量的运算</h2><h3 id="标量与向量的加法"><a href="#标量与向量的加法" class="headerlink" title="标量与向量的加法"></a>标量与向量的加法</h3><p>前面讲过标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。<strong>当把一个向量加/减/乘/除一个标量</strong>，我们可以简单的把向量的每个分量分别进行该运算。对于加法来说会像这样:<br>$$<br>\begin{pmatrix} \color{red}1 \\ \color{green}2 \\ \color{blue}3 \end{pmatrix} + x = \begin{pmatrix} \color{red}1 + x \\ \color{green}2 + x \\ \color{blue}3 + x \end{pmatrix}<br>$$</p><h3 id="标量与向量的乘法分析"><a href="#标量与向量的乘法分析" class="headerlink" title="标量与向量的乘法分析"></a>标量与向量的乘法分析</h3><blockquote><p>通过数的乘法我们知道乘法其实就是多个加法而已。所以这里标量与向量的乘法含义就是多个向量之间的加法运算。</p></blockquote><p>比如 </p><p>$$ 2 * (5, 2)^T$$</p><p>就是两个（5，2）向量相加。</p><p>延伸一下<br>$$<br>k * (a, b)^T = (ka, kb)^T<br>$$<br>意思就是向x移动k次a个单位，再向y移动k次b个单位，总共就是x移动了ka个单位，y移动了kb个单位。</p><h3 id="向量的减法"><a href="#向量的减法" class="headerlink" title="向量的减法"></a>向量的减法</h3><p>我们知道减法其实就是加法的逆运算。比如a-b= a + (-b)。对于向量而言，-b其实就是b的相反向量。</p><p>一个例子：</p><p><img src="https://www.wxlong.tech/post_images/1570083210720.png" alt="1570083210720"></p><p>上图我们非常容易的知道u是红色向量v和绿色向量的和，反过来，那么绿色的向量就应该是u-v。</p><h1 id="零向量"><a href="#零向量" class="headerlink" title="零向量"></a>零向量</h1><p>对于任意一个向量u,都存在一个向量o，满足u+0=u。称这个向量为0向量。</p><p>那么就很自然而然的就知道坐标原点就指向零向量的向量。因为零向量和原点重合，所以零向量是没有箭头的。<strong>可以这样认为0向量是个特殊的向量，它就是原点。</strong></p><p>和数字零不同的在于，零就是一个数字。而零向量是可以多个的，不同的维度有不同的零向量。</p><p>有了零向量，那么对应数字有负数，那么向量也就有了负向量。u+(-u)=0，并且这个负向量是位移的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>从上一篇开始到现在，我们把向量最为基础的部分讲解完了。主要有如下几个部分：</p><ul><li>什么是向量：一组数</li><li>两个视角：有向线段，数据点</li><li>基本运算：向量加减法，与标量的加减乘除</li><li>零向量：扩充向量范围，类比数的范围。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数——思考</title>
      <link href="/2019/10/02/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2019/10/02/2019/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线性代数是很多科学的基础，大学的时候学过，那时候没有意识到线代这么重要，也就应付一下考试。随着工作的深入，以及平时研究一些有趣的问题，越发觉得线代越来越有意思，于是就有了这个系列。</p></blockquote><a id="more"></a><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>最近在看<strong>OpenGL</strong>，发现线性代数在坐标变换、光照系统应用非常频繁。虽然系统库（GLEW）已经把向量、矩阵各种操作封装好了，但是深入的了解其含义是非常重要的。</p><p> 毫不夸张的说：线性代数是近代科学发展的最重要的基础数学之一。就拿IT行业来讲，图形学，人工智能都和线性代数密不可分。</p><p>大家知道在初等教育中代数更多的是讲的如何研究<strong>一个数，仅仅是一个数。</strong>比如作用于一个数的函数$$f(x$$)这种形式。而线性代数研究的更多是<strong>一组数，也就是后面会讲的向量。</strong>比如一个作用于一个向量的函数$$V（\vec{u}）$$。以及后面介绍到的矩阵，矩阵的作用其实就是用来变化向量的，所以可以把矩阵看做是作用于向量的函数。</p><p>在正式进入线性代数之前，让我们感受一下什么是代数，下面这节有些宏观，不过很贴切。</p><h2 id="什么是代数"><a href="#什么是代数" class="headerlink" title="什么是代数"></a>什么是代数</h2><p>代数是用来研究事物之间关系的一种方式。这是自己的理解，用来描述事物的关系，而函数就是用来改变这种关系的工具。<strong>注意代数和算数最大的不同在于，代数着重的是变量之间的关系，而不是变量的量（结果）。</strong>或者干脆用一种最为直观的方式来理解，代数即符号，用符号代替一种事物。</p><p>代数的两个核心：变量（符号）、函数。输入一系列变量到一个函数中，进行研究它们的关系，以及对结果的影响。</p><p>一个的例子：$$y = f(x) = x +1 $$。x是原有数量，y当前数量，f计数函数。这个就是一个简单的计数模型。<strong>注意上面这个等式，它不关心具体结果，因为没有具体的输入，输出，而只是研究了数与数之间的关系，这是这种能力使我们区别了其他生物</strong>————把这个等式看是一种模型，那么我们就可以反复的使用这个模型。</p><p>如果要说最早的代数，那么无疑人类的语言就是第一批代数符号，其他生物的语言只会用来指代具体的事物和数量，也就是它们的语言中没有变量，<strong>而人类的语言可以用来指代抽象的事物和关系。这就是变量和函数的雏形。</strong></p><blockquote><p>语言的作用不仅仅用来交流，而更重要的是用来描述事物的关系，当前的环境，以及预测未来发生的事情，进而做出决策。</p></blockquote><p>现在已经有了人类语言、数学语言，人类又发明了计算机语言。<strong>将重复利用现有模型的能力推到了一个前所未有的高度（想想平时写代码的时候，为什么尽量把函数写短小一点，也就是便于复用）。</strong></p><p>在将线性代数之前把什么是代数理解清楚了，再去理解线性代数就更加容易。</p><h2 id="研究一组数的意义"><a href="#研究一组数的意义" class="headerlink" title="研究一组数的意义"></a>研究一组数的意义</h2><blockquote><p> 初等代数研究一个数，为什么还要去要就一组数呢。因为现实的世界是多维度的，单个变量不足以描述真实世界，用单个变量描述世界非常不方便。正如上面所讲我们需要研究的是事物的关系。<strong>当确定这种关系之后，我们就可以复用这种关系模型。</strong></p></blockquote><p>代数就是一种描述世界的方式。线性代数着重的是线性空间及线性变换，事物是多维的，所以需要线性代数来描述更为合适，所以线代在很多学科才如此重要，计算机、人工智能；经济，建筑；化学；天文等等。</p><p>讲了这么多终于把前戏做完了，接下来是对线性代数相关内容的介绍。</p><h2 id="会讲到的内容"><a href="#会讲到的内容" class="headerlink" title="会讲到的内容"></a>会讲到的内容</h2><p>线性代数涉及非常多，所以不可能像大学那样详详细细的走完。后面的章节会结合实际的运用，将一些重要而实用的部分。主要有：</p><ul><li>向量<ul><li>标量</li><li>向量基本运算</li><li>零向量</li><li>各种几何意义</li></ul></li><li>矩阵<ul><li>矩阵的基本运算</li><li>矩阵与向量</li><li>单位矩阵</li><li>几何意义（旋转、缩放、平移）</li><li>矩阵的逆</li></ul></li></ul><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="什么是向量"><a href="#什么是向量" class="headerlink" title="什么是向量"></a>什么是向量</h2><p>一组数的基本表示方法就是向量（Vector)，用向量来表示一组数，向量也就是线性代数研究的基本单元。</p><p>提到向量一个重要点就是：方向。这也是为什么中文翻译有一个方向的<code>向</code>。<strong>除了量之外，还关系方向。</strong>比如高中物理将的，位移、速度、加速度、力这些概念都是和向量相关的，因为它们都有方向。</p><h3 id="向量的起始点"><a href="#向量的起始点" class="headerlink" title="向量的起始点"></a>向量的起始点</h3><p><img src="https://www.wxlong.tech/post_images/1570072544812.png" alt="1570072544812"><br><img src="https://www.wxlong.tech/post_images/1570072555033.png" alt="1570072555033"></p><p>比如上面这两个向量，可以这样来理解：</p><ul><li>前面的向量是从(0,0)先向右走4，然后往上走3。</li><li>后面的向量是从(-1, -1)同样是先向右走4，然后往上走3。</li></ul><p>对于这两个过程，只有坐标系不同而已。向量表示一个点到另一个点的结果，所以为了研究方便默认以坐标原地为基础的。</p><blockquote><p><strong>同理在研究数的问题上我们经常用数轴来表示，比如6就是距离0有6个单位的地方，而6到-1就是7个单位，为什么我们不把6表示成7呢。也就是默认是以0点为参考的。</strong></p></blockquote><p>注意：向量是有顺序的，向量是一组有序的数，顺序不同结果不同。</p><h3 id="多维向量"><a href="#多维向量" class="headerlink" title="多维向量"></a>多维向量</h3><p>我们能感知的方向最多就是三维的，所以用三个维度的向量描述我们感知的方向。但依然存在着多维，很难想象出多维的具体样子，可是现实中我们已经用到了多维的思路来描述事物。比如一个简单的例子——如何描述套房子：</p><p><img src="https://www.wxlong.tech/post_images/1570073270844.png" alt="1570073270844"></p><p>每一个数字都是一个维度。那么我们就可以用向量来描述这么一通房子<strong>(120, 3, 2, 2, 666)</strong>。这就是一个5维的向量，依然满足向量就是一组数。<strong>注意向量是有顺序的，所以不能随意改变顺序。</strong>而具体维度代表什么含义，是由使用者决定的。</p><h3 id="转化视角（方向、点）"><a href="#转化视角（方向、点）" class="headerlink" title="转化视角（方向、点）"></a>转化视角（方向、点）</h3><p>二维的向量我们很容易的转化到x,y坐标系中。比如(4, 3)这个向量，对应的坐标系就是一个点。</p><p><img src="https://www.wxlong.tech/post_images/1570072544812.png" alt="1570072544812"></p><p>同理我们可以将上面的<strong>(120, 3, 2, 2, 666)</strong>5维向量，同样的转化到多维空间的一个点。这个有点难以想象，但是可以依照二维空间的规则来思考。</p><p>比如一个拥有5个维度的坐标轴空间，每个坐标轴的取值都可以从负无穷到正无穷之间任意取值。这样一看<strong>(120, 3, 2, 2, 666)</strong>5维向量就对应5维空间的一个点。</p><p>通过上面的转化方式，<strong>我们就可以将方向和点进行转化，一个方向就是一个点。</strong>一个重要的前提：就是空间中的任意一个点都可以看做是由远点指向这个点的一个方向。</p><p>方向和点这两个视角给向量赋予了几何意义，让向量不仅仅只是表示一组数字，更应该结合空间理解向量。比如方向这个视角把向量是一<strong>有向线段</strong>，而点这个视角把向量看做事<strong>空间</strong>中的一个点。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇是对线性代数的一个基本介绍，用一个比较深刻的视角(人类语言)介绍了什么是代数，代数就是研究关系。然后简单介绍了线性代数中的向量。</p><p>从多个角度来看向量，它具有数、方向、点的属性。下一篇介绍向量其他特性。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL 学习总结</title>
      <link href="/2019/09/27/2019/9/OpenGL%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/27/2019/9/OpenGL%20%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>花了大半个月的时候把OpenGL相关的学习了一下，也算是对图形学的深入了解。之前做过很长时间的客户端，关于很多渲染底层相关的东西都没有了解过。<strong>对多也就停留在所谓的离屏渲染名词而已。</strong>做客户端的同学确实也应该把计算机图形学大致了解一下，尤其想做做游戏方面开发的同学更应如此。</p></blockquote><a id="more"></a><h1 id="整体感觉"><a href="#整体感觉" class="headerlink" title="整体感觉"></a>整体感觉</h1><p>一口气学下来，内容难度是由浅入深，前面三个大的部分基础部分比较好理解，而且代码也比较好理解。但是到了后面的高级部分就非常烧脑筋了，反正很多内容没看懂，自己也明确目标，并不是深入搞图形算法，图形研究。到了后面的高级部分也就适可而止。 </p><p>所有通过肉眼观察的物体具有下面三个属性：</p><ul><li>远近</li><li>形状</li><li>颜色</li></ul><p>通过上面三个属性可以得到一个静态的物体，也是最为基本的单元。</p><p>这三个属性在OpenGL中有对应的概念来联系现实物体。<strong>很多概念、理论都是来源于现实，通过现实的经验去抽象出经验规律。</strong></p><p>物体形状对应的物体顶点；物体颜色对应光照；物体远近对应摄像机。</p><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>渲染管线在图形学中非常重要，抽象的也就是我们如何看到一个物体的过程。具体过程如下：<br><img src="https://www.wxlong.tech/post_images/15695704846257.jpg" alt></p><p>整个学习的过程也是沿着这个渲染流程进行。</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p>总结了一张思维导图，对照这个导图可以知道自己掌握了哪些部分。<br><img src="https://www.wxlong.tech/post_images/LearnOpenGL.png" alt="LearnOpenG"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opengl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客访问失败，服务器被封，重头来！</title>
      <link href="/2019/09/18/2019/9/%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E5%B0%81%EF%BC%8C%E9%87%8D%E5%A4%B4%E6%9D%A5/"/>
      <url>/2019/09/18/2019/9/%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E5%B0%81%EF%BC%8C%E9%87%8D%E5%A4%B4%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前天下午开始，买的香港服务器就一直访问不了，<code>ssh</code>也不行，这就意味着之前在这台服务器上搭建的三个网站全部打水漂了。几个网站都是是自己一手拉扯打的，投入了很多精力……</p></blockquote><a id="more"></a><h1 id="被封事件"><a href="#被封事件" class="headerlink" title="被封事件"></a>被封事件</h1><p>上午还在更新博客，下午服务器直接被封，一起都来得突然。追究其原因，还是自己为了省力，直接在香港服务器上搭了个私人<code>SSR</code>服务。不料最近这段时间快到国庆了，政府抓这个抓得严。虽然自己平时也就用来做一些正经的事情，但是还是被封了。</p><p>这次被封事件，让自己忙活了大半年的个人网站、资源分享网站、教程网站都付之一炬。心痛得无法呼吸，且不说服务器采用半年时间，最重要的是里面投入的心血和时间。<strong>大半年以来，所以的技术博客都迁移到了wordpress上面，也正好用这个想做一点资源收集、分享的事情，顺便赚点外快。这下可好，什么都没捞着。</strong></p><blockquote><p>通过这次事件之后，总结出在天朝还是乖乖的挺指挥，规则要遵守的还是必须遵守，虽然平时可能没影响，存在侥幸心理总有一天会出事情。</p></blockquote><h1 id="善后工作"><a href="#善后工作" class="headerlink" title="善后工作"></a>善后工作</h1><p>既然数据已经都访问不了了，那也只能这样了。于是自己想到了之前用过<code>hexo</code>来写博客，和<code>wordpress</code>最大的不同就是<code>hexo</code>非常轻量级，静态博客，而wordpress比较重量级，扩展性也好很多。</p><p>现在还是觉得个人博客还是用<code>hexo</code>来搭建把，依托在一个Page服务上，比如GitHub、Coding这些Page服务。这样基本上不会受什么影响。商业性质的还是走WordPress，毕竟是重量级，扩展性也好很多。图片、视频这些都可以直接存在服务器上。hexo就没有这么方便。一般都需要用到第三方图床服务。</p><p>这是移回hexo第一篇迁博客。之前在这上面的老博客也不准备去修复图片外链了。一切重新开始吧！</p><h1 id="一个全新的开始"><a href="#一个全新的开始" class="headerlink" title="一个全新的开始"></a>一个全新的开始</h1><p>这次被封事件对自己而言也是一次全新的开始。数据备份一定要做，并且对于个人重要数据一定要在一段时间内更新备份。因此买了移动硬盘，不经历这样的坑是不知道备份是多么重要。</p><p>技术文章也重新回到了正规，虽然丢掉了几个月的文章。不过有些也是有底稿的，相当于是对知识的总结而已，大可不必患得患失。<strong>相信，后面的总结更加用心去做！</strong></p><blockquote><p>20190918 博客新纪元！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web如何启动到Servlet&amp;Tomcat</title>
      <link href="/2018/06/11/2018/6/Java%20Web%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E5%88%B0Servlet&amp;Tomcat/"/>
      <url>/2018/06/11/2018/6/Java%20Web%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E5%88%B0Servlet&amp;Tomcat/</url>
      
        <content type="html"><![CDATA[<blockquote><p>平时我们在写一般的应用程序的时候，无论如何都会有一个main函数入口。而在进行web开发的时候，从头到尾我们都没有写过一个main函数。最后部署时，打了一个war包，传到web容器下面就可以了。<strong>到底这后面发生了什么，带着疑问让我开始吧。</strong></p></blockquote><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>先了解一下java web应用目录组织结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7bad8f5da338ab7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>WebRoot ：Web应用所在目录，一般情况下虚拟目录要配置到此文件夹当中。</li><li>WEB-INF：<strong>此文件夹必须位WebRoot文件夹里面，而且必须以这样的形式去命名，字母都要大写。</strong></li><li>Web.xml：<strong>配置文件，有格式要求，此文件必须以这样的形式去命名，并且必须放置到WEB-INF文件夹中。</strong></li></ul><p>在看看一个浏览器与服务器交互的流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-e146fa9be8ef34f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>在java web项目中，我们无论是用什么框架，Spring MVC也好，Spring Boot也好，最后都是Servlet在起着决定性的作用。</p><h2 id="Servlet是什么？"><a href="#Servlet是什么？" class="headerlink" title="Servlet是什么？"></a>Servlet是什么？</h2><p>Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 </p><p>Servlet在Web应用程序的位置如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-09afe2d51564eb0d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p><strong>Servlet程序是由web容器调用，也就解释了为什么我们所写的web应用程序不需要main函数的原因，它是由web容器根据请然后创建的。</strong></p></blockquote><p>Servlet主要作用有：</p><ul><li>读取客户端（浏览器）发送的数据 。</li><li>处理数据并生成结果。这个过程可能需要访问数据库，调用 Web 服务，或者直接计算得出对应的响应。<strong>平时的业务逻辑就是在这个部分实现。</strong></li><li>发送处理过后的数据给客户端（浏览器）。</li></ul><h2 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h2><p>web容器收到客户端的访问请求后将进行如下处理：</p><ol><li>Web容器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第4步，否则，执行第2步。 　　</li><li>装载并创建该Servlet的一个实例对象。  　</li><li>调用Servlet实例对象的init()方法。 　　</li><li>创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 　　</li><li>WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。   </li></ol><p>具体来讲可以用下面的图说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-82ccf891428975e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-0cf8986122ea42f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-732fe84d5d4909ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-cd6c1fc2f080f5a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其时序图可以用下图表示：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-cb0190e14e5a4207.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="一个Servlet例子"><a href="#一个Servlet例子" class="headerlink" title="一个Servlet例子"></a>一个Servlet例子</h2><p>有了上面的理论基础我们就可以写一个例子加深理解。最终实现一个现实header的效果。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-8631cf9e786d028c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Enumeration<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>ServletException<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServlet<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletRequest<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletResponse<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DisplayHeaderServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理 GET 方法请求的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置响应内容类型</span>        response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PrintWriter out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String title <span class="token operator">=</span> <span class="token string">"HTTP Header 请求"</span><span class="token punctuation">;</span>        String docType <span class="token operator">=</span>                <span class="token string">"&lt;!DOCTYPE html> \n"</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>docType <span class="token operator">+</span>                <span class="token string">"&lt;html>\n"</span> <span class="token operator">+</span>                <span class="token string">"&lt;head>&lt;meta charset=\"utf-8\">&lt;title>"</span> <span class="token operator">+</span> title <span class="token operator">+</span> <span class="token string">"&lt;/title>&lt;/head>\n"</span><span class="token operator">+</span>                <span class="token string">"&lt;body bgcolor=\"#f0f0f0\">\n"</span> <span class="token operator">+</span>                <span class="token string">"&lt;h1 align=\"center\">"</span> <span class="token operator">+</span> title <span class="token operator">+</span> <span class="token string">"&lt;/h1>\n"</span> <span class="token operator">+</span>                <span class="token string">"&lt;table width=\"100%\" border=\"1\" align=\"center\">\n"</span> <span class="token operator">+</span>                <span class="token string">"&lt;tr bgcolor=\"#949494\">\n"</span> <span class="token operator">+</span>                <span class="token string">"&lt;th>Header 名称&lt;/th>&lt;th>Header 值&lt;/th>\n"</span><span class="token operator">+</span>                <span class="token string">"&lt;/tr>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Enumeration headerNames <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaderNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>headerNames<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String paramName <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>headerNames<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&lt;tr>&lt;td>"</span> <span class="token operator">+</span> paramName <span class="token operator">+</span> <span class="token string">"&lt;/td>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String paramValue <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>paramName<span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;td> "</span> <span class="token operator">+</span> paramValue <span class="token operator">+</span> <span class="token string">"&lt;/td>&lt;/tr>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;/table>\n&lt;/body>&lt;/html>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 处理 POST 方法请求的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token function">doGet</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写完之后，还需要将文件便以为class文件，项目部署到tomcat目录下。启动tomcat Web容器访问对应路径即可。</p><p>在web.xml中配置一下加载的Servlet</p><pre class="line-numbers language-xml"><code class="language-xml">     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- servlet名，一般写成类名，并不一定严格是类名 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>DisplayHeaderServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 所在的包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.xxx.xxx.DisplayHeaderServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 与上面的servlet-name相对应--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>DisplayHeaderServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 访问的网址 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/TomcatTest/DisplayHeaderServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Servlet需要注意"><a href="#Servlet需要注意" class="headerlink" title="Servlet需要注意"></a>Servlet需要注意</h2><h3 id="Servlet访问URL映射配置"><a href="#Servlet访问URL映射配置" class="headerlink" title="Servlet访问URL映射配置"></a>Servlet访问URL映射配置</h3><p>由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上。</p><p>这个工作在web.xml文件中使用<code>&lt;servlet&gt;</code>元素和<code>&lt;servlet-mapping&gt;</code>元素完成。<code>&lt;servlet&gt;</code>元素用于注册Servlet，它包含有两个主要的子元素：<code>&lt;servlet-name&gt;</code>和<code>&lt;servlet-class&gt;</code>，分别用于设置Servlet的注册名称和Servlet的完整类名。  </p><p>一个<code>&lt;servlet-mapping&gt;</code>元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：<code>&lt;servlet-name&gt;</code>和<code>&lt;url-pattern&gt;</code>，分别用于指定Servlet的注册名称和Servlet的对外访问路径。 </p><ul><li>同一个Servlet可以被映射到多个URL上，即多个<code>&lt;servlet-mapping&gt;</code>元素的<code>&lt;servlet-name&gt;</code>子元素的设置值可以是同一个Servlet的注册名。 </li><li>同一个Url不能对应多个Servlet。否则会报错<code>Caused by: java.lang.IllegalArgumentException: The servlets named [xxx] and [xxx] are both mapped to the url-pattern xxx</code></li></ul><h3 id="Servlet访问URL使用-通配符映射"><a href="#Servlet访问URL使用-通配符映射" class="headerlink" title="Servlet访问URL使用*通配符映射"></a>Servlet访问URL<strong>使用*通配符</strong>映射</h3><p><strong>在Servlet映射到的URL中也可以使用*通配符，但是只能有两种固定的格式：一种格式是<code>&quot;*.扩展名&quot;</code>，另一种格式是以正斜杠（/）开头并以<code>&quot;/*&quot;</code>结尾</strong> </p><p>但是如果存在了冲突，比如都有<code>*</code>。规则又是怎样的呢？</p><table><thead><tr><th align="center">请求Url</th><th align="center">Url1</th><th align="center">Url2</th><th align="center">规则</th></tr></thead><tbody><tr><td align="center">/abc/a.html</td><td align="center">/abc/*</td><td align="center">/*</td><td align="center">Servlet引擎将调用/abc/*</td></tr><tr><td align="center">/abc</td><td align="center">/abc/*</td><td align="center">/abc</td><td align="center">Servlet引擎将调用/abc</td></tr><tr><td align="center">/abc/a.do</td><td align="center">/abc/*</td><td align="center">*.do</td><td align="center">Servlet引擎将调用/abc/*</td></tr><tr><td align="center">/a.do</td><td align="center">/*</td><td align="center">*.do</td><td align="center">Servlet引擎将调用/*</td></tr><tr><td align="center">/xxx/yyy/a.do</td><td align="center">/*</td><td align="center">*.do</td><td align="center">Servlet引擎将调用/*</td></tr></tbody></table><blockquote><p><strong>匹配的原则就是”谁长得更像就找谁”</strong> 。但是当请求url完全匹配的时候就走完全匹配的rul。如上面的第二条。</p></blockquote><h3 id="Servlet与普通Java类的区别"><a href="#Servlet与普通Java类的区别" class="headerlink" title="Servlet与普通Java类的区别"></a>Servlet与普通Java类的区别</h3><blockquote><p>Servlet是一个供其他Java程序（Servlet引擎，比如tomcat web容器）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。这也是开发Web项目没有些main方法的原因。</p></blockquote><p>针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，<strong>也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁</strong>。</p><p>在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。</p><p><strong>对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</strong></p><p>如果在<code>&lt;servlet&gt;</code>元素中配置了一个<code>&lt;load-on-startup&gt;</code>元素，<strong>那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。</strong></p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>invoker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>            org.apache.catalina.servlets.InvokerServlet        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以用于为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。<strong>很多第三方框架也需要在应用一加载就实例化Serlvet，比如SpringMVC中的org.springframework.web.servlet.DispatcherServlet</strong></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- springMVC的核心控制器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath*:springMVC-servlet.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>async-supported</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>async-supported</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="缺省Servlet"><a href="#缺省Servlet" class="headerlink" title="缺省Servlet"></a>缺省Servlet</h3><p>如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。  　　</p><p>凡是在web.xml文件中找不到匹配的<code>&lt;servlet-mapping&gt;</code>元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，<strong>缺省Servlet用于处理所有其他Servlet都不处理的访问请求。</strong> </p><p>比如在tomcat中\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。 </p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.apache.catalina.servlets.DefaultServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>debug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>listings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- The mapping for the default servlet --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。 </p></blockquote><h3 id="Servlet的线程安全问题"><a href="#Servlet的线程安全问题" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h3><p>当多个客户端并发访问同一个Servlet时，<strong>web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题</strong>。 </p><blockquote><p>所有在Servlet中尽量<strong>避免使用实例变量</strong> ，最好使用局部变量。</p></blockquote><h3 id="Servlet如何处理多个请求访问"><a href="#Servlet如何处理多个请求访问" class="headerlink" title="Servlet如何处理多个请求访问"></a>Servlet如何处理多个请求访问</h3><p>Servlet容器默认是采用单实例多线程的方式处理多个请求的：</p><ul><li>当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化(只存在一个Servlet实例)</li><li>容器初始化化Servlet主要就是读取配置文件（例如tomcat,可以通过servlet.xml的<connector>设置线程池中线程数目，初始化线程池通过web.xml,初始化每个参数值等等。</connector></li><li>当请求到达时，Servlet容器通过调度线程(Dispatchaer Thread) 调度它管理下线程池中等待执行的线程（Worker Thread）给请求者。</li><li>线程执行Servlet的service方法。</li><li>请求结束，放回线程池，等待被调用；</li></ul><p>从上面可以看出（好处）：</p><ol><li>Servlet单实例，减少了产生servlet的开销；</li><li>通过线程池来响应多个请求，提高了请求的响应时间；</li><li>Servlet容器并不关心到达的Servlet请求访问的是否是同一个Servlet还是另一个Servlet，直接分配给它一个新的线程。</li><li>如果是同一个Servlet的多个请求，那么Servlet的service方法将在多线程中并发的执行；</li><li>每一个请求由ServletRequest对象来接受请求，由ServletResponse对象来响应该请求；</li></ol><h2 id="Servlet相关对象"><a href="#Servlet相关对象" class="headerlink" title="Servlet相关对象"></a>Servlet相关对象</h2><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>上面讲了可以设置Servlet对应的url,那么如何需要配置Serlvet初始化参数怎么办，这就需要用到ServletConfig。在Servlet的配置文件web.xml中，可以使用一个或多个<code>&lt;init-param&gt;</code>标签为servlet配置一些初始化参数。 </p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>ServletConfigDemo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.xxx.xxx.xxx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--配置ServletConfig的初始化参数 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>xxx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>password<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>charset<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，我们通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 </p><p>获取方式如下：</p><pre class="line-numbers language-java"><code class="language-java">     <span class="token comment" spellcheck="true">/**     * 定义ServletConfig对象来接收配置的初始化参数     */</span>    <span class="token keyword">private</span> ServletConfig config<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，     * 会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，     * 将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以     * 得到当前servlet的初始化参数信息。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>ServletConfig config<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> config<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span>            <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取在web.xml中配置的初始化参数</span>        <span class="token comment" spellcheck="true">//获取指定的初始化参数</span>        String paramVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>paramVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&lt;hr/>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取所有的初始化参数</span>        Enumeration<span class="token operator">&lt;</span>String<span class="token operator">></span> e <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameterNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String name <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String value <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value <span class="token operator">+</span> <span class="token string">"&lt;br/>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如在使用SpringMVC的时候，在web.xml就使用到了ServletConfig</p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--配置ServletConfig的初始化参数 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath:spring/spring-mvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--web容器一旦加载就会创建这个servlet，并且会调用init方法--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SpringMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>对于ServletContext需要我们注意一下几点：</p><ul><li>WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。</li><li>ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 </li><li>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 </li></ul><blockquote><p>类似于ServletContext（应用上下文）这种设计思想，很多地方都有类似的应用。比如iOS中的画图CGContext 。</p></blockquote><p>来一个数据共享的例子：</p><p>存储数据：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span>            <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        String data <span class="token operator">=</span> <span class="token string">"data"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，         * 可以通过ServletConfig.getServletContext方法获得ServletContext对象。         */</span>            <span class="token comment" spellcheck="true">//获得ServletContext对象</span>        ServletContext context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将data存储到ServletContext对象中</span>            <span class="token comment" spellcheck="true">//将data存储到ServletContext对象中</span>        context<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取数据：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span>            <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        ServletContext context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\        <span class="token comment" spellcheck="true">//从ServletContext对象中取出数据</span>        String data <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"data="</span><span class="token operator">+</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多的情况下是通过web.xml中读取初始化参数。如下：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 配置WEB应用的初始化参数 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>context<span class="token operator">-</span>param<span class="token operator">></span>        <span class="token operator">&lt;</span>param<span class="token operator">-</span>name<span class="token operator">></span>url<span class="token operator">&lt;</span><span class="token operator">/</span>param<span class="token operator">-</span>name<span class="token operator">></span>        <span class="token operator">&lt;</span>param<span class="token operator">-</span>value<span class="token operator">></span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxxx<span class="token operator">&lt;</span><span class="token operator">/</span>param<span class="token operator">-</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>context<span class="token operator">-</span>param<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取web.xml中的初始化参数</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span>            <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        ServletContext context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取整个web站点的初始化参数</span>        String contextInitParam <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getInitParameter</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>contextInitParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了读取web.xml中的初始化参数，还可以通过ServletContext读取对象文件。比如常见在项目中使用的xxx.properties文件。很多第三方也是用的这种方式来读取对应的配置文件</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * 读取src目录下的com.xxx.xxx包中的xxx.properties配置文件     * @param response     * @throws IOException     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readPropCfgFile2</span><span class="token punctuation">(</span>HttpServletResponse response<span class="token punctuation">)</span>            <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        InputStream in <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"/WEB-INF/classes/com/xxx/xxx/xxx.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Properties prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String driver <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String url <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String username <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String password <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取src目录下的com.xxx.xxx包中的xxx.properties配置文件："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                MessageFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>                        <span class="token string">"driver={0},url={1},username={2},password={3}"</span><span class="token punctuation">,</span>                         driver<span class="token punctuation">,</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了通过ServletContext读取资源文件，还可以通过类装载器读取资源文件。也有很多第三方是通过这样的方式读取资源文件</p><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/**     * 读取类路径下的资源文件     * @param response     * @throws IOException     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span>HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取到装载当前类的类装载器</span>        ClassLoader loader <span class="token operator">=</span> ServletContextDemo7<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//用类装载器读取src目录下的db1.properties配置文件</span>        InputStream in <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"db1.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Properties prop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        prop<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String driver <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String url <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String username <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String password <span class="token operator">=</span> prop<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用类装载器读取src目录下的db1.properties配置文件："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                MessageFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>                        <span class="token string">"driver={0},url={1},username={2},password={3}"</span><span class="token punctuation">,</span>                         driver<span class="token punctuation">,</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h1><p>上一篇讲了Servlet，提到Servlet由容器调用。拿么Web容器是干嘛的呢。</p><p>比较权威的解释：</p><blockquote><p>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。比如tomcat容器，它提供的接口严格遵守 J2EE 规范中的 WEB APPLICATION  标准。我们把遵守该标准的 WEB 服务器就叫做 J2EE 中的 WEB 容器。 <strong>这套标准就是当有客户端请求，自动调用对应的Servlet的标准</strong></p></blockquote><p>为了加强理解这里再次说明一下：</p><p>servlet没有main方法，那我们如何启动一个servlet，如何结束一个servlet，如何寻找一个servlet等等，都受控于另一个java应用，这个应用我们就称之为web容器。</p><p>比如tomcat就是这样一个容器。如果web服务器应用得到一个指向某个servlet的请求，此时服务器不是把servlet交给servlet本身，而是交给部署该servlet的容器。要有容器向servlet提供http请求和响应，而且要由容器调用servlet的方法，如doPost或者doGet。</p><p>接下来就以Tomcat为例子</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。  　　</p><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/664334-8c01fdb4c6836b4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>Tomcat服务器的启动是基于一个server.xml文件的，Tomcat启动的时候首先会启动一个Server，Server里面就会启动Service，Service里面就会启动多个Connector(连接器)。</li><li>每一个Connector（连接器）都在等待客户机的连接，当有用户使用浏览器去访问服务器上面的web资源时，首先是连接到Connector(连接器)，<strong>Connector(连接器)是不处理用户的请求的，而是将用户的请求交给一个Engine(引擎)去处理。</strong></li><li>Engine(引擎)接收到请求后就会解析用户想要访问的Host，然后将请求交给相应的Host。</li><li>Host收到请求后就会解析出用户想要访问这个Host下面的哪一个Web应用,一个web应用对应一个Context。</li></ul><p>一个简单的配置例子，<strong>对照着上面的体系结构来看</strong>：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='utf-8'?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Server</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8005<span class="token punctuation">"</span></span> <span class="token attr-name">shutdown</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SHUTDOWN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Service</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Catalina<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8080<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span>               <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span>               <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.coyote.http11.Http11Protocol<span class="token punctuation">"</span></span>               <span class="token attr-name">maxThreads</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>150<span class="token punctuation">"</span></span> <span class="token attr-name">SSLEnabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">scheme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https<span class="token punctuation">"</span></span> <span class="token attr-name">secure</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>               <span class="token attr-name">clientAuth</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name">sslProtocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TLS<span class="token punctuation">"</span></span>                <span class="token attr-name">keystoreFile</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>conf/.keystore<span class="token punctuation">"</span></span> <span class="token attr-name">keystorePass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>123456<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8009<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AJP/1.3<span class="token punctuation">"</span></span> <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8443<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Engine</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Catalina<span class="token punctuation">"</span></span> <span class="token attr-name">defaultHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span>  <span class="token attr-name">appBase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>webapps<span class="token punctuation">"</span></span>            <span class="token attr-name">unpackWARs</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">autoDeploy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.catalina.valves.AccessLogValve<span class="token punctuation">"</span></span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logs<span class="token punctuation">"</span></span>               <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost_access_log.<span class="token punctuation">"</span></span> <span class="token attr-name">suffix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.txt<span class="token punctuation">"</span></span>               <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>%h %l %u %t &amp;quot;%r&amp;quot; %s %b<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!-- host对应的根目录 --></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>www.xxx.xxx<span class="token punctuation">"</span></span> <span class="token attr-name">appBase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>F:\JavaWebApps<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 具体context对应的目录 --></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">docBase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>F:\JavaWebApps\xxxx<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Engine</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Service</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Server</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Tomcat-web-xml"><a href="#Tomcat-web-xml" class="headerlink" title="Tomcat web.xml"></a>Tomcat web.xml</h2><p>应用服务器启动时web.xml加载过程，至于这些节点在xml文件中的前后顺序没有关系，不过有些应用服务器,比如websphere就严格要求web.xml的节点顺序,否则部署不成功，所以还是最好按照web.xml标准格式写 ：</p><blockquote><p>具体的配置和加载顺序：content-param –&gt; listener –&gt; filter –&gt; servlet </p></blockquote><p>结合上面所讲的ServletConfig及ServletContext。</p><ol><li>启动WEB项目的时候,应用服务器会去读它的配置文件web.xml.读两个节点:<code>&lt;context-param&gt;&lt;/context-param&gt;</code> 和<code>&lt;listener&gt;&lt;/listener&gt;</code></li><li>紧接着,容器创建一个ServletContext(上下文),这个WEB项目所有部分都将共享这个上下文。</li><li>容器将<code>&lt;context-param&gt;&lt;/context-param&gt;</code>转化为键值对,并交给ServletContext。</li><li>容器创建<code>&lt;listener&gt;&lt;/listener&gt;</code>中的类实例,即创建监听。</li><li>在监听中会有<code>contextInitialized(ServletContextEvent args)</code>初始化方法,在这个方法中获得：<code>ServletContext = ServletContextEvent.getServletContext();  context-param的值 = ServletContext.getInitParameter(&quot;context-param的键&quot;)</code>;     </li><li>得到这个<code>context-param</code>的值之后,你就可以做一些操作了.注意,<strong>这个时候你的WEB项目还没有完全启动完成，这个动作会比所有的Servlet都要早。</strong>换句话说,这个时候,你对<context-param>中的键值做的操作,将在你的WEB项目完全启动之前被执行.如果想在项目启动之前就打开数据库,那么这里就可以在<context-param>中设置数据库的连接方式,在监听类中初始化数据库的连接,这个监听是自己写的一个类,除了初始化方法,它还有销毁方法.用于关闭应用前释放资源.比如说数据库连接的关闭。</context-param></context-param></li></ol><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>以 filter 为例，web.xml 中当然可以定义多个 filter，与 filter 相关的一个配置节是 filter-mapping，<strong>这里一定要注意，对于拥有相同 filter-name 的 filter 和 filter-mapping 配置节而言，filter-mapping 必须出现在 filter 之后，否则当解析到 filter-mapping 时，它所对应的 filter-name 还未定义</strong>。</p><p>web 容器启动时初始化每个 filter 时，是按照 filter 配置节出现的顺序来初始化的，当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的。 <strong>servlet 同 filter 类似！</strong></p><blockquote><p>比如filter 需要用到 bean ，但加载顺序是： 先加载filter 后加载spring，则filter中初始化操作中的bean为null；所以，如果过滤器中要使用到 bean，可以将spring 的加载 改成 Listener的方式 </p></blockquote><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="节点详解"><a href="#节点详解" class="headerlink" title="节点详解"></a>节点详解</h3><h4 id="web-app"><a href="#web-app" class="headerlink" title="web-app"></a>web-app</h4><p>根节点</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="context-param"><a href="#context-param" class="headerlink" title="context-param"></a><strong>context-param</strong></h4><p>用来设定web站台的环境参数。</p><p> 它包含两个子元素：</p><ul><li><p><param-name></param-name> 用来指定参数的名称</p></li><li><p><param-value></param-value> 用来设定参数值</p><p>在此设定的参数，可以在servlet中用 <code>getServletContext().getInitParameter(&quot;my_param&quot;)</code>来取得。</p><p>例子:</p></li></ul><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>log4jConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>classpath*:/log4j.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h4><p>用来设定Listener接口，它的主要子元素为：</p><ul><li><p><listener-class></listener-class> 定义Listener的类名称</p><p>例子:</p></li></ul><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>  是用来声明filter的相关设定</p><ul><li><filter-name></filter-name> 这当然就是指定filter的名字</li><li><filter-class></filter-class> 这是用来定义filter的类的名称</li><li><init-param></init-param> 用来定义参数，它有两个子元素：</li><li><param-name></param-name> 用来指定参数的名称</li><li><param-value></param-value> 用来设定参数值</li></ul><p>例子:</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>encodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>GBK<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>forceEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h4><p>来声明一个servlet的数据，主要有以下子元素：</p><ul><li><servlet-name></servlet-name> 指定servlet的名称</li><li><servlet-class></servlet-class> 指定servlet的类名称</li><li><jsp-file></jsp-file> 指定web站台中的某个JSP网页的完整路径</li><li><init-param></init-param> 用来定义参数，和前面的<init-param>差不多</init-param></li></ul><blockquote><p>同样，与<servlet></servlet>一起使用的是<servlet-mapping></servlet-mapping> 用来定义servlet所对应的URL，包含两个子元素：<servlet-name></servlet-name> 指定servlet的名称<url-pattern></url-pattern> 指定servlet所对应的URL</p></blockquote><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>DemoServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>com.test.DemoServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>DemoServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/demoServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="description"><a href="#description" class="headerlink" title="description"></a>description</h4><p>是对站台的描述</p><p> 例子：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>传道、授业、解惑<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="display-name"><a href="#display-name" class="headerlink" title="display-name"></a>display-name</h4><p>定义站台的名称<br> 例子：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>我的站点<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h4><p>icon元素包含small-icon和large-icon两个子元素.用来指定web站台中小图标和大图标的路径.<br><small-icon>/路径/smallicon.gif</small-icon> </p><p>small-icon元素应指向web站台中某个小图标的路径,大小为16 X 16 pixel,但是图象文件必须为GIF或JPEG格式,扩展名必须为:.gif或.jpg. </p><p><large-icon>/路径/largeicon-jpg</large-icon><br>large-icon元素应指向web站台中某个大图表路径,大小为32 X 32 pixel,但是图象文件必须为GIF或JPEG的格式,扩展名必须为; gif或jpg.<br>例子: </p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>icon</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>small-icon</span><span class="token punctuation">></span></span>/images/small.gif<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>small-icon</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>large-icon</span><span class="token punctuation">></span></span>/images/large.gir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>large-icon</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>icon</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="distributable"><a href="#distributable" class="headerlink" title="distributable"></a>distributable</h4><p>是指定该站台是否可分布式处理</p><h4 id="session-config"><a href="#session-config" class="headerlink" title="session-config"></a>session-config</h4><p>用来定义web站台中的session参数</p><p>包含一个子元素：<br> <session-timeout></session-timeout> 用来定义这个web站台所有session的有效期限，单位为 分钟</p><h4 id="mime-mapping"><a href="#mime-mapping" class="headerlink" title="mime-mapping"></a>mime-mapping</h4><p> 定义某一个扩展名和某一个MIME Type做对应该<br> 包含两个子元素：</p><ul><li><p><extension></extension> 扩展名的名称</p></li><li><p><mime-type></mime-type> MIME格式</p><p>例子：</p></li></ul><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mime-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>extension</span><span class="token punctuation">></span></span>doc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>extension</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mime-type</span><span class="token punctuation">></span></span>application/vnd.ms-word<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mime-type</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mime-mapping</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mime-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>extension</span><span class="token punctuation">></span></span>xls<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>extension</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mime-type</span><span class="token punctuation">></span></span>application/vnd.ms-excel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mime-type</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mime-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="error-page"><a href="#error-page" class="headerlink" title="error-page"></a>error-page</h4><p> 例子</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>500<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/message.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>400<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/message.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>403<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/message.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>404<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/message.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>502<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jsp-config"><a href="#jsp-config" class="headerlink" title="jsp-config"></a>jsp-config</h4><p>例子</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jsp-config</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib-uri</span><span class="token punctuation">></span></span>/struts-tags<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib-uri</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib-location</span><span class="token punctuation">></span></span>/WEB-INF/struts-tags.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib-location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib-uri</span><span class="token punctuation">></span></span>/struts-dojo-tags<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib-uri</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib-location</span><span class="token punctuation">></span></span>/WEB-INF/struts-dojo-tags.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib-location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib-uri</span><span class="token punctuation">></span></span>/s<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib-uri</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>taglib-location</span><span class="token punctuation">></span></span>/WEB-INF/struts-tags.tld<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib-location</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>taglib</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jsp-config</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>####welcome-file-list</p><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.htm<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">></span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="resource-ref"><a href="#resource-ref" class="headerlink" title="resource-ref"></a>resource-ref</h4><p> 定义利用JNDI取得站台可利用的资源<br> 有五个子元素：</p><ul><li><p><description></description> 资源说明</p></li><li><p><rec-ref-name></rec-ref-name> 资源名称</p></li><li><p><res-type></res-type> 资源种类</p></li><li><p><res-auth></res-auth> 资源经由Application或Container来许可</p></li><li><p><res-sharing-scope></res-sharing-scope> 资源是否可以共享，有Shareable和Unshareable两个值，默认为Shareable</p><p>比如，配置数据库连接池就可在此配置</p></li></ul><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource-ref</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>JNDI JDBC DataSource of shop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>res-ref-name</span><span class="token punctuation">></span></span>jdbc/sample_db<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>res-ref-name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>res-type</span><span class="token punctuation">></span></span>javax.sql.DataSource<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>res-type</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>res-auth</span><span class="token punctuation">></span></span>Container<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>res-auth</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource-ref</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://www.cnblogs.com/xdp-gacl/p/3734395.html" target="_blank" rel="noopener">Tomcat服务器学习和使用(一)</a></p><p><a href="http://www.cnblogs.com/xdp-gacl/category/574705.html" target="_blank" rel="noopener">JavaWeb学习总结</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 服务端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说开发中的配置</title>
      <link href="/2018/06/07/2018/6/%E8%AF%B4%E8%AF%B4%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/06/07/2018/6/%E8%AF%B4%E8%AF%B4%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>花了些时间研究了java后端开发，总体感觉起来与客户端与服务端开发存在非常多的不同。服务端所需要掌握的知识太多太多了，随随便便一个分布式就足够学个一年半载。这里简单记录一下自己对配置的理解。</p></blockquote><a id="more"></a><h1 id="配置的作用"><a href="#配置的作用" class="headerlink" title="配置的作用"></a>配置的作用</h1><blockquote><p>配置无非就是把大量的参数，放在一起便于统一管理。如果从函数调用的角度来讲，传递参数其实就是进行配置，只不过粒度太小，算不上平常所说的配置。</p></blockquote><p>配置的作用非常多，但归结一点就是传递约定好的信息或方式。小则一个应用程序的版本号，名称（iOS的plist文件），大则操作系统的网络配置（Host）、口令等。无论是大是小，配置在软件开发中都无处不在。</p><p>广义上来讲，我们所使用的操作系统就使用大量的配置文件。比如：</p><ul><li>UNIX主机下TCP/IP服务配置文件</li><li>Windows系统口令配置文件</li><li><strong>最常用还是数host文件</strong></li></ul><p>上面几种都是关于操作系统基本的配置文件，其本质和java中所用的xml，propery；iOS中的plist；node中的json是一样的。无非就是换个包装而已，只要理解到了本质，也就不难理解。</p><p>从软件开发的角度，配置完完全全可以通过运行时的来完成，为什么非要写成文件，搞一大堆的xml、json、yml？这个问题我也想了好久，比如java后端开发中，稍微大一点的项目就会遇到一大堆的配置文件非常繁琐。后面会给出自己的理解。<br><img src="https://upload-images.jianshu.io/upload_images/664334-c7bc1172859aa990.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-2c9f5c3b9c0551b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="为什么不直接用配置类？"><a href="#为什么不直接用配置类？" class="headerlink" title="为什么不直接用配置类？"></a>为什么不直接用配置类？</h1><p>文件相对于运行时的配置类最大的好处就是有利于复用、便于更新及本地化。</p><h2 id="iOS中的配置"><a href="#iOS中的配置" class="headerlink" title="iOS中的配置"></a>iOS中的配置</h2><p>在iOS开发中使用配置类的场景远远比使用配置文件的场景多。比如SDWebImage中缓存的配置：</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">SDImageCacheConfig</span> <span class="token operator">:</span> NSObject<span class="token comment" spellcheck="true">/** * Decompressing images that are downloaded and cached can improve performance but can consume lot of memory. * Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption. */</span><span class="token annotation punctuation">@property</span> <span class="token punctuation">(</span>assign<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> BOOL shouldDecompressImages<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** *  disable iCloud backup [defaults to YES] */</span><span class="token annotation punctuation">@property</span> <span class="token punctuation">(</span>assign<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> BOOL shouldDisableiCloud<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * use memory cache [defaults to YES] */</span><span class="token annotation punctuation">@property</span> <span class="token punctuation">(</span>assign<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> BOOL shouldCacheImagesInMemory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * The maximum length of time to keep an image in the cache, in seconds */</span><span class="token annotation punctuation">@property</span> <span class="token punctuation">(</span>assign<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> NSInteger maxCacheAge<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * The maximum size of the cache, in bytes. */</span><span class="token annotation punctuation">@property</span> <span class="token punctuation">(</span>assign<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> NSUInteger maxCacheSize<span class="token punctuation">;</span><span class="token annotation punctuation">@end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把对缓存的一些设置全部放在了SDImageCacheConfig配置类中，<strong>并且注明了默认是什么，这一点非常重要。</strong></p><p>这是把配置写成配置类的方式，那么可不可以换成配置文件的方式呢。肯定可以，其实在iOS开发中用来保存用户偏好设置的NSUserDefaults就是使用文件配置的方式，只不过是系统帮我们读取配置文件，然后映射为NSUserDefaults对象而已。<strong>NSUserdefaults 的本质是使用了plist存储数据，将存储在NSUserdefaults中的数据写入了一个以Bundle Identifier命名的plist中。对应的路径在沙盒中为：root/Library/Preferences/xxxx.plist</strong></p><p>就连我们平时我们所使用的xcode也使用了很多配置文件，比如Xcode中记录项目文件的<code>project.pbxproj</code>文件。只是我们开发过程中没有像java后端开发那样大量使用自定义的配置，更多的是系统帮我们做好了而已。</p><h2 id="java后端开发中的配置"><a href="#java后端开发中的配置" class="headerlink" title="java后端开发中的配置"></a>java后端开发中的配置</h2><p>java中的配置远远多于iOS中的配置。毕竟服务端所要做的东西比客户端多太多。自己总结的一套java框架图，学完这些基本就离聪明绝顶不远了。<br><img src="https://upload-images.jianshu.io/upload_images/664334-11882eb156d37fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>常见的java中需要配置的内容：</p><ul><li>数据库配置（druid）</li><li>缓存框架配置(redis，enchache)</li><li>消息队列配置（mq）</li><li>日志框架配置（log4j）</li><li>作业调度配置（quartz）</li><li>…..</li></ul><p>太多了，以至于一个大的项目单单配置文件就让人摸不着头脑。<strong>而且一般情况下都是使用xml的方式</strong>。每一个层面都可能有多个配置文件，一个层面的配置对于其他层面的配置可能存在交互等等。这样基于xml配置的java开发现象让很多人开始觉得复杂。于是后面出现了基于类配置或者说基于默认xml配置规则的Spring Boot出现。</p><p>虽然在后端开发中大部分使用xml配置，其中也有一些框架也是基于类配置的，<strong>并且即使是基于xml最终落实到代码上，也是基于类配置，只不过xml将配置本地化了而已</strong>。</p><p>一般处理过程：创建一个xxxconfig，对其需要自定义的属性进行设置，然后将配置传入主类。如果是用xml方式一般是在java类加载的时候（也就是static 代码块中）从classpath中读取相关的配置文件，如果有想匹配的配置文件就讲起内容读出来，然后设置的到对应的配置类中。</p><p>为什么客户端开发和服务端开发在配置仅仅在配置上就有如此大的不同？这里我大致总结了如下几点：</p><ol><li>客户端没有服务端那么多的模块。客户端就是一个单机应用，而服务端涉及到数据库，分布式等等。</li><li>一般情况下客户端的选择对框架的选择非常有限，比如数据库本质就sqlite。而服务端的选择各种各样，以满足不同的业务场景。</li><li>客户端大部分的配置基本上都已经被系统约定好，提供了，比如iOS中的NSUserDefault。而服务端由于各式各样的业务场景，所以更多的是需要自定义。</li></ol><p>那为什么非要基于xml，而不基于配置类呢？之前解释过一些，这里在说一点其他的。<strong>其实现在java后台开发也慢慢意识到了xml配置所带来的繁琐，所以Spring Boot显示深受青睐。至于为什么之前基于xml配置如此之多，笔者认为有如下几点</strong>：</p><ul><li>xml能存储小量数据，仅仅是存储数据。<!----></li><li>xml<strong>可以跨平台，主流各种平台都对xml有支持</strong>。</li><li>xml<strong>规范性非常强</strong>，这样就可以更好的去解释文件内的信息。</li><li>xml不适合动态语言但非常适合强类型的语言。java 处理 xml 更容易。</li><li><strong>历史问题，业界标准形成，不容易改变。</strong></li></ul><p>配置文本化后都有一个好处：<strong>文本形式方便浏览修改，方便更新配置</strong>，后期维护方便。比如在更改配置之后不用重新启动服务器，如果是写成配置类了，类的结构已经确定，需要重新启动。而用配置文件之后只需要重新读取配置文件就可以更新配置。</p>]]></content>
      
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于随机数的一些思考</title>
      <link href="/2018/05/11/2018/6/%E5%85%B3%E4%BA%8E%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2018/05/11/2018/6/%E5%85%B3%E4%BA%8E%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>现实世界随机事件随时都在发生，而计算机世界的随机又是怎样的呢？</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/664334-aa08e6c14f06e08f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><p>现实世界随机事件随时都在发生，而计算机世界的随机又是怎样的呢？</p><p>在不同领域对随机数有不同的定义。这里就从计算机的角度去理解，可以分为两种——伪随机数、真随机数。</p><h1 id="真随机数"><a href="#真随机数" class="headerlink" title="真随机数"></a>真随机数</h1><p>真随机数是非常难通过计算机得到的，而是使用物理现象才能得到。比如掷钱币、骰子、转轮、使用电子元件的噪音、核裂变等等。这样的随机数生成器叫做物理性随机数生成器，它们的缺点是技术要求比较高。</p><p>其次也可以使用专门的设备，比如热噪讯号、量子力学的效应、放射性元素的衰退辐射，或使用无法预测的现象，譬如用户按键盘的位置与速度、用户运动鼠标的路径坐标等来产生。</p><p><strong>也就是真随机只有在现实的物理世界才能得到，平时在计算机中使用的大都数都是伪随机。</strong></p><h1 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h1><p>顾名思义伪随机数其实<strong>严格来讲不是真真的随机</strong>，一般情况下在计算机中通过一定算法得到的，并且在大量的随机样本情况下是可以推算出来的；</p><p>伪随机数有一个重要的特征那就是<strong>在计算伪随机数时假如使用的开始值（也称种子）不变的话，那么伪随机数的数序也不变。</strong></p><p>伪随机数的优点是它的计算比较简单，而且只使用少数数值很难推算出计算它的算法。<strong>一般人们使用一个假的随机数，比如电脑上的时间作为计算伪随机数的开始值。</strong></p><h2 id="C语言伪随机算法"><a href="#C语言伪随机算法" class="headerlink" title="C语言伪随机算法"></a>C语言伪随机算法</h2><p>用来计算伪随机数的函数被称为随机函数，使用随机函数产生随机数的算法称为随机数生成器。具体的算法如下。这里的种子意思就是随机数的开始数值。对应到下面的代码就是<code>next</code>变量。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* 使用 ANSI C 可移植算法 */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 种子</span><span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true">// 生成伪随机数</span><span class="token punctuation">{</span>    next <span class="token operator">=</span> next <span class="token operator">*</span> <span class="token number">1103515245</span> <span class="token operator">+</span> <span class="token number">12345</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>next <span class="token operator">/</span> <span class="token number">65536</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">32768</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 修改种子</span><span class="token punctuation">{</span>    next <span class="token operator">=</span> seed<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下会用1970年元旦午夜0点到现在的秒数作为随机序列运算的初始化种子，<br><strong>事实上这种产生随机种子的方法有一定的缺陷性。假设在一台计算机上运行批量执行程序，程序执行的时间是几个ms，那么几个相邻程序的seed是一样的，每次调用随机数生成函数的结果也是一样的</strong>。</p><blockquote><p>因为系统时间time是按照秒级来计算的，而程序执行的时间是毫秒级，倘若在一秒内执行多次程序，必然导致产生的随机种子相同。</p></blockquote><p><strong>这里有一个用系统时间作为随机种子的可被破解的例子：<a href="http://www.inbreak.net/archives/349" target="_blank" rel="noopener">利用系统时间可预测破解java随机数</a>，有兴趣的可以看一看</strong></p><p>【 一些注意事项】：由于伪随机数不是真的随机数，在有些方面它们不能被使用，例如在密码学中使用伪随机数要小心，因为其可计算性是一个可以攻击的地方。伪随机数的一个特别大的优点是它们的计算不需要外部的特殊硬件的支持，因此在计算机科学中伪随机数依然被使用。</p><h1 id="随机数生成算法介绍"><a href="#随机数生成算法介绍" class="headerlink" title="随机数生成算法介绍"></a>随机数生成算法介绍</h1><h2 id="线性同余方法"><a href="#线性同余方法" class="headerlink" title="线性同余方法"></a>线性同余方法</h2><p>线性同余方法（LCG）它是根据递归公式：<br><img src="https://upload-images.jianshu.io/upload_images/664334-f39acb67409f4c19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>产生随机数的方法。<strong>线性同余中的线性，是指“线性”表示方程中 A 的次数是一次，mod 取余运算符则体现了“同余”这一数学概念。</strong></p><p>其中A、B、M是产生器设定的常数。LCG周期最大为M，但大部分时候都会小于M。A、B、M分别称做乘数、增量和模数。使用线性同余生成随机数的方法速度快，但对乘数、增量和模数的选取有一定的要求：</p><p>要令LCG达到最大周期，应符合以下条件：</p><ol><li>B,M互质；</li><li>M的所有质因子的积能整除A-1；</li><li>若M是4的倍数，A-1也是；</li><li>A,B,N_0都比M小；</li><li>A,B是正整数。</li></ol><p>出了上面的条件以外还有以下：</p><ol><li>多次使用线性同余公式产生的序列应该看起来是随机的，不循环的；</li><li>乘数/增量与模数互质；</li><li>这个函数能够产生一个完整周期内的所有随机数，由模数控制；</li></ol><p>可以看到上面介绍C语言随机数生成算法就是线性同余方法。</p><p>从网上搜集了一些式子：</p><ul><li><code>seed    = (seed * 9301 + 49297) % 233280</code></li><li><code>seed = (seed * 31 + 13) % ((1 &lt;&lt; 15) - 1);</code></li></ul><p>【注】：因为通过线性同余方法构建的伪随机数生成器的内部状态可以轻易地由其输出演算得知，所以此种伪随机数生成器属于统计学伪随机数生成器。设计密码学的应用必须至少使用密码学安全伪随机数生成器，故需要避免由线性同余方法获得的随机数在密码学中的应用。</p><h3 id="线性同余实现"><a href="#线性同余实现" class="headerlink" title="线性同余实现"></a>线性同余实现</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认使用系统时间为种子</span><span class="token comment" spellcheck="true">// time(NULL) 返回从1970年元旦午夜0点到现在的秒数</span><span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    seed <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用了一种线性同余法，得到的随机数最大为(2^15-1),29为质数中的一个</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    seed <span class="token operator">=</span> <span class="token punctuation">(</span>seed <span class="token operator">*</span> <span class="token number">31</span> <span class="token operator">+</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> seed<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高级的随机数生成器"><a href="#高级的随机数生成器" class="headerlink" title="高级的随机数生成器"></a>高级的随机数生成器</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123456789</span><span class="token punctuation">,</span>                   y <span class="token operator">=</span> <span class="token number">362436000</span><span class="token punctuation">,</span>                   z <span class="token operator">=</span> <span class="token number">521288629</span><span class="token punctuation">,</span>                   c <span class="token operator">=</span> <span class="token number">7654321</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Seed variables */</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">KISS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> t<span class="token punctuation">,</span> A <span class="token operator">=</span> <span class="token number">698769069ULL</span><span class="token punctuation">;</span>      x <span class="token operator">=</span> <span class="token number">69069</span><span class="token operator">*</span>x<span class="token operator">+</span><span class="token number">12345</span><span class="token punctuation">;</span>      y <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span>y<span class="token operator">&lt;&lt;</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     y <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span>y<span class="token operator">>></span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     y <span class="token operator">^</span><span class="token operator">=</span> <span class="token punctuation">(</span>y<span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      t <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span>z <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">>></span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    z <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token operator">+</span>z<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个生成器只是把“线性同余”，“移位轮转”和“带记忆乘法”这3种基本的随机数发生法一起用，便获得很好的效果。其中<strong>移位轮转</strong>在很多加密算法中经常用到。</p><h2 id="乘同余法"><a href="#乘同余法" class="headerlink" title="乘同余法"></a>乘同余法</h2><p>乘同余法和线性同余法非常相似。对比一下二者的公式</p><p>线性同余：<br><img src="https://upload-images.jianshu.io/upload_images/664334-f39acb67409f4c19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>乘同余法：</p><pre><code>Xn+1=Lamda*Xn(mod M)Rn+1=Xn/M</code></pre><p>数选取是有一定理论基础的，否则所产生的随机数的周期将较小，相关性会较大。经过前人检验的两组性能较好的素数取模乘同余法迭代式的系数为:</p><pre><code>Lamda=5^5,M=2^35-31Lamda=7^5,M=2^31-1</code></pre><p>代码这里就不贴了</p><h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>算法：<br><img src="media/15259221655301/15259350089793.jpg" alt></p><p>换一种方式十进制的表达：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-71884d9250df88ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>对比上面可以写成另外一种形式。</p><pre><code>#define S 2  Xn+1=(Xn^2/10^s)(mod 10^2s) Rn+1=Xn+1/10^2s这里的s代表的就是位数其中，Xn+1是迭代算子，而 Rn+1 则是每次需要产生的随机数。 第一个式子表示的是将 Xn 平方后右移 s 位，并截右端的 2s 位。 而第二个式子则是将截尾后的数字再压缩 2s 倍，显然 :0=&lt;Rn+1&lt;=1。迭代取中法有一个显著的不良特性就是它比较容易退化成 0。</code></pre><p>将上面的公式转为代码表示：<code>x=(int)(x*x/pow(10.0,(m/2)))%(int)pow(10.0,m);</code></p><h3 id="平法取中法的简单实现"><a href="#平法取中法的简单实现" class="headerlink" title="平法取中法的简单实现"></a>平法取中法的简单实现</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">randomTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> m<span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input a int number"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"error! enter again:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">itoa</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//作用是将数字转为字符串，并且制定转换之后的进制</span>    m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">/</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>m<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x%d=%d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> x<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">线性同余方法</a><br><a href="https://www.cnblogs.com/xkfz007/articles/2487510.html" target="_blank" rel="noopener">随机数产生原理及应用</a><br><a href="https://blog.csdn.net/liyuefeilong/article/details/47688223" target="_blank" rel="noopener">使用线性同余法生成伪随机数/序列（C++实现）</a><br><a href="https://www.cnblogs.com/deng-cc/p/8064481.html" target="_blank" rel="noopener">SecureRandom</a></p>]]></content>
      
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》读书笔记——内存</title>
      <link href="/2018/04/10/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98.md/"/>
      <url>/2018/04/10/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98.md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面几篇文章都是关于静态库，动态库相关的介绍。平时开发中接触并不是很多。从这篇开始进入和工作中关系比较大的部分，库和运行库。第一篇就从内存开始介绍。</p></blockquote><p>本文导图<br><img src="https://upload-images.jianshu.io/upload_images/664334-9dd5b635a2e48c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>现代应用程序都运行在一个内存空间里面，在32系统里面这个内存空间拥有4GB的寻址能力。16位时代是用段地址加偏移地址的寻址模式用尽不用了。<strong>如今的应用程序直接使用32位的地址进行寻址。这种方式叫做平坦的内存模型。整个内存是一个统一的地址空间，用户可以使用一个32位指针访问任何一个内存位置。</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x12345678</span><span class="token punctuation">;</span><span class="token operator">++</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如上可以直接读写指定内存的数据。但是真真的情况下并不是这么平坦的。因为大多数操作系统会把内存空间的一部分给内核使用，应用程序时无法访问的，对应的内存空间也就叫做内核空间。相对内核空间，应用程序能够访问到的就是永恒空间。一般而言，在用户空间，很多区域有特殊含义。<strong>一个应用程序有如下默认的区域：</strong></p><ul><li>栈：用于维护函数调用的上下文，通常是在用户空间高地址除分配，有数兆字节大小</li><li>堆：堆用来容纳应用程序动态分配的内存区域。比如使用malloc、new分配内存的时候。堆通常位于栈的下方（低地址方向），并且堆一般没有统一的区域，而且范围也比栈大很多。</li><li>可执行文件映像：存储可执行文件在内存中的映像。之前介绍过，由装载器在装载的时候将可执行文件的内存读取或映射到这里。</li><li>保留区：<strong>不是一个单一的内存区域，而是对内存中受保护而禁止访问内存区域的总称。</strong>比如大多数操作系统绩效的地址通常不允许访问比如NULL,因为0地址正常情况不可能有有效的可访问数据。</li></ul><p>如下图是Linux一个进程的内存布局：<br><img src="https://upload-images.jianshu.io/upload_images/664334-ab834f17dfdb4832.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>注意还有一个动态链接库映射区，这个区域用于映射装载的动态链接库，比如在Linux下，如果有其他共享库链接，那么系统就会从0x4000 0000开始地址分配。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈最大的特点就是先进后出。在数据结构中，栈被定义为一个特殊的容器，可以压栈和出栈。在计算机系统中，栈则是一个具有数据结构中栈的属性的一个动态内存区域。</p><p>栈总是向下增长的，栈顶由称为esp（有些也叫sp）寄存器定位。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7d4dfac34858220e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><strong>栈保存了一个函数调用所需要的维护信息，被称作为堆栈帧或者活动记录，堆栈帧一般有如下内容：</strong></p><ul><li>函数的返回地址和参数</li><li>临时变量，包括函数的非晶体局部变量及编译器自动生成的其他临时变量</li><li>保存的上下文，包括在函数调用前后保持不变的寄存器</li></ul><p>在i386中，栈帧用ebp和esp这链两个寄存器划定范围。<strong>esp指向栈顶，ebp指向栈帧的一个固定位置，ebp又叫做帧指针。</strong></p><p>比如：<br><img src="https://upload-images.jianshu.io/upload_images/664334-e5a7d38c070f5837.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在参数之后的数据就是函数的活动记录，ebp固定在其中一个位置，<strong>ebp不会随着函数的执行变化而变化，esp指向栈顶，会随着函数的执行变化而变化。</strong>ebp用来定位函数活动记录的各个数据。</p><p>ebp之前就是函数返回地址（ebp-4），再往前就是压入栈的参数 ，地址分配是ebp-8、ebp-12，根据参数大小不同而定。</p><p><strong>ebp指向的数据是调用函数前的ebp的值，这样函数返回的时候ebp可以通过这个值恢复到调用前的值。</strong></p><p>i386函数调用过程：</p><ul><li>把所有或者一部分参数压入栈中，如果有些参数没有入栈则使用特定的寄存器保存。——参数</li><li>把当前指令的下一条指令地址压入栈中。——返回地址</li><li>跳转到函数体执行——上一步和这一步由指令call一起执行</li><li>push ebp；将ebp压入栈中——old ebp</li><li>mov ebp,esp ebp =esp——这个时候ebp指向栈顶，恰好这个时候栈顶就是old ebp</li><li>sub esp,xxx——在栈上分配xxx字节的临时空间</li><li>push xxx——如果有必要，保存名为xxx寄存器的内容</li><li>pop xxx——将栈顶数据恢复到xxx寄存器</li><li>mov esp,ebp——恢复esp，回收栈局部变量空间</li><li>pop ebp——从栈中恢复保存的ebp的值</li><li>ret ——从栈中取回返回地址，并跳转到该位置。</li></ul><p>一个例子：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-373450b10fb866af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7243e94543a6f357.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="调用惯例（一种调用方和被调用的约定）"><a href="#调用惯例（一种调用方和被调用的约定）" class="headerlink" title="调用惯例（一种调用方和被调用的约定）"></a>调用惯例（一种调用方和被调用的约定）</h2><p>如果函数调用方决定利用寄存器传递参数，而函数本身却以栈的方式传递，那么函数无法获取正确的参数。<strong>调用方和被调用方对于函数如何调用有一个明确的约定，只有双方遵守同样的约定，函数才能被正确调用，这样的约定被称作调用惯例。</strong></p><ul><li>参数传递顺序和方式</li><li>栈的维护方式</li><li>名字修饰的策略</li></ul><p>c语言中使用的cdel惯例：<br><img src="https://upload-images.jianshu.io/upload_images/664334-6d292e156b7fdb1b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>看一个例子：<br><img src="https://upload-images.jianshu.io/upload_images/664334-004130ffdc8acf7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-28073132a9711564.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>虚线表示指令执行后的栈状态</li><li>实线表示程序的跳转状态</li></ul><blockquote><p>最好按照执行过程走一遍，弄清楚整个流程。</p></blockquote><h2 id="函数返回值传递"><a href="#函数返回值传递" class="headerlink" title="函数返回值传递"></a>函数返回值传递</h2><p>函数返回值存储在eax中，返回后函数的调用方再读取eax。但是exa只有4个字节，那么如何返回大数据的返回值呢。</p><p>几乎所有的调用惯例都是采用eax和edx联合返回的方式进行。exa存储低1-4字节，edx存储高1-4字节。</p><p><strong>可以通过反汇编来分析eax和edx</strong></p><p>源代码：<br><img src="https://upload-images.jianshu.io/upload_images/664334-c7834aba91a1f0be.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>分析结果:<br><img src="https://upload-images.jianshu.io/upload_images/664334-d9074b7e1740d3ed.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>如果返回值的尺寸太大，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值的对象会被拷贝两次，所以不到万不得已不要轻易返回大尺寸的对象。</p></blockquote><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆的内存管理比栈更为复杂，在任意时刻程序都可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存。</p><p>栈在函数返回时数据就会被清空，所以无法将数据传递至函数外部，而全局变量没有办法动态产生，只能在编译的时候定义，所以堆是唯一的选择。</p><p>堆是一块巨大的空间，占有虚拟内存很大一部分。程序可以在堆上主动申请一块连续的内存，直到程序主动放弃。</p><pre><code>int main(){  char* p=(char *)malloc(1000);  //p指针指向1000大小的数组  free(p);}</code></pre><p>malloc一种简单的实现是通过操作系统内核去完成的，把进程的内存管理给操作系统内核，系统提供一个系统调用。但是这样性能比较差，因为程序申请释放堆的操作比较频繁，每次都需要在用户太和内核态切换会消耗非常大的开销。<strong>比较好的做法就是把程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，往往是通过运行库来管理的。</strong></p><p>运行库充当的而是像操作系统批发一块较大堆空间角色，然后零售给程序使用。当全部使用完或者程序有大量内存需求的时候，运行库再向操作系统进货。<strong>通过堆分配算法来保证分配的内存不会出现冲突。</strong></p><h2 id="Linux进程堆管理"><a href="#Linux进程堆管理" class="headerlink" title="Linux进程堆管理"></a>Linux进程堆管理</h2><p>Linux 提供了两种堆空间的分配方式（两种系统调用），一种是brk系统调用，一种是mmap系统调用。brk原型<code>int brk（void* end_data_segment）</code></p><h3 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h3><p>brk作用实际上就是设置进程数据段的结束地址，扩大 或者缩小数据端，如果数据段结束地址向高地址移动那么扩大的部分就可以被使用。另一个和brk类似的是sbrk，只不过sbrk传入的是需要增加空间的大小（负数就是减小），返回时值数据段的结束为止，其实就是对brk的一次包装。</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>作用是向操作系统申请一段虚拟地址空间，这块虚拟地址空间可以映射到某个文件，当不再映射到某个文件的时候，又叫这个空间为匿名空间——虚拟内存和磁盘交换</p><p>声明如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-2d1c2e0097f677ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>start</td><td>申请空间的起始地址</td></tr><tr><td>length</td><td>申请空间的大小，和start决定虚拟空间</td></tr><tr><td>prot</td><td>设置申请空间的权限，可读、可写、可执行</td></tr><tr><td>flags</td><td>映射类型，比如文件映射、匿名空间等</td></tr><tr><td>fd</td><td>文件描述符</td></tr><tr><td>offset</td><td>文件偏移</td></tr></tbody></table><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>glibc中是通过malloc申请空间的，小于128kb的请求来讲会在现有的堆空间里面，安装堆分配算法分配一块空间并返回；如果大于128kb的请求会通过mmap申请一块匿名空间，然后在匿名空间中为用户分配空间。</p><p><strong>申请空间的其实地址和代销都必须是系统页大小的整数倍。所以对于字节很小的请求用mmap的话，会非常浪费。</strong></p><h1 id="Windows进程堆管理"><a href="#Windows进程堆管理" class="headerlink" title="Windows进程堆管理"></a>Windows进程堆管理</h1><p>关于Windows的内容这里暂时先省略，有感兴趣的同学可以自己去看一看。</p><h1 id="值得注意的几个问题"><a href="#值得注意的几个问题" class="headerlink" title="值得注意的几个问题"></a>值得注意的几个问题</h1><ul><li>一个堆里面的空间，如果被多次释放，那么会在重复释放的时候产生错误</li><li>调用malloc首先会从系统分配给应用功能的堆里面去取，如果不够用才会通过系统调用再申请空间</li><li>malloc申请的空间在进程结束后都不会存在了，不仅内存如此。凡是和进程相关的资源，比如地址空间，物理内存，打开的文件，网络链接等都会被系统回收</li><li>malloc申请的空间在虚拟空间是连续的，在对应的物理空间不一定连续</li></ul><h1 id="堆分配算法"><a href="#堆分配算法" class="headerlink" title="堆分配算法"></a>堆分配算法</h1><p>如何管理一大块连续的内存空间，能够按照需求 分配和释放，这就是堆分配算法。堆分配算法有很多种，这里介绍简单的几种</p><h2 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h2><p><strong>空闲链表就是把堆中各个空闲的块通过链表的方式联系起来，当前用申请一块空间的时候 ，可以遍历整个链表，直到找到合适大小的块，并将它拆分，当用户释放空间的时候将它合并到空闲链表中。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-8d39ad58f8abeb65.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当找到了足够容纳请求的一个空闲快，会把块分为两个部分，一部分为程序申请的，一部分是没有用到剩下的的（申请的和块大小不一定完全一样）。下图表示申请了一块和空闲块2相等堆后的状态<br><img src="https://upload-images.jianshu.io/upload_images/664334-d71575da3e982f3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在释放的时候，需要知道这个块的大小，那就在后面多加4个字节，用于存储分配的大小。这样在释放的时候就知道大小了。</p><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p><strong>核心思想就是把整个堆分为大量的块，每个块的大小相同，当用户申请的时候，总是分配给整数个块给用户。第一个块称为分配区域的头，其余的我主体。那么所有的块只有三种状态头（H）、主体（B）、空闲（F）。所有可用两个二进制就能表示出来。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7e41f2af52e60efc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>其中11表示H，10表示主体，00表示空闲<br>如上图，这个堆分配3个片内存，分别有2、4、1块。对应的位图是</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-0a65a2719831c224.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>速度快：整个堆空闲信息存储在一个数组内，隐藏访问数组时cache容易命中。</li><li>稳定性好</li><li>快不需要额外的信息</li><li>但是分配内存的时候容易造成随便，比如分配300字节，实际分配了3个快，也就是384.</li></ul><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>上面两种是最为基本的。被分配对象大小是较为固定的几个值。对象池是一个对于这种场景更为高效的算法。</p><p>思路：如果一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，没次请求的时候只需要找到以小块就可以了。</p><p><strong>核心在于与上面两种的区别是假定每次请求的都是一个固定的大小，因此实现起来容易。</strong></p><p>实际中堆分配算法往往是结合起来的，比如glilbc，对于64字节空念的申请，采用的是类似于对象池的方式，对于大于512字节的采用最佳适配算法，对于大于128KB的，会直接使用mmap机制直接向操作系统申请。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这一节总体看来不是特别复杂，因为这一层平时接触比较多。相对于编译连接，静态、动态库之类的要简单很多。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》读书笔记——可执行文件的装载与进程</title>
      <link href="/2018/04/07/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
      <url>/2018/04/07/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>中间跳过了Winods PE/COFF这一节，以及最后Windows内核装载也会省略掉。因为我们主要面向的Mac、Linux。这一节介绍可执行文件的装载与进程。</p></blockquote><p>本文导图<br><img src="https://upload-images.jianshu.io/upload_images/664334-c19a92ae3268d252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><h1 id="进程虚拟地址（操作系统讲得比较多）"><a href="#进程虚拟地址（操作系统讲得比较多）" class="headerlink" title="进程虚拟地址（操作系统讲得比较多）"></a>进程虚拟地址（操作系统讲得比较多）</h1><p>程序（可执行文件）是一个静态的概念，不知是一些预先编译好的指令和数据集合的一个文件；而进程是一个动态的概念，它是程序运行时的一个过程。一个比方：把程序与进程的概念跟厨房做菜比较</p><ul><li>程序就是菜谱</li><li>CPU就是人</li><li>厨具就是其他硬件</li><li>整个炒菜就是一个进程</li></ul><blockquote><p><strong>计算机按此程序指令把数据加工成输出数据，就像菜谱指导人把原料做成菜肴一样</strong></p></blockquote><p><strong>每个程序被运行起来以后，它将拥有独立的虚拟地址空间</strong>。从程序角度来讲，C语言程序中指针所占用的空间来计算虚拟地址空间位数大小。一般来将，C语言指针大小与虚拟空间的位数相同，如32位平台，指针就是32位，既4字节。</p><p>进程只能使用那些操作系统分配给地址空间，如果访问了未经许可的空间，那么操作系统就会捕获这些访问，将进程这种访问视为非法访问，并强制结束进程。</p><p>如32位中，整个4GB被划分为两个部分，从地址0xC000 0000到0xFFFF FFFF共1GB。剩下的从0x0000 0000地址到0xBFFF FFFF共3GB空间都是给进程用的，其实这3GB还要减去一些物理设备的RAM大小。</p><h2 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h2><p>32位CPU最大的寻址能力是0到4GB；Intel1995年就开始采用36位的物理地址，也就是可以访问64GB的物理内存，<strong>并且修改了页映射方式，使得新的映射方式可以访问到更多的物理内存，这种地址扩展方式叫做PAE（Physical Address Extensio）。</strong></p><p>虽然扩展了物理地址空间，但是对于普通的应用程序而言感觉不到它的存在，因为操作系统会处理好映射关系。操作系统提供一个窗口映射的方法，把额外的内存映射到进程地址空间中来。</p><h1 id="装载方式"><a href="#装载方式" class="headerlink" title="装载方式"></a>装载方式</h1><p>静态装载，也就是把程序所有的数据和指令装载到内存中。但是很浪费资源。因为程序运行有局部性原理，可以吧最常用的部分驻留在内存中，将不太常用的数据存在磁盘中。——虚拟内存</p><h2 id="覆盖装入"><a href="#覆盖装入" class="headerlink" title="覆盖装入"></a>覆盖装入</h2><p>以一个程序为单位进行内存的换入换出。详细内容直接去看操作系统。</p><h2 id="页映射方式"><a href="#页映射方式" class="headerlink" title="页映射方式"></a>页映射方式</h2><p>将换入换出的粒度变得更小，以一页的大小为单位进程换入换出。</p><p>一个列子：<br><img src="https://upload-images.jianshu.io/upload_images/664334-5c6ea3bdba13cd94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>程序刚刚执行的入口是P0，这时装载挂你器发现P0不在内存中，于是将F0分配给P0，并且将P0内容装载到F0，运行一段时候后发现需要用到P5，于是装载器将P5装入F1，依次类推当程序需要用到P3和P6的时候，分别被载入到F2，F3中。——有点类似懒加载</p><p>如果程序只需要这4个页，那么程序就能够一直运行下去，但是，如果程序要访问P4，那么必须舍弃4个内存页其中的一个来装载P4。<strong>至于选择哪一个页，可以根据算法选择。比如先进先出，LUR(最少使用算法）</strong></p><blockquote><p>现代的操作系统都是按照这样的方式装载可执行文件。</p></blockquote><h1 id="操作系统角度理解可执行文件的装载"><a href="#操作系统角度理解可执行文件的装载" class="headerlink" title="操作系统角度理解可执行文件的装载"></a>操作系统角度理解可执行文件的装载</h1><p>如上面所示，程序使用物理地址直接操作，每次页被载入时都需要重定位。在虚拟内存中现代的硬件MMU（内存管理单元）提供了地址转换功能，有了硬件地址转换和页映射机制，可执行文件加载动态加载方式和静态加载有非常大的不同。</p><h2 id="进程的建立（三步）"><a href="#进程的建立（三步）" class="headerlink" title="进程的建立（三步）"></a>进程的建立（三步）</h2><p>从操作系统的角度来讲，<strong>一个进程最关键的特征就是它有独立的虚拟地址空间，因此有别于其他进程</strong>。</p><p>创建一个进程，装载之后然后执行需要下面三个步骤：</p><ul><li>创建一个独立的虚拟地址空间：创建映射函数所需要的相应数据结构，在Linux下，创建虚拟地址实际上只是分配了一个页目录，还没有页映射，<strong>映射关系等到后面程序发生页错误的时候在设置</strong>。</li><li>读取可执行文件头，<strong>建立虚拟地址与可执行文件的映射关</strong>系：上一步是页映射关系函数时虚拟地址到物理地址的映射，这一步是虚拟地址与可执行文件的映射。<strong>当程序执行发生页错误的时候，操作系统将从物理内存中分配一个物理页，然后将该<code>缺页</code>从磁盘中读取到内存中，在设置缺页的虚拟页和物理页的映射关系。——当操作系统捕获到缺页错误的时候，知道当前程序所需要的页在可执行文件哪一个位置，这就是虚拟空间与可执行文件映射关系。</strong></li><li>将CPU的指令寄存器设置成可执行文件入口地址，启动运行：操作系统通过设置CPU指令的寄存器将控制权交给进程，由此进程开始执行。ELF文件头中保存了入口地址。</li></ul><p>现在对第二个步骤说明一下。假设现在EFL文件有一个代码段<code>.text</code>，虚拟地址是0x0804 8000，文件大小为0x00021，对齐为0x1000(4096，也就是一个虚拟页的大小）。<strong>因为该.text段不到一个页，考虑到对齐该段占用一个段，所以可执行完一旦被装载，映射关系如下：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-1713b9149cc6fff8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这种映射关系只是保存在操作系统内部的一个数据结构，Linux将进程虚拟空间中的一段叫做虚拟内存区域（VMA）——一种数据结构.</p><h2 id="页错误（懒加载的方式）"><a href="#页错误（懒加载的方式）" class="headerlink" title="页错误（懒加载的方式）"></a>页错误（懒加载的方式）</h2><p>上面步骤执行完之后可执行文件的指令并没有被装载到内存中，只是通过<strong>可执行文件头部的信息建立可执行文件和进程虚拟内存之间的映射关系而已。也就是先占个位置。</strong></p><p>具体流程：如上面的例子，程序入口地址为0x08048000，刚好是<code>.text</code>段的起始地址，当CPU执行这个地址的指令时，发现页面0x0804 8000 到 0x0804 9000 是个空页，也是认为这个是页错误，CPU将控制权给操作系统，操作系统有专门处理页错误的例程。<strong>这个时候操作系统将会查询刚才第二步中建立的数据结构（映射关系），找到空白页所在VMA，计算出相应页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后再把控制权给进程，进程从刚才的页错误重新执行。</strong>——遇到错误页——》控制区给操作系统——》确定映射关系——》控制权交给进程——》从错误页重新执行</p><blockquote><p>也就是<strong>可执行文件和虚拟内存建立先建立映射关系</strong>，然后在发生错误页的时候根据之前建立映射的数据结构<strong>确定物理页与虚拟内存的映射关系</strong>。</p></blockquote><p>随着进程的执行，错误页不断产生，操作系统也会为进程分配相应的物理页来满足进程的执行需求。简单来讲如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/664334-7e46ee0a22fc1fda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="进程虚拟内存分布（合并）"><a href="#进程虚拟内存分布（合并）" class="headerlink" title="进程虚拟内存分布（合并）"></a>进程虚拟内存分布（合并）</h1><h2 id="ELF文件链接视图和执行视图"><a href="#ELF文件链接视图和执行视图" class="headerlink" title="ELF文件链接视图和执行视图"></a>ELF文件链接视图和执行视图</h2><p>上面的例子中是以一个<code>.text</code>为例，然后被操作系统装载到进程空间，对应一个VMA。但是一般可执行文件由很多段，就会产生空间浪费。<strong>因为ELF文件映射到VMA中是以页长为单位的，每个段映射之后的长度都是系统页长的整数倍，不足的就会补足多用的部分，造成空间浪费。</strong></p><p>最终是通过合并来解决上面的问题。操作系统并不关心实际各个段包含的内容，只关心一些跟装载相关的问题，比如各个段的读写权限等。段可以分为：</p><ul><li>以代码段为代表的可读可执行段</li><li>以数据段、BBS段为代表的可读可写段</li><li>以只读数据段为代表的权限为只读的段。</li></ul><p><strong>对于相同权限的段，把它们合并到一起当做一个段进行映射。——合并</strong></p><p>如下图所示如果<code>.text</code>段为4097<code>.init</code>段为512。那么这两个段就需要三个页大小。如果把它们合并只需要两个页大小。<br><img src="https://upload-images.jianshu.io/upload_images/664334-980e9094864d900e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="Segment（合并段的称号）"><a href="#Segment（合并段的称号）" class="headerlink" title="Segment（合并段的称号）"></a>Segment（合并段的称号）</h2><blockquote><p>ELF可执行文中引入了一个概念叫做<code>Segment</code>，一个Segment包含一个或多个属性类型的Section。<strong>上面的例子中如果将<code>.text</code>和<code>.init</code>段合并在一起看作一个segment，那么装载的时候就可以将他们看作一个整体一起映射——也就是映射以后在进程的虚拟地址空间只有一个相对应的VMA。可以减少页面内部碎片，节省内存空间。</strong></p></blockquote><p>这里可能把Segment和Section弄混了。</p><ul><li>Segment是从装载的角度重新划分了ELF的各个段</li><li>目标文件链接成可执行文件的时候，<strong>链接器会把相同权限相同的段分在同一个空间，如可读可执行的段放在一起（代码段），可读可写放在一起（数据段），把这些属性相似的、又连在一起的段叫做segment</strong></li><li>系统按照Segmen而不是Section来映射可执行文件。</li></ul><blockquote><p>也就是Section适用于目标文件，Segment适用于可执行文件。</p></blockquote><p>一个列子：<br><img src="https://upload-images.jianshu.io/upload_images/664334-92620285ed1794e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-0b99b5a01455cf92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-54a1c324c1a69bb5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以使用readelf命令查看ELFD额segment，类比之前的section属性结构，相应的segment的结构叫做程序头，<strong>描述了ELF文件改如何被操作系统映射到进程的虚拟空间中。</strong></p><p>根据上面的图，这个可执行文件最终有5个segment。目前只关心加载相关的Load类型的Segment，只有它是被需要映射的。<br><img src="https://upload-images.jianshu.io/upload_images/664334-9772adedbf9f3c06.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>可执行文件重新被换房了三个部分，一些短被归入了可读可执行的，统一被映射到VMA0；可读可写的映射到了VMA1；还有一部分段在程序装载的时候没有被映射，比如一些调试信息和字符串表等，这些段在程序执行时没有作用，所以不需要映射。——所有相同的section都被归类到了一个segment中，映射到同一个VMA</strong></p><p>在ELF的时候，段指的是segment，其他情况都是值section。</p><p>ELF可执行文件有一个专门的数据结构叫做程序头用来保存Segment信息，<strong>因为目标文件不需要装载所以没有程序头，动态库和ELF可执行文件都有。</strong>类似于段表，程序头同样是一个结构体数组。——对整个可执行文的segment的说明</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-6dc4b7fcd4b65959.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>各个字段的含义如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-0e1c9b627ca41167.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><p>堆和栈在进程的虚拟空间同样是以VMA的形式存在，分别都有一个对应的VMA。Linux下可以使用<code>/proc</code>来查看进程的而虚拟空间分别。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-2d0e2f63ba9119ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>解释：可以看到该进程有5个VMA，只有前两个被映射到了可执行文件宏的两个segment，另外三个没有映射，这三个叫做匿名虚拟内存区域。<strong>可以看到还有两个区域分别是heap和stack大小分别是140kb，88kb，这两个区域在所有进程中都存在</strong>。</p><p>每个线程都有属于自己的堆栈，对于单线程的程序来讲，这个VMA堆栈就全归它使用。</p><p>操作系统通过给进程空间划分一个VMA来挂你进程的虚拟空间，将相同权限、有相同映射文件的合成一个VMA。一个进程基本上有如下几种VMA:</p><ul><li>代码VMA，只读、可执行，有映射文件</li><li>数据VMA，可读可写、可执行，有映射文件</li><li>堆VMA，可读可行、可执行，无映射文件，匿名，<strong>可向上扩展</strong></li><li>栈VMA，可读可行、不可执行，无映射文件，匿名，<strong>可向下扩展</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/664334-4ba6f01f0bcf973b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h2><p>这里的段值Segment。前面讲过装载过程是通过虚拟内存额页映射机制完成的，也是映射的最小单位，大小是4096。所以映射的物理内存和虚拟内存都徐亚是4096的整数倍。<strong>由于长度和起始地址的显示，应该尽可能的优化空间和地址安排，节省空间。</strong></p><p>假设现在一个ELF可执行文件有三个段，SEG0，SEG1，SEG2，长度和偏移如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-92fc1093d2e16107.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>每个段的长度都不是页长度的整数倍，一种简单的思路就是把每个段分开映射但是会导致非常多内存碎片的，因为长度不足4096的需要补足4096。<br><img src="https://upload-images.jianshu.io/upload_images/664334-2042a82b16ce8606.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-d57524b0aa171b9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在UNIX中，采用的是让各个段接壤部分共享一个物理页面，然后将该物理页面分别映射两次，比如SGE0和SGE1接壤的那个物理页，系统将它们映射两份到虚拟地址空间。UNIX中系统将ELF的文件头也看做是系统的一个段（可以从下面的图中看到），也会映射到虚拟地址空间，这样进程中的某一段区域就是整个ELF文件的镜像了，这就操作ELF文件头就可以直接读写内存的来实现操作。</p><p><strong>ELF文件从开始到某个点结束也4096位单位划分为若干个块，每个块单独装载到物理内存中，如果位于段中间的块，就会被映射两次。</strong><br><img src="https://upload-images.jianshu.io/upload_images/664334-09d84eec72c31306.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-b9530a162d2f303f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>这样内次空间就得到了充分的利用，上面例子看出本来用到5个物理页，现在只需要3个。<strong>一个极端情况，如果文件头、代码段、数据段加起来都没有4096那么只需要一个物理页就够了。</strong></p><h2 id="进程栈初始化"><a href="#进程栈初始化" class="headerlink" title="进程栈初始化"></a>进程栈初始化</h2><p>进程刚开始启动的时候，需要知道一些进程运行的环境，<strong>最基本的就是系统环境变量和进程运行参数</strong>。常见的做法就是操作系统在进程启动前将这些信息提前保存到虚拟空间的栈中（也就是VMA中的Stack VMA）。——系统环境变量，进程运行参数</p><p>假设有如下环境变量：</p><pre><code>HOME=/home/userPATH=/usr/bin</code></pre><p>假设堆栈段底部地址为0xBF80 2000，那么进程初始化后的堆栈就如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/664334-afcef4076888f818.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>栈顶寄存器esp指向的位置是初始化以后堆栈的顶部，最前面4个字节表示命令行参数的数量。</li><li>对应这个例子是<code>prog 123</code></li><li>紧跟着的就是分布指向这两个参数字符串的指针，后面跟了一个0</li><li>紧接着是两个指向环境变量的字符串指针，分别指向字符串<code>HOME=/home/user</code>和<code>PATH=/usr/bin</code></li><li>后面紧跟着一个0表示结束。</li></ul><blockquote><p>进程启动之后，程序的库会把堆栈里面的初始化信息中的参数信息传递给main()函数，也就是我们熟知的argc和argv连个参数，两个参数分别对应这里的命令参数数量和命令行参数字符串指针数组。</p></blockquote><h1 id="Linux内核装载ELF过程（可以省略，有点深）"><a href="#Linux内核装载ELF过程（可以省略，有点深）" class="headerlink" title="Linux内核装载ELF过程（可以省略，有点深）"></a>Linux内核装载ELF过程（可以省略，有点深）</h1><p>当在Linux系统bash下输入一个命令执行ELF程序时.</p><p>首先在用户层面，bash进程会调用fork，系统会创建一个新的进程，新的进程会用exeve()系统调用指定ELF文件，原先bash进程继续返回等待刚才启动新进程结束，开始等待用户输入命令。</p><blockquote><p>最终会调用到execve，函数原型<code>int     execve(const char * __file, char * const * __argv, char * const * __envp)</code>。三个参数分别是：</p></blockquote><ul><li>可执行文件名</li><li>执行参数</li><li>环境变量</li></ul><p>调用过程中还会调用到<code>do_excve()</code>，<code>do_excve()</code>会读取文件的前128个字节，判断文件格式，特别是开头的四个字节常常被称作魔数，通过魔数可以判断文件的格式及类型。</p><p>上面步骤可以确定文件的类型及格式了，然后调用<code>search_binary——handle()</code>去搜索和匹配合适的可执行文件装载处理过程。匹配过程是通过判断文件头部的魔数确定的，比如ELF可执行文件装载处理过程叫做load_elf_binary()，a.out可执行文件的装载处理过程叫做load_aout_binary(),可执行脚本处理过程叫做load_script()。比如load_elf_binary()主要经历了如下步骤。</p><ul><li>检查ELF可执行危机格式的有效性。如魔数，程序头表中段的数量</li><li>寻找动态链接的<code>.interp</code>段，设置动态链接路径</li><li>根据ELF可执行文件的程序头表描述，对ELF文件进行映射，比如代码数据，只读数据</li><li>初始化ELF进程环境，比如进程启动是EDX寄存器地址应该是DT_FINI地址（动态链接会讲）</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式。对于静态链接的ELF可执行文件，入口点就是ELF文件的文件头中e_entry所指的地址；动态链接的ELF，入口点就是动态链接器</li></ul><p>当load_elf_binary执行完毕，返回到do_execve在返回到sys_exevce()时，第5步中已经把系统调用的返回地址改为了被装载的ELF的程序入口 地址。所以当sys_execve()从内核态返回到用户态的时候，EIP寄存器直接跳到ELF程序入口地址，新的程序开始执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于可执行文件的装载和进程进程就介绍到这里。很多东西如果去深究，会发现是个无底洞。生有涯而学无涯！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac搭建虚拟CentOS服务器环境</title>
      <link href="/2018/04/06/2018/4/Mac%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9FCentOS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/04/06/2018/4/Mac%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9FCentOS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最初打算在阿里云买个云服务器来部署，后来一想完全可以用虚拟机先把整个流程跑一遍再买也不迟。<strong>先把坑踩完了，再直接去线上部署就会事半功倍。终有此文！</strong></p></blockquote><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/664334-5fef01c89d4c9e4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>比较麻烦的是在设置网络的时候，一方面需要访问外网，一方面需要主机ssh登录，网上介绍得的方法需要改Centos什么配置这些，亲自实践结果是不需要改Centos网络配置，直接设置Virutal Box就可以了</strong></p><h1 id="Virtual-Box-amp-amp-CentOS"><a href="#Virtual-Box-amp-amp-CentOS" class="headerlink" title="Virtual Box &amp;&amp; CentOS"></a>Virtual Box &amp;&amp; CentOS</h1><p>在正式开始安装之前需要一个虚拟化软件，这里用的是Oracle的Virtual Box，<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">可以在这里下载</a></p><p>其次需要CentOS的镜像文件，<a href="https://www.centos.org/download/" target="_blank" rel="noopener">可以在这里下载</a><br>官网提供了三种ISO镜像文件下载，区别如下：</p><ul><li>DVD ISO：标准安装版，一般下载这个就可以了（推荐）</li><li>Everything ISO：对完整版安装盘的软件进行补充，集成所有软件。（包含CentOS7的一套完整的软件包，可以用来安装系统或者填充本地镜像）</li><li>Minimal ISO：迷你版，小巧、安装快速、自带的软件少</li></ul><h1 id="安装CentOS"><a href="#安装CentOS" class="headerlink" title="安装CentOS"></a>安装CentOS</h1><p>首先打开Virtual Box，选择新建，选择类型为Linux，版本为Other Linux（64-bit）（根据自己下载的镜像决定）。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-20ff894540be4564.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>接下来可以使用默认的设置，也可以设置设置自定义的，比如内存大小。<strong>这里我全部采用的是默认设置。</strong>一直点继续<br><img src="https://upload-images.jianshu.io/upload_images/664334-e7a2312b4ffb9012.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-9c86b9e022144d6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-ab343b42b7306d6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-8543eb2c65f51e60.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-9927aa1e08328c09.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>最后点击创建，就会在左边出现一个虚拟主机<br><img src="https://upload-images.jianshu.io/upload_images/664334-a52a2604ca82b27e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="使用ISO镜像"><a href="#使用ISO镜像" class="headerlink" title="使用ISO镜像"></a>使用ISO镜像</h2><p>选中刚才创建的虚拟主机，点击启动</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-fd99bdbbdd3a42d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>选择之前下载好的CentOS的镜像文件，点击开始<br><img src="https://upload-images.jianshu.io/upload_images/664334-ff7ed46e2063b3ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后使用↑或↓选择想要安装的方式，这里直接安装CentOS<br><img src="https://upload-images.jianshu.io/upload_images/664334-dfebb94e182cd259.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>紧接着开始安装了<br><img src="https://upload-images.jianshu.io/upload_images/664334-2038a2cfe492e2a0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>然后出现选择语言的界面（我这里直接选的默认的英语），点击右下角的<code>continue</code>进入下一步<br><img src="https://upload-images.jianshu.io/upload_images/664334-f48a64e3382a9844.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里选择的是最小化安装<br><img src="https://upload-images.jianshu.io/upload_images/664334-7454485f167c4ac6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后设置Root密码及创建用户<br><img src="https://upload-images.jianshu.io/upload_images/664334-4857ab7cb7327e37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>设置好密码及用户后就等待安装完成，然后重启就可以了。<br><img src="https://upload-images.jianshu.io/upload_images/664334-bf2b0ba7f4607b32.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-695c5576874c4042.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="设置网络（重点，很多同学不知道怎么弄？）"><a href="#设置网络（重点，很多同学不知道怎么弄？）" class="headerlink" title="设置网络（重点，很多同学不知道怎么弄？）"></a>设置网络（重点，很多同学不知道怎么弄？）</h1><p>经过上面的步骤已经安装好了，并且可以登录使用。<br><img src="https://upload-images.jianshu.io/upload_images/664334-75b4004569344036.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>但是这个时候虚拟机是不能连上外网的，并且很多命令都还不包含比如ifconfig，gcc等</strong>输入<code>ip addr</code>只有一个本地地址。<br><img src="https://upload-images.jianshu.io/upload_images/664334-305c5870fa8007df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>接下来进行Virtual Box的偏好设置<br><img src="https://upload-images.jianshu.io/upload_images/664334-4800df52e5a9c409.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>设置对应的网络（<strong>如果没有则新建，新建之后可以直接用默认的设置，双击可以进行编辑</strong>）</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-850f43ae222dc217.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>保存了上一步的设置之后，接下来设置虚拟的网络，<strong>需要先关闭虚拟机之后才能新加网络类型。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-d2f858573b30ce50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-74b2f8fc0b700581.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>关机之后选中设置中的网络，则可以直接设置网络了<br><img src="https://upload-images.jianshu.io/upload_images/664334-a28c67146421e8e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>选中网卡2，进行如下设置（为了能够访问外网）<br><img src="https://upload-images.jianshu.io/upload_images/664334-e76a8a7f72eb5448.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>选中网卡3，进行如下设置（为了主机能够远程登录虚拟机，和主机通信）<br><img src="https://upload-images.jianshu.io/upload_images/664334-bd08fdc2f6a6b544.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>网卡1直接用默认的，不管他<br><img src="https://upload-images.jianshu.io/upload_images/664334-62ea53f3bffd9177.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后启动虚拟机。<br>这个时候再次输入<code>ip addr</code>则会出现如下内容：<br><img src="https://upload-images.jianshu.io/upload_images/664334-c687428745fe6e04.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>可以看到已经有了公网ip及局域网地址。</p><p>ping 一下百度，结果也正常。<br><img src="https://upload-images.jianshu.io/upload_images/664334-00ed3453f34b1d7c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这个时候可以连上外网了就可以正常的经常操作了，比如更新yum，安装常用软件等等。</p><h2 id="安装net-tools"><a href="#安装net-tools" class="headerlink" title="安装net-tools"></a>安装net-tools</h2><p>建议先安装一下net-tools。不然很多网络相关的命令会找不到。<strong>安装的时候需要root权限，需要su一下</strong></p><h1 id="启动SSH"><a href="#启动SSH" class="headerlink" title="启动SSH"></a>启动SSH</h1><blockquote><p>如果直接在虚拟机中操作CentOS非常不方便，比如输入一行命令后，打印很多内容，但是不能直接翻页查找之前的命令，这点非常蛋疼。如果可以用iterm SSH远程登录了就可以解决这个问题，而且还能直接粘贴、复制相关的命令，非常方便。</p></blockquote><h2 id="查看22端口"><a href="#查看22端口" class="headerlink" title="查看22端口"></a>查看22端口</h2><p>ssh端口一般是22，首先查看一下这个端口开放没有。使用<code>netstat -tnl</code>进行查看。关于netstat命令这里多说点。</p><pre><code>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。常用参数如下：-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/664334-f4b537bbf045c20b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>可以看到默认情况下，端口22是开启的，处于监听状态。</p><h2 id="查看ssh服务"><a href="#查看ssh服务" class="headerlink" title="查看ssh服务"></a>查看ssh服务</h2><p>然后查看ssh服务是否启动，使用命令<code>systemctl status sshd</code><br><img src="https://upload-images.jianshu.io/upload_images/664334-94593309d799b618.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到ssh服务是开启的。<strong>那么我们就可以直接在主机上远程登录了。完全模拟了线上开发的流程。</strong></p><h1 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h1><p>将之前看到的局域网ip记录下来，进程ssh登录。当然可以使用公钥、私钥的方式，这里直接通过密码的方式登录。<br><img src="https://upload-images.jianshu.io/upload_images/664334-37fc848a6692e6a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>登录成功后就可以安装一些常见的软件了。</p><h1 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h1><blockquote><p>大部分情况下安装软件都需要root权限，所以最好先切换到root用户下。</p></blockquote><h2 id="更新yum"><a href="#更新yum" class="headerlink" title="更新yum"></a>更新yum</h2><p>关于yum的update和upgrade的区别这里解释下：</p><ul><li>update：是下载源里面的metadata的. 包括这个源有什么包, 每个包什么版本之类的</li><li>upgrade:是根据update命令下载的metadata决定要更新什么包(同时获取每个包的位置)</li><li>安装软件之前, 可以不upgrade, 但是要update因为旧的信息指向了旧版本的包, 但是源的服务器更新了之后旧的包可能被新的替代了, 于是会遇到404…</li></ul><p><strong>一定要先update一下</strong></p><h2 id="安装Wget"><a href="#安装Wget" class="headerlink" title="安装Wget"></a>安装Wget</h2><p>wget在linux中经常用来下载一些资源非常方便。使用<code>yum install wget</code>安装</p><blockquote><p>注意如果直接用wget去下载JDK，由于默认用wget下载JDK表示你没有同意许可证所以下载下来的文件名字虽然是jdk的名字，实际上是一个网页。</p></blockquote><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>使用wget直接下载JDK是不行的，于是就只有采用间接的方式。<strong>先把jdk文件下载到本地，然后再把文件传到服务器</strong></p><p>去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK官网下载</a>。记得点击同意接受许可证<br><img src="https://upload-images.jianshu.io/upload_images/664334-30a9771ae605ca02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>下载好之后，新开一个item。通过scp命令将文件传到服务器指定目录下。</p><h3 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h3><p><strong>在传之前先建好文件夹目录，一般会在/usr/local下面建一个子文件夹soft，用来保存上传的环境</strong></p><pre><code>[root@localhost CodeSource]# mkdir /usr/local/soft[root@localhost CodeSource]# cd /usr/local/soft</code></pre><h3 id="上传文件至服务器"><a href="#上传文件至服务器" class="headerlink" title="上传文件至服务器"></a>上传文件至服务器</h3><pre><code>scp /Users/instanza/Downloads/jdk-8u161-linux-x64.tar.gz root@192.168.56.101:/usr/local/softroot@192.168.56.101&#39;s password:jdk-8u161-linux-x64.t 100%  181MB  51.6MB/s   00:03</code></pre><p>然后在soft目录查看</p><pre><code>[root@localhost soft]# lsjdk-8u161-linux-x64.tar.gz</code></pre><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>使用<code>tar -zxvf  jdk-8u161-linux-x64.tar.gz</code>解压</p><p>查看解压结果</p><pre><code>[root@localhost soft]# lsjdk1.8.0_161  jdk-8u161-linux-x64.tar.gz</code></pre><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>jdk1.8.0_161<br>编辑profile文件</p><pre><code>[root@localhost soft]# vi /etc/profile</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/664334-c1d9084939255cd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><pre><code>export JAVA_HOME=/usr/local/soft/jdk1.8.0_161export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre><p>然后退出保存，通过<code>source /etc/profile</code>让环境变量立即生效</p><h3 id="测试JDK是否安装成功"><a href="#测试JDK是否安装成功" class="headerlink" title="测试JDK是否安装成功"></a>测试JDK是否安装成功</h3><p>使用<code>java -version</code>和<code>javac -version</code></p><pre><code>[root@localhost soft]# java -versionjava version &quot;1.8.0_161&quot;Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</code></pre><pre><code>[root@localhost soft]# javac -versionjavac 1.8.0_161</code></pre><p>上面这种情况就说明环境变量配置成功。</p><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>安装tomcat同安装jdk一样，也是先现在带本地然后上传到服务器</p><p><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">下载地址</a><br><img src="https://upload-images.jianshu.io/upload_images/664334-95b9a283fb662bab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><pre><code>$ scp /Users/instanza/Downloads/apache-tomcat-9.0.6.tar.gz root@192.168.56.101:/usr/local/softroot@192.168.56.101&#39;s password:apache-tomcat-9.0.6.tar.gz                    100% 9272KB  49.6MB/s   00:00</code></pre><p>在服务器目录中中查看<br>多了个压缩文件</p><pre><code>[root@localhost soft]# lsapache-tomcat-9.0.6.tar.gz  jdk1.8.0_161  jdk-8u161-linux-x64.tar.gz</code></pre><p>然后解压</p><pre><code>[root@localhost soft]# tar -zxvf apache-tomcat-9.0.6.tar.gz</code></pre><p>接下来启动一下</p><pre><code>[root@localhost soft]# cd apache-tomcat-9.0.6/bin/[root@localhost bin]# ./startup.shUsing CATALINA_BASE:   /usr/local/soft/apache-tomcat-9.0.6Using CATALINA_HOME:   /usr/local/soft/apache-tomcat-9.0.6Using CATALINA_TMPDIR: /usr/local/soft/apache-tomcat-9.0.6/tempUsing JRE_HOME:        /usr/local/soft/jdk1.8.0_161Using CLASSPATH:       /usr/local/soft/apache-tomcat-9.0.6/bin/bootstrap.jar:/usr/local/soft/apache-tomcat-9.0.6/bin/tomcat-juli.jarTomcat started.</code></pre><p>说明启动成功了。有的tomcat版本会报错<code>Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</code>这是因为因为启动tomcat会调用tomcat安装文件中的startup.bat，而它调用了catalina.bat则调用了setclasspath.bat。因此需要在setclasspath.bat的开头手动声明环境变量。<strong>解决起来也方便直接用vim打开tomcat的bin目录下的setclasspath.sh，添加JAVA_HOME和JRE_HOME两个环境变量，两个环境变量路径为您安装的java JDK的路径就可以了。</strong></p><p>但是这个时候在主机上访问还是访问不到Tomcat，这是因为防火墙的原因。</p><h3 id="配置Tomcat相关的防火墙"><a href="#配置Tomcat相关的防火墙" class="headerlink" title="配置Tomcat相关的防火墙"></a>配置Tomcat相关的防火墙</h3><p>CentOS7相对于CentOS6，CentOS6中的iptables相关命令用不了的，CentOS7使用firewall而不是iptables。所以解决这类问题可以通过添加firewall的端口，使其对我们需要用的端口开放。</p><p>具体来讲：</p><ol><li>使用命令 firewall-cmd –state查看防火墙状态。得到结果是running或者not running</li><li>在running 状态下，向firewall 添加需要开放的端口，命令为<code>firewall-cmd --permanent --zone=public --add-port=8080/tcp</code>永久的添加该端口。去掉–permanent则表示临时。</li><li><code>firewall-cmd --reload</code> 加载配置，使得修改有效。</li><li>使用命令<code>firewall-cmd --permanent --zone=public --list-ports</code> 查看开启的端口，出现8080/tcp这开启正确</li></ol><p>一些常见的防火墙命令：</p><pre><code>开启防火墙的命令         systemctl start firewalld.service关闭防火墙的命令        systemctl stop firewalld.service开机自动启动        systemctl enable firewalld.service关闭开机自动启动        systemctl disable firewalld.service查看防火墙状态        systemctl status firewalld下列显示表示没有问题。</code></pre><p>对应到这台虚拟上</p><pre><code>[root@localhost ~]# firewall-cmd --staterunning</code></pre><pre><code>[root@localhost ~]# firewall-cmd --permanent --zone=public --add-port=8080/tcpsuccess</code></pre><pre><code>[root@localhost ~]# firewall-cmd --reloadsuccess</code></pre><pre><code>[root@localhost ~]# firewall-cmd --permanent --zone=public --list-ports8080/tcp</code></pre><p>现在在主机上再次访问：<br><img src="https://upload-images.jianshu.io/upload_images/664334-7f83bc09ec16040a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>说明已经能够正常访问了。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>如果要进行代码管理，一般使用Git来管理。</p><p>比价常见的一种服务端模式是将代码放在单独的一台代码服务器管理，服务器通过Git来拉取代码，然后服务器本地有了代码，直接在本地编译打包，最后发布。<strong>中间的过程大部分都是直接通过脚本实现的。</strong></p><p>通过<code>yum install git</code>安装Git</p><p>安装好之后试一试</p><pre><code>[root@localhost CodeSource]# git initInitialized empty Git repository in /home/wesly/CodeSource/.git/</code></pre><p>说明没问题了。</p><h2 id="安装其他常用工具"><a href="#安装其他常用工具" class="headerlink" title="安装其他常用工具"></a>安装其他常用工具</h2><p>比如Redis 、Ngix、MySql这里就直接省略了。因为按照步骤都差不多了太多。<strong>需要注意的就是在装完之后如果主机访问不了需要检查一下防火墙的设置。比如Ngix的时候。</strong></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>现在你就可以想怎么玩就怎么玩了！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》读书笔记——静态链接</title>
      <link href="/2018/04/02/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2018/04/02/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇介绍了<a href="https://www.jianshu.com/p/dd9b6b66ef25" target="_blank" rel="noopener">目标文件的格式</a>，有了对结构的认识，这篇讲静态链接，主要是关于目标文件如何链接起来组成可执行文件。笔记后面把ld链接脚本语法省略，暂时用不到这么牛逼的武器。</p></blockquote><p>本文导图<br><img src="https://upload-images.jianshu.io/upload_images/664334-291434e5d490db67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><p>实验代码</p><ul><li>a.c</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> shared<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>b.c</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> shared <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">*</span>a <span class="token operator">^</span><span class="token operator">=</span> <span class="token operator">*</span>b <span class="token operator">^</span><span class="token operator">=</span> <span class="token operator">*</span>a <span class="token operator">^</span><span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对上面内容的解释：</p><ul><li>b中定义两个全局符号，变量shared和函数swap</li><li>a中定义了一个全局符号main</li><li>a中引用到了b中的swap和shared</li></ul><h1 id="空间地址分配"><a href="#空间地址分配" class="headerlink" title="空间地址分配"></a>空间地址分配</h1><p><strong>链接额过程就是将输入的目标文件合并为一个输出的可执行文件</strong>。如何将目标文件的各个段合并到可执行文件中，也就是空间如何分配，总体有如下两种方式，<strong>按序叠加与相似段合并</strong>。——合并规则</p><p>按序叠加很简单，就是按照目标文件的顺序叠加起来，可以用下图说明：<br><img src="https://upload-images.jianshu.io/upload_images/664334-37840aa80dbebd5f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>如果可执行文件成千上百个目标文件组成，就会出现很多零散的段，每个目标文件都有三个最为核心的段，这样就会非常浪费空间，<strong>因为每个段都需要有一定的地址和空间对其要求。</strong>比如x86来说，段的装载地址和空间对其单位是页，也就是4096字节（一个页大小是4096字节），会造成极大的内存空间碎片。</li><li>关于内存地址对其可以看看<a href="https://levphy.github.io/2017/03/23/memory-alignment.html" target="_blank" rel="noopener">内存对齐规则之我见</a>，简单来讲就是因为<strong>CPU是按字读取内存。所以内存对齐的话，不会出现某个类型的数据读一半的情况，需要再二次读取内存。可以提升访问效率。编译器想通过空间换时间，通过适当增加padding，使每个成员的访问都在一个指令里完成，而不需要两次访问再拼接。</strong></li></ul><p>相似段合并这种方式更加实际，比如讲.text段合并到可执行文件的.text段，各个段一次合并。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/664334-e150e0c5ba11dfc0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>链接器为目标文件分配地址空间有两层含义：</p><ul><li>一个是在输出可执行文件中的空间</li><li>另一个是装载后的虚拟地址中的虚拟地址空间</li><li>之前提到过.bbs段，在可执行文件中并不占用文件空间，但是在占用虚拟地址空间，因为.bbs段在在文件中并没有内容。</li></ul><blockquote><p>目前只讨论关于虚拟地址空间的分配</p></blockquote><p>具体来讲链接器空间分配策略都是用第二中，并且采用两步链接。</p><ul><li>第一步：空间与地址分配——扫描所有目标文件，得到各个段的长度，将所有目标文件的符号表中的符号定义及引用信息统一放到一个全局符号表。可以根据目标文件的段长度，将他们合并，建立映射关系。</li><li>第二步：符号解析与重定位——根据上面的信息，读取文件中的段数据，重定位信息，进行符号解析与重定位，调整代码地址。<strong>这一步才是狠心，尤其是重定位。</strong></li></ul><p>用ld将a.o、b.o连接起来</p><p>Linux</p><pre><code>ld a.o b.o -e main -o ab</code></pre><p>Mac</p><pre><code>ld a.o b.o -e _main -o ab</code></pre><p>ld命令的两个参数含义是：</p><pre><code>-o：指定输出文件名；-e：指定程序的入口符号。</code></pre><p>链接之后各个段的属性</p><p>Linux</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-9bbb1180534f8f37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Mac</p><pre><code>$ objdump -h a.oa.o:    file format Mach-O 64-bit x86-64Sections:Idx Name          Size      Address          Type  0 __text        0000002e 0000000000000000 TEXT  1 __compact_unwind 00000020 0000000000000030 DATA  2 __eh_frame    00000040 0000000000000050 DATA$ objdump -h b.ob.o:    file format Mach-O 64-bit x86-64Sections:Idx Name          Size      Address          Type  0 __text        0000002c 0000000000000000 TEXT  1 __data        00000004 000000000000002c DATA  2 __compact_unwind 00000020 0000000000000030 DATA  3 __eh_frame    00000040 0000000000000050 DATA$ objdump -h abab:    file format Mach-O 64-bit x86-64Sections:Idx Name          Size      Address          Type  0 __text        0000005c 0000000000001f20 TEXT  1 __eh_frame    00000080 0000000000001f80 DATA  2 __data        00000004 0000000000002000 DATA</code></pre><p>在Linux中VMA表示的是虚拟地址，LMA表示的是加载地址，一般这两个值一样，但是有些嵌入式系统中会不一样。Mac中只有一个地址也就是虚拟地址。</p><p>现在直接看VMA和SIZE，暂时忽略文件偏移。<strong>在链接之前虚拟地址都是零（MAC上起始的.text段为0），因为虚拟地址空间还没有分配，所以默认都是0，但是链接之后，可执行文件ab各个段都分配了相应的虚拟地址，所以可以看到text已经分配到地址。</strong></p><p>对应到Linux中ELF文件，<code>.text</code>段分配到了0x08048094，大小是0x72字节，<code>.data</code>段从地址0x08049108开始，大小为四字节。总体来说如下图：<br><img src="https://upload-images.jianshu.io/upload_images/664334-ca093deba689074b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>为什么不从虚拟地址的0地址开始分配呢。涉及到操作系统进程虚拟地址的分配规则。Linux下ELF文件默认从0x08048000开始分配的。</p><h2 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h2><p>第一步过程中确定了在可执行文件中的空间分布。比如<code>.text</code>其实段0x08040894，<code>.data</code>段其实地址0x08049108.</p><p>第一步完成之后，链接器就开始计算各个符号的虚拟地址。<strong>符号在段内的位置是固定的，比如main、shared、wap地址已经是确定的了，只不过需要链接器给每个符号添加一个偏移量。</strong></p><p>比如a.o中的main函数相对于a.o的text偏移量是X，经过链接之后a.o的text段位于虚拟地址0x08048094,那么main的地址就是0x08048094+X。从前面的objdump可以看到main位于a.o的text段偏移是0。所以main这个符号最终在可执行文件中的地址是0x08048094+0。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-b0c9486d653f2a53.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="符号解析、重定位"><a href="#符号解析、重定位" class="headerlink" title="符号解析、重定位"></a>符号解析、重定位</h1><p>完成了空间和地址分配，链接器开始进行符号解析及重定位。</p><p>使用objdump的参数d查看反汇编结果</p><p>未链接a.o反汇编结果</p><p>Mac 下</p><pre><code>$ objdump -d a.oa.o:    file format Mach-O 64-bit x86-64Disassembly of section __TEXT,__text:_main:       0:    55     pushq    %rbp       1:    48 89 e5     movq    %rsp, %rbp       4:    48 83 ec 10     subq    $16, %rsp       8:    48 8d 7d fc     leaq    -4(%rbp), %rdi       c:    48 8b 35 00 00 00 00     movq    (%rip), %rsi      13:    c7 45 fc 64 00 00 00     movl    $100, -4(%rbp)      1a:    b0 00     movb    $0, %al      1c:    e8 00 00 00 00     callq    0 &lt;_main+0x21&gt;      21:    31 c9     xorl    %ecx, %ecx      23:    89 45 f8     movl    %eax, -8(%rbp)      26:    89 c8     movl    %ecx, %eax      28:    48 83 c4 10     addq    $16, %rsp      2c:    5d     popq    %rbp      2d:    c3     retq</code></pre><p>Linux下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-283999b8f255baee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可执行文件ab反汇编结果：<br>Mac 下：</p><pre><code>objdump -d abab:    file format Mach-O 64-bit x86-64Disassembly of section __TEXT,__text:......_main:    1f20:    55     pushq    %rbp    1f21:    48 89 e5     movq    %rsp, %rbp    1f24:    48 83 ec 10     subq    $16, %rsp    1f28:    48 8d 7d fc     leaq    -4(%rbp), %rdi    1f2c:    48 8d 35 cd 00 00 00     leaq    205(%rip), %rsi    1f33:    c7 45 fc 64 00 00 00     movl    $100, -4(%rbp)    1f3a:    b0 00     movb    $0, %al    1f3c:    e8 0f 00 00 00     callq    15 &lt;_swap&gt;    1f41:    31 c9     xorl    %ecx, %ecx    1f43:    89 45 f8     movl    %eax, -8(%rbp)    1f46:    89 c8     movl    %ecx, %eax    1f48:    48 83 c4 10     addq    $16, %rsp    1f4c:    5d     popq    %rbp    1f4d:    c3     retq    1f4e:    90     nop    1f4f:    90     nop......</code></pre><p>Linux下<br><img src="https://upload-images.jianshu.io/upload_images/664334-38d3e11ae3691af1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>需要懂点汇编才能理解上面的不同。主要是想说明，被引用的函数或者变量的地址，在链接之后被重新定位了。如上面的swap函数、shared变量。</p></blockquote><p><strong>关于汇编的学习后面会专门写一篇！</strong></p><h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>链接器通过重定位表才能知道哪些指令需要被调整，重定位表往往是一个或多个段。ELF必须包含重定位表来重新定位符号。</p><p>比如代码段<code>.text</code>有符号需要重定位，则就会有一个<code>.rel.text</code>的段保存了代码段重定位的信息，如果<code>.data</code>段中有重定位的地方，就会有一个对应的.<code>rel.data</code>段保存了数据端的重定位表。可以使用objdump的<code>r</code>参数查看。</p><p>Mac下：</p><pre><code>objdump -r a.oa.o:    file format Mach-O 64-bit x86-64RELOCATION RECORDS FOR [__text]:000000000000001d X86_64_RELOC_BRANCH _swap000000000000000f X86_64_RELOC_GOT_LOAD _shared@GOTPCRELRELOCATION RECORDS FOR [__compact_unwind]:0000000000000000 X86_64_RELOC_UNSIGNED __text</code></pre><p>Linux下：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7870e45aa714f9f8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以看到a.o有两个重定位入口，<strong>重定位入口的偏移表示该符号入口在重定位段中的位置。</strong></p><blockquote><p>对上面代码的解析：因为还未进行链接,首先main函数其实地址为0x00000000。这个main函数占用了0x33个字节，17条指令。shared的引用是一条mov指令，一共8个字节，将shared的地址复制到ESP寄存器+4的偏移地址中，前四个是指令码，后面是shared的地址。暂时认为shared的地址是0x00000000，<strong>并且是绝对地址指令。</strong>。</p><p>其次对swap的调用的指令一个共5个字节，0xE8是操作码，这是个相对位移调用指令，后面四个字节就是函数 相对于调用指令的下一条指令的偏移量。没重定位之前，相对偏移量为0xFFFFFFFC（小端），常量<code>-4</code>的补码形式。</p></blockquote><ul><li>第一行表示这个重定位表是对代码段的重定位，所以偏移表示代码段中需要被调整的位置。对照前面的反汇编结构。这里的0x1c和0x27分别对应了代码段中的mov和call指令部分。</li></ul><p>重定位表中保存的是一个ELF32_Rel（intelx86）结构数组，表中每一个元素都对应一个重定位入口</p><pre><code>typedef struct {    ELF32_Addr r_offset;    ELF32_Word r_info;}</code></pre><p>具体含义如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-b1f223b2c71b1cfa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>重定位表项里面包含了如何定位该符号的所有信息，偏移位置，类型，符号等。</p></blockquote><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>符号未定义错误在链接的时候经常出现。对应上面的例子，</p><pre><code>ld a.old: warning: -macosx_version_min not specified, assuming 10.11ld: warning: object file (a.o) was built for newer OSX version (10.12) than being linked (10.11)Undefined symbols for architecture x86_64:  &quot;_shared&quot;, referenced from:      _main in a.o  &quot;_swap&quot;, referenced from:      _main in a.o  &quot;start&quot;, referenced from:     implicit entry/start for main executableld: symbol(s) not found for inferred architecture x86_64</code></pre><p>导致符号未定义的原因很多（根本原因找不到符号），比如：</p><ul><li>链接时少了某个库</li><li>符号目标文本路径不正确</li></ul><blockquote><p>为什么缺少符号定义会导致链接错误？其实重定位过程伴随着符号解析的过程，每个目标文件可能定义一些符号，也可能引用的到其他文件中定义的符号，每个重定位入口都是对一个符号的引用。<strong>当链接器对某个符号进行重定位的时候，就需要确定这个符号的目标地址，这个时候就会去查找输入目标文件的符号表组成的全局符号表，找到这个符号然后重定位。</strong></p></blockquote><p>使用readelf -s查看符号表。</p><p>a.o中的符号表<br><img src="https://upload-images.jianshu.io/upload_images/664334-f822a74a55579eb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>注意上面的main、shared、swap都是GLOBAL。main函数定义在代码段之外，shared和swap是UND为定义。因为他们是定义哎其他目标文件中的。稳定一的都是需要在全局符号表中找到。</p><h2 id="指令修正"><a href="#指令修正" class="headerlink" title="指令修正"></a>指令修正</h2><blockquote><p>这部分需要结合在重定位反汇编用到的偏移量。</p></blockquote><p>不同处理器对于地址的格式和方式都不一样。常见的有跳转指令（jump 11种）、子程序调用指令（call 10种）、数据传送指令（mov 34中）寻址千差万别。差别如下：</p><ul><li>近址或远址寻址</li><li>绝对与相对寻址</li><li>寻址长度8、16、32、64位</li><li>相对近址32位寻址</li><li>绝对近址32位寻址</li></ul><p>每个被修正的长度为32位，4字节，都是近址寻址。区别就是相对或者绝对。之前说过，重定位入口r_info成员低八位表示重定位入口类型</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-d898a7501a982583.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>对应到上面的内容。swap符号的引用类型为R_386_PC32，代表是相对位移调用指令，而shared是R_386_32类型，他修正的是一条传输指令的原，shared的绝对地址。</p><blockquote><p>绝对寻址修正和相对寻址修正的区别就是前者修正后的地址就是该符号的实际地址，而后者修正后的地址为符号距离被修正位置的地址差。</p></blockquote><p>现在来计算一下，<strong>假设链接之后main函数的虚拟地址为0x1000，swap函数的地址为0x2000，shared变量的虚拟地址为0x3000。现在开始修正这两个重定位符号的地址。</strong></p><h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>根据上面的分析，首先shared是一个绝对寻址修正，结果应该是S（实际虚拟地址——假设的）+ A（修正位置的值——从符号解析中得到的value）</p><p>那么修正之后的地址就是：0x3000 + 0x0000000 = 0x3000。那么就应该是：<br><img src="https://upload-images.jianshu.io/upload_images/664334-7a989b0f0c244fe1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>swap需要相对修正，器修正地址就是S + A - P（被修正的位置，当链接的时候这个值就是被修正位置的虚拟地址 就为0x1000(main函数地址）+ 0x27）</p><p>对应下来：0x2000 + (-4) - (0x1000 + 0x27) = 0xFD5：</p><p>那么这条相对唯一调用指令地址是改指令下一条指令其实地址加上偏移量。那就是0x1026 + 0xfd5 = 0x2000。这就是swap函数的地址。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-2ff7b9eda6c0beab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h1><p>编译器将未初始化的全局变量定义作为弱符号，如上一篇的例子中global_uninit_var。使用<code>readelf -s</code>查看<br><img src="https://upload-images.jianshu.io/upload_images/664334-171f804fb9a221ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>类型是一个SH_COMMON类型。</p><p><strong>当不同目标文件需要的COMMON块空间大小不一致的时候，以最大的那块为准。</strong></p><blockquote><p>需要使用COMMON机制的原因是编译器和链接器允许不同类型的弱符号存在，但是最本质的还是链接器不支持符号类型，也就是链接器无法判断各个符号类型是否一致。</p></blockquote><p><strong>小结：如果编译单元包含了弱符号（比如未初始化的全局变量就是典型的），那么弱符号最终占有多大空间不知道，所以编译器无法为改符号在BSS段分配空间。但是在链接过程中，弱符号大小可以确定了，所以最终在输出可执行文件的BBS段为弱符号分配空间。最终未初始化的全局变量还是放在BBS段</strong></p><h1 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++ 相关问题"></a>C++ 相关问题</h1><p>C++语言特性太复杂，必须有编译器和链接器共同支持才能完成工作。关键在于：</p><ul><li>重复代码消除</li><li>全局构造与析构</li><li>特性：虚函数、函数重载、继承、异常等。<strong>这些数据结构复杂，往往在不同编译器和链接器之间不能通用，二进制兼容性很麻烦。</strong></li></ul><h2 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h2><p>C++中的模板本质来讲很像宏，当被实例化的时候，并不知道自己是否在别的编译单元被实例化，所以必定出现重复代码。如果不管这些重复代码的话，主要会有如下问题：</p><ul><li>空间浪费</li><li>地址教易出错：可能有两个指向同一个函数的指针不相等。</li><li>指令运行效率低：因为现代CPU都会对指令和数据进行缓存，同一份指令有多份副本，那么Cache的命中率就会很低。</li></ul><p>比较现实的做法：每个目标的实例代码都单独存放到一个段（段命名如<code>.gnu.linkonce.name</code>，name就是该函数模板修饰后的名称）里，每个段只包含一个模板实例。当别的编译单元也有同样模板实例的时候，就会生成相同的名字，最终链接器将他们合并到最后的代码段。</p><h2 id="函数级别链接"><a href="#函数级别链接" class="headerlink" title="函数级别链接"></a>函数级别链接</h2><p>现在的程序和库都非常庞大，一个目标文件可能包含成千上百个函数或者变量，当我们需要用到某个目标文件的一个函数或变量的时候，需要把珍格格文件链接进来，这样导致输出的文件也很多。</p><p>在C++编译器中，有个编译选项叫做函数几倍链接，这个的作用就是让所有的函数像前面的模板一样，<strong>单独保存到一个段里面</strong>。当链接器需要用到这个函数的时候，就会将它合并到输出文件，没有用到的函数就会被抛弃。<strong>这样的方式同样有问题，虽然减少了输出文件的长度，但是会减慢编译和链接的过程，并且所有函数保存到独立的短中，目标函数的短数量增加，重定位会因为短的数目增加而变得复杂，目标文件也会变得相对较大。</strong></p><h2 id="全局构造、析构"><a href="#全局构造、析构" class="headerlink" title="全局构造、析构"></a>全局构造、析构</h2><p>C/C++程序都是从main函数开始执行的，随着main函数结束而结束。在main函数之前为了程序能够顺利执行。需要<strong>初始化进程执行环境、如堆分配初始化、线程子系统等</strong>。C++的全局对象构造函数在这一时期被执行</p><p>Linux下一班程序的入口是<code>_start</code>，这个函数时Linux系统库（Glibc）的一部分。当程序与Glibc链接在一起形成可执行文件之后，<code>_start</code>就是程序初始化入口。<strong>程序初始化之后，会调用main函数来执行程序，main函数执行之后就会进行一些清理工作，然后结束进程。</strong></p><p>在ELF定义了两个特殊的段，</p><ul><li><code>.init</code>段在main函数之前的可执行指令。构成进程的初始化代码。所以在main函数调用之前，Glibc初始化部分会执行这个段的代码。</li><li><code>.fini</code>段保存着进程的终止代码指令。所以当main函数正常退出时，Glib会安排执行这个段中的代码。</li></ul><h2 id="C-、ABI"><a href="#C-、ABI" class="headerlink" title="C++、ABI"></a>C++、ABI</h2><p><strong>编译器有很多种，那么不同编译器产生的目标文件可不可以进链接呢?</strong></p><p>如果两个不同的编译器想要产生的目标文件能够正确的链接起来，那么这两个目标文件必须满足：</p><ul><li>采用相同的目标文件格式</li><li>拥有相同的符号修饰标准</li><li>变量的内存分配方式相同</li><li>函数调用方式相同</li></ul><blockquote><p>把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行的二进制文件兼容性相关的内容统称为ABI（应用程序二进制接口）。<strong>如果想弄清API和ABI的区别，可以看最后的扩展阅读内容呢。</strong></p></blockquote><ul><li>简单来讲就是API往往指源代码级别的接口，如POSIX是一个API标准，而ABI是二进制层面的级别。比如C++对象内存布局是C++ABI的一部分。</li><li>就拿POSIX规定printf()函数的原型为例，POSIX保证这个函数所有遵循POSIX标准的系统之间都一样，但是不保证printf在每个系统执行时，是否按照从右到左的参数压入堆栈。<strong>参数如何在堆栈中分配等这些实际运行时的二进制级别问题。</strong></li><li>由于各大硬件拼图，编程语言，编译，链接器和操作系统之间的ABI互相不兼容，所以哥哥目标文件之间无法互相链接。</li></ul><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>对于C语言的目标来讲，一下几个方面会决定二进制是否兼容：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-ae6d724f32011c81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>API相同ABI不一定相同。</strong></p><h1 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h1><p>一般情况下用链接器默认的链接规则就可以了，但是在一些特殊的情况下就需要自定义一些参数了，比如引导程序、内核驱动程序就需要特殊的链接过程。</p><p>链接过程需要确定的内容：</p><ul><li>使用哪些目标文件</li><li>使用安歇库文件</li><li>是否在最终的可执行文件保留调试信息</li><li>输出文件格式（可执行文件、动态库、静态库）</li><li>….</li></ul><h2 id="链接控制脚本"><a href="#链接控制脚本" class="headerlink" title="链接控制脚本"></a>链接控制脚本</h2><p><strong>链接控制脚本就是用来控制链接行为的</strong></p><p>一般链接器有如下几种方式控制链接行为：</p><ul><li>使用命令行：给链接器指定参数，比如之前用的ld的-o、-e参数就属于这类。</li><li>链接指令存放到目标文件里面：编译器经常会通过这种方式给链接器传递指令。具体来讲比如在PE目标文件的.drectve段用来链接传递参数 。</li><li>链接控制脚本：最为灵活也是最为强大的控制方式</li></ul><p>之前我们在使用ld命令链接的时候，没有指定链接脚本，其实ld如果没有指定链接脚本，则会使用默认的链接脚本。在Linux上使用<code>ld -verbose</code>查看默认链接脚本。<strong>为了更加精确的控制链接过程，可以自己写一个链接脚本，然后指定该脚本控制脚本，比如<code>ld -T link.script</code></strong></p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>在这里例子中，作者没有使用main函数和c中的printf函数来打印helloword。而是使用了自定义的一套方式，使用了GCC内嵌汇编（<strong>不是很懂，没弄过</strong>），并且自定义了将所有段合并到一个叫做<code>tinytext</code>段中。</p><p>TinyHelloWord.c源码<br><img src="https://upload-images.jianshu.io/upload_images/664334-82c0f6857b416585.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>看到后面懵逼了，暂时停下来去了解下汇编、复习下终端等知识。</p></blockquote><ul><li>句柄与普通指针的区别：指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。</li></ul><h3 id="使用ld链接脚本"><a href="#使用ld链接脚本" class="headerlink" title="使用ld链接脚本"></a>使用ld链接脚本</h3><p>无奈是输出文件还是输入文件，主要的数据就是文件中的各个段。它们中的段我们称作输入段、输出段。控制链接果果就是把控制输入段如何变成输出段，比如</p><ul><li>哪些输入段要合并为一个输出段</li><li>哪些输入段要丢弃</li><li>指定输出段的名字、装载地址、属性</li></ul><p>比如上面TinyHelloword的链接脚本TinyHelloWorld.lds<br><img src="https://upload-images.jianshu.io/upload_images/664334-7ee306600500b076.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><p>第一行是ENTRY（nomain）指定了程序入口为nomain()函数</p></li><li><p>SECTIONS是链接脚本的主体，指定了各个输入段到输出段的交换。里面的大括号包含的是SECTIONS的变化规则。</p><ul><li>第一条是赋值语句<code>. = 0x08048000 + SIZEOF_HEADERS</code>表示把当前虚拟地址设置成为0x08048000 + SIZEOF_HEADERS</li><li><code>tinytext：{*（.text）*(.data)*(.rodata)}</code>第二条是个段转换规则，也就是后面的三个段合并输出到文件tinytext中</li><li><code>/DISCARD/:{*{comment}}</code>第三个意思就是丢弃所有输入文件中的名字为<code>.comment</code>内容，不保存到输出文件中。</li></ul><p>  <strong>默认情况下，<code>.shstrtab、.symtab、.strtab</code>代表段名字符串表，符号表和字符串表，这三种表，链接器在产生可执行文件的时候会自动生成。</strong>——可执行文件中，符号表和字符串是可选的，段名字符串表保存段名，必不可少。</p></li></ul><h2 id="ld链接脚本语法"><a href="#ld链接脚本语法" class="headerlink" title="ld链接脚本语法"></a>ld链接脚本语法</h2><p>这一小节直接看资料，<a href="http://www.aizhuanji.com/a/AWbaBakV.html" target="_blank" rel="noopener">ld链接脚本文件语法解析</a>。平时很难有机会用到这块知识。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://en.wikipedia.org/wiki/ABI" target="_blank" rel="noopener">ABI-Application binary interface</a><br><a href="https://dirtysalt.github.io/html/gcc-asm.html#orgheadline2" target="_blank" rel="noopener">GCC内嵌汇编</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/" target="_blank" rel="noopener">Linux 内核中断内幕</a><br><a href="https://www.zhihu.com/question/27656256" target="_blank" rel="noopener">句柄是什么？</a><br><a href="https://stackoverflow.com/questions/381244/purpose-of-memory-alignment" target="_blank" rel="noopener">Purpose of memory alignment</a><br><a href="http://www.cnblogs.com/azraelly/archive/2012/12/31/2840479.html" target="_blank" rel="noopener">内存地址对齐提升程序性能</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》读书笔记——目标文件</title>
      <link href="/2018/04/02/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
      <url>/2018/04/02/2018/4/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇介绍了<a href="https://www.jianshu.com/p/0753cfe0c7e9" target="_blank" rel="noopener">编译连接的过程</a>，提到了<strong>目标文件</strong>是通过汇编过程生成的，最终链接生成可执行文件，这篇介绍一下目标文件里面到底有什么。</p></blockquote><p>本文导图<br><img src="https://upload-images.jianshu.io/upload_images/664334-11e7545344b9fdc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><h1 id="格式概述"><a href="#格式概述" class="headerlink" title="格式概述"></a>格式概述</h1><p>目标文件相对于最终的可执行文件而言，结构上已经和可执行文件的结构基本一样了。只是还没有经过链接过程，<strong>某些符号、地址还没被重定位</strong>，大部分内容都已经具备了。</p><p>可执行文件的格式在Windows（PE-Portable Executable）和Linux(ELF- Executable Linkable Format)、Mac(Mach-O)不同，前两者都是基于COFF(Common file format)格式的，除此之外还有其他不常见的，如Intel/Microsoft的OMF、Unix a.out、MS-Doc .Com格式等。</p><blockquote><p><strong>广义上将，目标文件与可执行文件格式几乎一样，可以看成同一种类型的文件。</strong></p></blockquote><p>动态链接库（window .dll、Linux .so）及静态链接库（window lib、Linux .a）、Mac(dylb，tbd)都是按照可执行文件的格式存储。<strong>静态库稍微不同，因为他是把很多目标文件集合在一起，需要在头部加上一些索引。也就是包含了很多目标文件的一个目标文件包。</strong></p><p>ELF格式文件更可以做如下归纳（目标文件.o 静态库、可执行文件、动态库）：<br><img src="https://upload-images.jianshu.io/upload_images/664334-516587d9fdafb8c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-d736e7d3986eba37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="查看格式"><a href="#查看格式" class="headerlink" title="查看格式"></a>查看格式</h2><p><strong>file命令查看相应的文件格式。</strong></p><p>Mac下<br><img src="https://upload-images.jianshu.io/upload_images/664334-71dce168ffbae31c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Linux下<br><img src="https://upload-images.jianshu.io/upload_images/664334-ea17bdce31d0a3e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>下面以ELF结构作为分析</p></blockquote><h1 id="浅析目标文件内部结构"><a href="#浅析目标文件内部结构" class="headerlink" title="浅析目标文件内部结构"></a>浅析目标文件内部结构</h1><p>目标文件至少包含编译后的<strong>机器指令代码、数据、和链接所需要的信息比如、符号表、调试信息、字符串</strong>等，下面的内容围绕着这几个部分进行总结。</p><blockquote><p>按照信息的不同属性以节（Section）也叫段（Segment）的形式存储，表示一个一定长度 的区域。这些区域里面分别存储了上诉编译后的信息。</p></blockquote><ul><li>代码段：编译之后的机器指令放在代码段（Code Section），一般是叫<code>.code</code>或 <code>.text</code>。</li><li>数据段：全局变量和静态变量数据放在数据段（Data Section），一般叫<code>.data</code></li><li>BBS段：未初始化的全局变量、未初始化静态变量放在<code>.bbs</code>段。</li></ul><p>具体来讲，下面代码与目标文件对应关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-1701f4c983830d46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>文件头：ELF文件有个文件头，描述整个文件的文件属性，如是否可执行、静态库还是动态库、及入口地址（可执行文件）、目标硬件、操作系统等。<strong>其中还包含一个段表，段表示描述各个段的一个数组，包含各个段在文件的偏移位置、段的属性。</strong>文件头后面就是各个段的内容，比如代码段保存指令，数据段保存数据。——其中段表非常重要。</li></ul><blockquote><p>未初始化的全局变量、局部静态变量虽然默认值都是0，但是没必要在<code>.data</code>段为它们分配空间（浪费），存放0是没必要的。所以放在<code>.bbs</code>段，也就给他们预留个位置而已，没有内容，所以在文件中不占空间。</p></blockquote><p><strong>总体来说，程序代码被编译后分成两种段，程序指令（代码段）和程序数据（数据端及<code>.BSS</code>）</strong></p><p>指令和数据分开的好处：</p><ul><li>指令和数据分别映射到两个虚拟区域，数据可读可写，而指令是只读的，可以设值区域的权限，<strong>防止恶意修改程序指令。</strong>——权限，安全</li><li>分开有利于程序的局部性（在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。）CPU有几大的缓存体系。——局部性原理</li><li>复用，如果系统有多个程序的副本，那么指令都是一样的。<strong>这个也是动态库非常大的优势，节省内存开销</strong>——复用、复用！！！</li></ul><h1 id="实验目标文件内容"><a href="#实验目标文件内容" class="headerlink" title="实验目标文件内容"></a>实验目标文件内容</h1><p>实验代码：<br><img src="https://upload-images.jianshu.io/upload_images/664334-38333c1c79a451f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/664334-3e6cc0136625e1ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>使用objdump -h 查看目标文件内部结构。</p><p>在Mac上实验结果</p><pre><code>objdump -h  hello.ohello.o:    file format Mach-O 64-bit x86-64Sections:Idx Name          Size      Address          Type  0 __text        00000067 0000000000000000 TEXT  1 __data        00000008 0000000000000068 DATA  2 __cstring     00000004 0000000000000070 DATA  3 __bss         00000004 0000000000000120 BSS  4 __compact_unwind 00000040 0000000000000078 DATA  5 __eh_frame    00000068 00000000000000b8 DATA</code></pre><p>在Linux实验结果<br><img src="https://upload-images.jianshu.io/upload_images/664334-97ecf8835873443e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>除了之前讲到的三个段，这里多了<strong>只读数据端，注释端，堆栈提示段。</strong>其中包含了一些属性关键词，如长度（size）、端的位置（File off）、该段是否在文件中存在（Contents）、段的各种属性（Alloc）。<strong>可以看到<code>.bbs</code>段没有contents所以在文件中没有内容。而堆栈提示段size为0</strong>。</p><p>将上面的内容整理一下：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-fe9d523c0fcc7776.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>可以通过size命令查看可执行文件的各个端大小（注意dec所有段的十进制和，hex是16进制的和）</p></blockquote><p>Mac上实验（文件格式是Mach-o）<br><img src="https://upload-images.jianshu.io/upload_images/664334-e774b6151ab30d33.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Linux上实验（文件格式是ELF）<br><img src="https://upload-images.jianshu.io/upload_images/664334-989e073733d03633.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="深入目标文件内部结构"><a href="#深入目标文件内部结构" class="headerlink" title="深入目标文件内部结构"></a>深入目标文件内部结构</h1><p>下面将深入了解目标文件中的各个段，他们的作用及含义。</p><h2 id="核心段"><a href="#核心段" class="headerlink" title="核心段"></a>核心段</h2><p>上面提到过核心段有代码段、数据端、BBS段。下面分别介绍！</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>代码段可以使用objdump的<code>-s</code>参数打印出来，<code>-d</code>可以将包含指令的段反汇编信息。</p><ul><li>最左边是偏移地址，紧跟着的是16进制信息（<strong>每两个数字为一个字节，一般都是以字节位单位查看。</strong>）</li></ul><p>Mac上实验（文件格式是Mach-o）：最前面的部分是反汇编内容，接下来是各个段的内容。</p><pre><code>$ objdump -s -d hello.ohello.o:    file format Mach-O 64-bit x86-64Disassembly of section __TEXT,__text:_fun1:       0:    55     pushq    %rbp       1:    48 89 e5     movq    %rsp, %rbp       4:    48 83 ec 10     subq    $16, %rsp       8:    48 8d 05 61 00 00 00     leaq    97(%rip), %rax       f:    89 7d fc     movl    %edi, -4(%rbp)      12:    8b 75 fc     movl    -4(%rbp), %esi      15:    48 89 c7     movq    %rax, %rdi      18:    b0 00     movb    $0, %al      1a:    e8 00 00 00 00     callq    0 &lt;_fun1+0x1F&gt;      1f:    89 45 f8     movl    %eax, -8(%rbp)      22:    48 83 c4 10     addq    $16, %rsp      26:    5d     popq    %rbp      27:    c3     retq      28:    0f 1f 84 00 00 00 00 00     nopl    (%rax,%rax)_main:      30:    55     pushq    %rbp      31:    48 89 e5     movq    %rsp, %rbp      34:    48 83 ec 10     subq    $16, %rsp      38:    c7 45 fc 00 00 00 00     movl    $0, -4(%rbp)      3f:    c7 45 f8 6f 00 00 00     movl    $111, -8(%rbp)      46:    8b 05 00 00 00 00     movl    (%rip), %eax      4c:    03 05 00 00 00 00     addl    (%rip), %eax      52:    03 45 f8     addl    -8(%rbp), %eax      55:    03 45 f4     addl    -12(%rbp), %eax      58:    89 c7     movl    %eax, %edi      5a:    e8 00 00 00 00     callq    0 &lt;_main+0x2F&gt;      5f:    31 c0     xorl    %eax, %eax      61:    48 83 c4 10     addq    $16, %rsp      65:    5d     popq    %rbp      66:    c3     retqContents of section __text: 0000 554889e5 4883ec10 488d0561 00000089  UH..H...H..a.... 0010 7dfc8b75 fc4889c7 b000e800 00000089  }..u.H.......... 0020 45f84883 c4105dc3 0f1f8400 00000000  E.H...]......... 0030 554889e5 4883ec10 c745fc00 000000c7  UH..H....E...... 0040 45f86f00 00008b05 00000000 03050000  E.o............. 0050 00000345 f80345f4 89c7e800 00000031  ...E..E........1 0060 c04883c4 105dc3                      .H...].Contents of section __data: 0068 54000000 55000000                    T...U...Contents of section __cstring: 0070 25640a00                             %d..Contents of section __bss:&lt;skipping contents of bss section at [0120, 0124)&gt;Contents of section __compact_unwind: 0078 00000000 00000000 28000000 00000001  ........(....... 0088 00000000 00000000 00000000 00000000  ................ 0098 30000000 00000000 37000000 00000001  0.......7....... 00a8 00000000 00000000 00000000 00000000  ................Contents of section __eh_frame: 00b8 14000000 00000000 017a5200 01781001  .........zR..x.. 00c8 100c0708 90010000 24000000 1c000000  ........$....... 00d8 28ffffff ffffffff 28000000 00000000  (.......(....... 00e8 00410e10 8602430d 06000000 00000000  .A....C......... 00f8 24000000 44000000 30ffffff ffffffff  $...D...0....... 0108 37000000 00000000 00410e10 8602430d  7........A....C. 0118 06000000 00000000                    ........# instanza @ InstanzadeMacBook-Pro in ~/Desktop/Temp [12:12:42]$</code></pre><p>Linux实验（文件格式是ELF）<br><img src="https://upload-images.jianshu.io/upload_images/664334-7a9ded57f136dd20.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li><code>contents of section .text</code>就是数据已十六进制打印出来的内容。<strong>中间4列是16进制内容，最右边是.text段的ASCII码形式。</strong></li><li><code>.text</code>段包含是.c文件两个函数的指令，比如第一个字节是0x55,就是func1()函数第一条<code>push %ebp</code>指令，最后一个0xc3代表main函数最后一个指令<code>ret</code></li></ul><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p><code>.data</code>段保存了初始化的全局静态变量和局部静态变量。上面代码中有两个这样的变量，每个变量4个字节一共8个字节。所以<code>.data</code>这个段大小为8个字节。——<strong>这是个非常准确的计算，不会存在多一个、少一个字节的情况</strong></p><p>注意<code>printf</code>的时候，有一个字符串常量<code>“%d\n”</code>。在linux中放到了<code>.rodata</code>段，分别有四个字符<code>%、d、\n（换行符）、空字符</code>。一个字符一个字节（<strong>8位ASCII码</strong>），所以一共四个字节。在Mac上放到了字符串常量区。</p><p>以Mac下例子为例：</p><pre><code>Contents of section __cstring: 0070 25640a00                             %d..</code></pre><p><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">通过查ASCII表</a>，得到对应情况：%——25，d——64，\n(换行符)——0a，空字符（NULL）——00。<strong>刚好和字符串常量区对应</strong></p><p>在来看一起<code>.data</code>段（Mac下）：</p><pre><code> 0060 c04883c4 105dc3                      .H...].Contents of section __data: 0068 54000000 55000000                    T...U...</code></pre><p>根据偏移范围可以知道<code>.data</code>端一共8个字节。<strong>和前面用size看到的不一样，size看到的是12个字节。</strong></p><p>Linux下</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-e7ae7c75b38838f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>可以看到Linux也是8个字节。字节从低到高分别是0x54、0x00、0x00、0x00。<strong>刚好是十进制的84，特别注意这里的顺序，字节从低到高还是从高到底排列涉及到CPU的字节序问题，也就是大端小端。后面四个字节也刚好是85</strong></p></blockquote><h3 id="BBS段"><a href="#BBS段" class="headerlink" title="BBS段"></a>BBS段</h3><p>Mac中的bss段如下：</p><pre><code>Contents of section __bss:&lt;skipping contents of bss section at [0120, 0124)&gt;</code></pre><p>可以知道具体的值放到了0120到0124之间，一共四个字节。</p><p>Linux下<br><img src="https://upload-images.jianshu.io/upload_images/664334-49ca09df5b752756.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>同样也是四个字节。和<code>global_uninit_var</code>、<code>static_var2</code>合起来大小8个字节不符。</p><blockquote><p>BBS段最终是通过符号表决定的。<strong>在Linux下只有static_var2存放到了bbs段。而global_uninit_var没有存放到任何段。只是一个未定义的common符号，这和语言及编译器实现有关。</strong>有一点可以明确——编译单元内部可见的静态变量是存在bbs段的。</p></blockquote><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>ELF中除了<code>.text、.data、.bbs</code>三个最常用的段还有其他段。具体如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-419a8ecaea556589.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>以<code>.</code>开头的都是系统保留的。如果想要自定义端，则不能以<code>.</code>开头。</p><p>GCC提供了扩展机制，可以将变量或者代码放到你指定的段中去。用以下方式实现：<br><img src="https://upload-images.jianshu.io/upload_images/664334-953bd942328af0c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上只是ELF文件的轮廓，下面用一张图总结：<br><img src="https://upload-images.jianshu.io/upload_images/664334-e377fec2b2c7f2a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>几点说明一下：</p><ul><li>文件头：描述怎个文件的基本属性，文件版本，目标机器型号，程序入口地址。</li><li>段表：描述了ELF文件包含所有段的信息，比如每个段的段名，长度，文件中的偏移，读写权限，和其他属性。</li></ul><p>下面开始从文件头开始</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>Linux用readelf来查看文件头，Mac用otool查看（<code>otool -h hello.o</code>）</p><p>在Linux中<br><img src="https://upload-images.jianshu.io/upload_images/664334-88854ba073d056b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-507e592dda3e94a0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>系统定义文件头数据结构：</p><pre><code>#define EI_NIDENT 16typedef struct {    unsigned char e_ident[EI_NIDENT];    Elf32_Half e_type;    Elf32_Half e_machine;    Elf32_Word e_version;    Elf32_Addr e_entry;    Elf32_Off e_phoff;    Elf32_Off e_shoff;    Elf32_Word e_flags;    Elf32_Half e_ehsize;    Elf32_Half e_phentsize;    Elf32_Half e_phnum;    Elf32_Half e_shentsize;    Elf32_Half e_shnum;    Elf32_Half e_shstrndx;} Elf32_Ehdr;</code></pre><p>各个字段代表什么意思根据名称就知道了。<strong>关键要知道在哪里定义这些常数的。ELF文件头定义在<code>user/include/elf</code>。mach.o类型的目标文件也有对应的头文件。</strong></p><p>下图是对readelf和ELF头文件定义的各个成员的含义解释。<strong>这里先大致了解下，后面会详解！</strong><br><img src="https://upload-images.jianshu.io/upload_images/664334-cba1a50307ebdf53.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-842bdaf10d69fd72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="ELF魔数（e-ident前四个字节）"><a href="#ELF魔数（e-ident前四个字节）" class="headerlink" title="ELF魔数（e_ident前四个字节）"></a>ELF魔数（e_ident前四个字节）</h3><p>通过readelf之后看到最前面的16个字节刚好是e_ident，这16个ELF标准用来标识ELF文件平台属性，比如ELF字长（32位、64位），字节序、文件版本等。</p><p>下表是对e_ident数组各个成员的说明：<br><img src="https://upload-images.jianshu.io/upload_images/664334-9a6f283fdf4a573a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>前四个字节是所有ELF文件必须相同的标识码：0x7F、0x45、0x4c、0x46。第一个字节赌赢DEL控制符，后三个对应ELF。所有的可执行文件最开始的几个字节都是魔数，<strong>用来确认文件类型，操作系统在加载的时候会确认魔数是否正确，不正确就不会加载。</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/664334-27fd9f6b8c9991b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>下一个字节标识文件类型;0x01标识32，0x02标识64</li><li>第六个字节是字节序</li><li>第七个字节：规定ELF文本版本</li><li>后面9个字节：标准还没有定义，一般填0</li></ul><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>e_type表示文件类型，之前提到过3种ELF文件类型。如下表<br><img src="https://upload-images.jianshu.io/upload_images/664334-836ba29f5509b72e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="机器类型"><a href="#机器类型" class="headerlink" title="机器类型"></a>机器类型</h4><p>e_machine表示平台属性</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-fe2d596fc75f1192.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>ELF最终段结构由段表决定，编译器、链接器和 装载器都是依赖段表来定位和访问各个端的属性。<strong>段表的位置有ELF文件头的e_shoff决定，如上面的例子段表的偏移为0x118</strong>。</p><p>直接来查看所有的段信息</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-6f5dd912efd77e4d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>这里的数据其实在代码层面来讲都是由对应的数据结构的。无论是mach.o还是ELF。比如这里的Elf32_Shdr结构体是对一个段的封装，段表也就是由Elf32_Shdr组成的数组。对上图而言一个有11个这样的元素。</p></blockquote><p>段表元素数据结构<br><img src="https://upload-images.jianshu.io/upload_images/664334-b425e4a10c651f62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><pre><code> typedef struct {    Elf32_Word sh_name;    Elf32_Word sh_type;    Elf32_Word sh_flags;    Elf32_Addr sh_addr;    Elf32_Off sh_offset;    Elf32_Word sh_size;    Elf32_Word sh_link;    Elf32_Word sh_info;    Elf32_Word sh_</code></pre><p>各个字段的含义<br><img src="https://upload-images.jianshu.io/upload_images/664334-bf37f670c7728af3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p>现在把整个.o文件所有段的位置及长度都分析清楚了。</p><ul><li>段表长度为0x1b8，一共440个字节，包含11个段描述符，每个段描述符为40个字节，这个长短刚好是结构Elf32_Shdr的长度。</li><li>文件最后一段.re.text结束后，长度为0x450也就是1104个字节，刚好是.o文件的大小。</li></ul><p><strong>中间有段表和.rel.text都因为对齐的原因，与前面的短之间有一个字节和两个字节的间隔。注意这里是为了对齐。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-5ab9706cb7db5a0e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="段类型（sh-type、sh-flags）"><a href="#段类型（sh-type、sh-flags）" class="headerlink" title="段类型（sh_type、sh_flags）"></a>段类型（sh_type、sh_flags）</h3><p>段名（sh_name）只有在编译、链接过程有意义，但不能真正表示段的类型，段名（sh_name）其实只是一个索引指向字符串表（SHT_STRTAB）的某个位置，在编译器和链接器中起作用的是段类型字段和段标志位字段。</p><p>段类型：<br><img src="https://upload-images.jianshu.io/upload_images/664334-99d00185f25c7be7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>段标志位<br><img src="https://upload-images.jianshu.io/upload_images/664334-24f2db64979a9b77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="系统保留段"><a href="#系统保留段" class="headerlink" title="系统保留段"></a>系统保留段</h4><p><img src="https://upload-images.jianshu.io/upload_images/664334-cd2163812a15c1c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7775d17ae1b27584.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h3><p>段的类型与链接相关的话都需要sh_link、sh_info，无论是动态库还是静态库。比如重定位表，符号表。对于其他段这两个成员没意义<br><img src="https://upload-images.jianshu.io/upload_images/664334-d603060caf3e3926.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="重定位表（段类型SHT-REL）"><a href="#重定位表（段类型SHT-REL）" class="headerlink" title="重定位表（段类型SHT_REL）"></a>重定位表（段类型SHT_REL）</h2><p>在刚才的段中，有一个<code>.rel.text</code>的短，类型（sh_type）为<code>SHT_REL</code>，也就是这个段包含的是重定位表。</p><blockquote><p>链接器在处理目标文件的时候，需要对目标文件某些部分重定位，虽然在代码段和数据端中用的是绝对地址的引用位置。重定位信息都记录在重定位表里面，每一个需要重定位的代码段或数据段都会有一个相应的重定位表，比如上面的<code>.rel.text</code>就是对<code>.text</code>的重定位表。因为<code>.text</code>段有一个绝对地址的引用，就是printf函数的调用。<strong>这里的决定地址引用也就是写死的地址</strong>。而<code>.data</code>段没有绝对地址引用。</p></blockquote><h2 id="字符串表（段类型SHT-STRTAB）"><a href="#字符串表（段类型SHT-STRTAB）" class="headerlink" title="字符串表（段类型SHT_STRTAB）"></a>字符串表（段类型SHT_STRTAB）</h2><p>ELF用到很多字符串 ，如段名、变量名、因为字符串长度不确定，所以固定的解构表示比较困难。<strong>一种很常见做法就是把字符串集中放到一个表中，使用字符串的时候在表中的偏移来引用字符串。</strong>如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-1ab314297d1f4d88.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>字符串表一般有两种一种用来保存普通的字符串，比如符号的名字；另一种段表字符串用来来保存段表中用到的字符串，比如段表名。字符串表中包含有若干个以’null’结尾的字符序列。</p><blockquote><p>只要分析ELF头文件，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件。</p></blockquote><h2 id="符号表（symbol-table）"><a href="#符号表（symbol-table）" class="headerlink" title="符号表（symbol table）"></a>符号表（symbol table）</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>假如B文件要用到A文件的函数foo，那么在目标文件A定义了函数foo，目标文件B引用了A中的foo函数。每个函数、变量都有自己的名字，将函数名、变量名统称为符号名。</p><p>每一个目标文件都会一个相应的符号表，记录了目标文件所要用到的符号，<strong>每个定义的符号有一个对应的值，叫做符号值</strong>，<strong>对于变量和函数来说，符号值就是他们的地址。</strong>出了变量和函数外还有其他几种符号，可以将符号表中的符号进行分类。</p><p>符号表包含的信息用于定位和重定位程序中的符号定义和引用。目标文件的其它部分<strong>通过一个符号在这个表中的索引值来使用 该符号</strong>。索引值从 0 开始计数，但值为 0 的表项(即第一项)并没有实际的意义， 它表示未定义的符号。这里用常量 STN_UNDEF 来表示未定义的符号。</p><p>符号一般有如下类型：</p><ul><li>定义在目标文件的全局符号：可以被其他目标文件引用。如上面的func1,main,global_init_var</li><li>引用其他目标文件中的全局符号：<strong>一般叫做外部符号，如 printf</strong></li><li>段名：由编译器产生，它的值就是该段的其实起始地址。如<code>.text</code>、<code>.data</code>。</li><li>局部符号：只在编译单元内部可见，如static_var、static_var2。调试器可以是用哪个这些符号来分析程序。对于链接没什么作用，链接器也会忽略他们。</li><li>行号符号：目标文件指令与源代码中代码行的对应关系。</li></ul><p><strong>可以使用<code>nm</code>查看符号表的内容</strong></p><p>Mac上<br><img src="https://upload-images.jianshu.io/upload_images/664334-32e798ca70f33443.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Linux上<br><img src="https://upload-images.jianshu.io/upload_images/664334-3baf5e25a61f1f6f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="符号表结构（SHT-SYMTAB）"><a href="#符号表结构（SHT-SYMTAB）" class="headerlink" title="符号表结构（SHT_SYMTAB）"></a>符号表结构（SHT_SYMTAB）</h3><p>符号表示文件中的一个段，段名<code>.symtab</code>。符号表数据结构比较简单Elf32_sym（符号表项），每个结构体对应一个符号。</p><p>其结构体如下：</p><pre><code> typedef struct {  Elf32_Word st_name;  Elf32_Addr st_value;  Elf32_Word st_size;  unsigned char st_info;  unsigned char st_other;  Elf32_Half st_shndx;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/664334-784ec85152367960.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>各个字段的含义<br><img src="https://upload-images.jianshu.io/upload_images/664334-4196d9a16ecbb098.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="符号类型和属性（st-info）"><a href="#符号类型和属性（st-info）" class="headerlink" title="符号类型和属性（st_info）"></a>符号类型和属性（st_info）</h3><p>由低4位表示符号类型，高28位表示符号属性信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-b4f89eaef8c0de85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="符号所在段（st-shndx）"><a href="#符号所在段（st-shndx）" class="headerlink" title="符号所在段（st_shndx）"></a>符号所在段（st_shndx）</h3><p>如果符号定义在本目标文件，则这个成员表示符号所载的段在段表中的下标。因为符号是为段而定义，在段中被引用。本数据成员即指明了相关联的段。本数据成员是一个索引值，它指向相关联的段在段表中的索引。在重定位过程中，段的位置会改变，本数据成员的值也随之改变，继续指向段的新位置。</p><p>如果没有定义在本目标文件，则sh_shndx有些特殊。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-30fb68169faaa976.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="符号值（st-value）"><a href="#符号值（st-value）" class="headerlink" title="符号值（st_value）"></a>符号值（st_value）</h3><p>每个符号都有一个对应的值。如果是一个变量或者函数，符号值就是其地址。总的来说有以下几种情况：</p><ul><li>如果是符号定义且不是<code>Common块</code>类型（st_shndx不为SHN_COMMON），则st_value表示该符号在段中的偏移，即符号所对应的函数、变量位于st_shndx指定段。这种是最常见的，比如func1、main、global_init_var。</li><li>如果是COMMON块的类型，<strong>则st_value表示该符号的对齐属性，如global_uninit_var</strong></li><li><strong>在可执行文件中，st_value表示符号的虚拟地址。</strong></li></ul><h3 id="符号表内容解析"><a href="#符号表内容解析" class="headerlink" title="符号表内容解析"></a>符号表内容解析</h3><p>内容如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-142d6e8abf7a6dd4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>第一列表示符号表数组下标，从0开始共15个符号</li><li>第二列就是符号值——st_value</li><li>第三列Size为符号大小——st_size</li><li>第四列、第五列分别为符号类型和绑定信息，对应st_info的低四位和高28位</li><li>第六列不知道</li><li>第七列表示符号所属的段——st_shndx</li><li>第八列表示符号名称</li></ul><p>根据前面的内容做出如下解析：</p><ul><li>func1、main是函数所有在代码段，代码段Ndx为1，所以.text为1.并且类型是STT_Func，并且是全局可见，所以是STB——GLOBAL。</li><li>global_uninit_var是一个SHN_COMMON类型的符号，本身并没有在BSS段。</li><li>….</li><li>依次类推可以把各个符号都解析出来</li></ul><p>需要说明的：static_var和static_var2变成了static_var.1533和static_var.1534，是因为进行符号修正。其次绑定的属性是STB_LOCAL，表示只在编译单元可见。类型是STT_SECTION类型的符号，表示下标为Ndx段的短名。但是符号没有显示。比如2号符号Ndx为1那么就是.text段。那么符号名字就是<code>.text</code>。可以使用<code>objdump -t</code>查看段名符号。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-432114f2e2eb3f78.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>当使用链接器链接的时候，链接器会定义很多特殊符号，这些特殊符号没有在程序定义，但是可以直接声明并应用它。链接器将这些特殊符号放在了链接脚本中，链接器会在程序最终链接为可执行文件的时候，将其解析为正确的值。</p><p>常见特殊符号<br><img src="https://upload-images.jianshu.io/upload_images/664334-779d6ab8c9b8107f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="符号修饰、函数签名（防止冲突）"><a href="#符号修饰、函数签名（防止冲突）" class="headerlink" title="符号修饰、函数签名（防止冲突）"></a>符号修饰、函数签名（防止冲突）</h3><p>最开始编译器产生目标文件的时候，符号名和相应的变量函数名一样。但是如果已经定义这些符号就会产生目标文件冲突。为了解决目标文件冲突，就在对应的符号名签名加一些字符以示区分。如在符号名前、后加上<code>_</code>。</p><p>如果模块较多，命名规范不严格，同样可能导致冲突。于是就增加了命名空间的方法来解决。</p><blockquote><p>所以看到上面的static_var和static_var2变成了static_var.1533和static_var.1534。也就是进行了一次符号修饰。</p></blockquote><h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h4><p>C++强大而复杂，为了支持C++特性，发明了符号修饰和符号改编机制。</p><p>对于不同类，同名函数，引入了一个函数签名的概念。函数签名包含一个函数的信息，函数名，参数类型及所在的命名空间、其他细心，用于识别不同的函数。</p><p>编译器在链接处理符号的时候，会使用名称修饰的方法，使得每个函数签名对应一个修饰后的名称。如下图：<br><img src="https://upload-images.jianshu.io/upload_images/664334-c3af654d08f6ac36.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="弱符号、强符号（）"><a href="#弱符号、强符号（）" class="headerlink" title="弱符号、强符号（）"></a>弱符号、强符号（）</h3><p>经常在编程中将一个符号重复定义，如果出现定义错误则说明这种事强符号。<strong>有些符号可以定义为弱符号，比如未初始化的全局变量</strong>，也可以使用<code>__attribut__((weak))</code>定义一个强符号为弱符号。</p><p>它们的规则如下：</p><ul><li>不允许强符号被多次定义，也就是不同目标文件不能有相当的强符号（iOS中经常出现的符号冲突就是这个意思）</li><li>如果符号在某个目标文件是强符号，其他文件是弱符号，那么选择强符号</li><li>如果在所有文件中都是弱符号则选择其中占空间最大的一个</li></ul><h3 id="弱引用、强引用"><a href="#弱引用、强引用" class="headerlink" title="弱引用、强引用"></a>弱引用、强引用</h3><p><strong>注意不是iOS中强弱引用</strong></p><p>如果没有找到该符号的定义，链接器就会报未定义错误这种成为强引用。与之相对的是弱引用，如果是弱引用，链接器不认为是个错误，一般对未定义的弱引用，链接器默认为0，或者其他值，以便程序识别。<strong>在动态库中使用到，和COMMON块概念联系很紧密</strong></p><p>可以使用<code>__attribute__((weakref))</code>扩展自声明对一个外部函数为弱引用。如果把它编译为可执行文件，并不会报链接错误。<strong>但是当运行的时候，就会发生非法地址访问。</strong></p><p>可以用if加以判断，防止这种情况。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-3fbe0477c63e73c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>这种弱符号和弱引用对于动态库来讲非常非常有用，比如动态库中定义的弱符号可以被用户定义的强符号覆盖，使得程序可以使用自定义版的库函数。</strong></p><h2 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h2><p>目标文件还可能保存调试信息，比如在函数里面设置断点，可以监视变量变化，可以单步行进等，前提都是编译器必须提前将源代码与目标代码之间的关系（如目标代码中的地址对应源代码中的哪一行、函数和变量的类你先给，结构体的定义，字符串保存到目标文件里面）保存到目标文件。</p><p><strong>如果在gcc 中加入<code>-g</code>参数就可以在目标文件里面加上调试信息。</strong>如<code>gcc -c -g hello.c</code></p><p>比如：</p><pre><code>objdump -h hello.ohello.o:    file format Mach-O 64-bit x86-64Sections:Idx Name          Size      Address          Type  0 __text        00000067 0000000000000000 TEXT  1 __data        00000008 0000000000000068 DATA  2 __cstring     00000004 0000000000000070 DATA  3 __bss         00000004 00000000000004e4 BSS  4 __debug_str   0000009e 0000000000000074 DATA  5 __debug_loc   00000000 0000000000000112 DATA  6 __debug_abbrev 00000087 0000000000000112 DATA  7 __debug_info  000000e0 0000000000000199 DATA  8 __debug_ranges 00000000 0000000000000279 DATA  9 __debug_macinfo 00000001 0000000000000279 DATA 10 __apple_names 000000c8 000000000000027a DATA 11 __apple_objc  00000024 0000000000000342 DATA 12 __apple_namespac 00000024 0000000000000366 DATA 13 __apple_types 00000047 000000000000038a DATA 14 __compact_unwind 00000040 00000000000003d8 DATA 15 __eh_frame    00000068 0000000000000418 DATA 16 __debug_line  00000062 0000000000000480 DATA</code></pre><p>ELF采用一个DWARF的标准的调试信息格式。在Xcode中也有DWARF的身影。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-0c6d11a7c8c57c98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>调试信息在目标文件和可执行文件中占用很大的空间，往往比程序的代码和数据大很多倍（<strong>这一点在iOS开发中用Instrument调试的时候最终就是用得这个文件实现的。</strong>）</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这一部分内容比较多，主要是解析目标文件格式。如文件头、段、段表、重定位表、符号表、字符串表各自的数据结构是如何的。<strong>其实对ELF文件解析的内容内容远远不止这些，也有专门的官方文档对ELF格式记性详细的说明。</strong></p><p><strong>最重要的是明白各个部分的关系</strong></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://zh.wikipedia.org/wiki/Category:%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">可执行文件格式</a><br><a href="https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-1/elf_format.html" target="_blank" rel="noopener">理解ELF文件格式</a><br><a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf" target="_blank" rel="noopener">ELF文件格式分析</a><br><a href="https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats" target="_blank" rel="noopener">Comparison of executable file formats</a><br><a href="https://sourceforge.net/projects/machoview/files/?source=navbar" target="_blank" rel="noopener">MachOView</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》读书笔记——编译和连接</title>
      <link href="/2018/03/29/2018/3/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/03/29/2018/3/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇简单回顾操作系统相关的知识，这篇正式开始进入编译链接部分。</p></blockquote><p>开发工具IDE一般都把编译和链接都集成进去了，这个过程叫做构建（build），就算是一个简单的<code>gcc hello.c</code>命令就包含非常复杂的过程。下面介绍下将一步一步介绍这一切是怎么实现的。</p><a id="more"></a><h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>一个简单Hello World程序</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当使用gcc来编译的时候</p><pre><code>gcc hello.c</code></pre><p>然后运行该程序</p><pre><code>./ a.out</code></pre><blockquote><p>上面总共经历了四个步骤，分别是预处理、编译、汇编和链接。如下图所示：</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/664334-a78b62ae6e55bbf0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>gcc可以通过参数来指定具体的编译步骤，参数如下：</p><pre><code>-o：指定生成的输出文件；-E：仅执行编译预处理；-S：将C代码转换为汇编代码；-wall：显示警告信息；-c：仅执行编译操作，不进行连接操作。</code></pre><h2 id="预编译（输出-i文件）"><a href="#预编译（输出-i文件）" class="headerlink" title="预编译（输出.i文件）"></a>预编译（输出.i文件）</h2><p>c文件预处理为<code>.i</code>文件，cpp预处理为<code>.ii</code>文件。可以通过参数控制gcc当前操作的步骤。前面讲过用<code>-E</code>仅仅执行预编译</p><pre><code>gcc -E hello.c -o hello.i</code></pre><p><strong>由于预编译后的文件内容很长就不贴在这里了，放在了本文你末尾，有兴趣的可以看一看</strong>。预编译是处理源代码中的<code>#</code>开始的预编译指令，比如<code>#include  #define</code>。</p><p>规则如下（可以参看预编译后的内容对比）：</p><ul><li>将所有<code>#define</code>删除，并且展开所有的宏定义。</li><li>处理所有的条件预编译指令，如<code>#if #ifdef #eif #else #endif</code></li><li>处理<code>#include</code>预编译指令，将被包含的文件Haru到预编译指令的位置。<strong>这个过程可能是一个递归的过程，有可能文件中还包含其他文件</strong>。</li><li>删除所有的注释</li><li><strong>添加行号及文件标识符。如<code># 2 &quot;hello.c&quot; 2</code>，用于编译器编译时产生调试用的行号信息。</strong>——格式没有弄懂？</li><li>保留所有的#pragma编译指令，编译器需要</li></ul><p><strong>如果当无法判断宏定义是否正确或者文件包含是否正确时，可以查看编译后的文件来查找问题。</strong></p><blockquote><p>根据预编译后的<code>.i</code>文件，没弄明白的是为什么预编译之后很多文件会重复引入？</p></blockquote><h2 id="编译（输出目标文件、内涵汇编代码）"><a href="#编译（输出目标文件、内涵汇编代码）" class="headerlink" title="编译（输出目标文件、内涵汇编代码）"></a>编译（输出目标文件、内涵汇编代码）</h2><p>编译是程序构建的核心部分，也最复杂。需要在这个过程中完成<strong>词法分析、语法分析、语义分析及优化产生的汇编代码</strong>。</p><pre><code>gcc -S hello.i -o hello.s</code></pre><p>现在一般GCC把预编译和编译都合在一起了。但是也可以分开实现！<strong>GCC的命令其实是对一些编译程序的包装而已，它根据不同的参数去调用预编译程序（cc1）、汇编器（as）、链接器（ld）</strong></p><blockquote><p>后面会详细介绍</p></blockquote><h2 id="汇编（输出-o文件）"><a href="#汇编（输出-o文件）" class="headerlink" title="汇编（输出.o文件）"></a>汇编（输出.o文件）</h2><p>汇编器将上面生成的汇编代码转为机器可以执行的指令。每一条汇编语句对应一条机器指令。所以汇编过程比编译过程简单，没有复杂的语法、语义，也不需要优化指令。最终输出的是目标文件.o。</p><pre><code>as -c hello.s -o hello.o</code></pre><p>汇编之后的.o文件是二进制格式的。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>由于作者实验的系统是Linux，链接的部分需要用到Linux中的库及.o文件。所以实验在本地做不了</strong></p><p>链接总的命令：<br><img src="https://upload-images.jianshu.io/upload_images/664334-435fad524d804e40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>如果把路径都省略了<br><img src="https://upload-images.jianshu.io/upload_images/664334-7849439b9d027cea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>其中很多不知道什么意思，crt1.o、crti.o文件是什么（Mac中能找到），参数lgcc、lgcc_en是什么意思</strong>。后面在讲</p><p>如果直接执行<code>ld -static helloworld.o</code>，则会报找不到符号的错误。</p><pre><code>ld: warning: -macosx_version_min not specified, assuming 10.11Undefined symbols for architecture x86_64:  &quot;_printf&quot;, referenced from:      _main in helloworld.o  &quot;start&quot;, referenced from:     -u command line optionld: symbol(s) not found for inferred architecture x86_64</code></pre><h2 id="编译器（核心）"><a href="#编译器（核心）" class="headerlink" title="编译器（核心）"></a>编译器（核心）</h2><p>编译器就是将高级语言翻译为机器语言的一个工具。<strong>如果直接使用机器指令或汇编来写，一方面效率低，一方面只能为一种CPU编写，而不能移植。</strong></p><p>编译过程一般分为6步（扫描、语法分析、词法分析、语义分析、源代码优化、代码生成和目标代码优化）：<br><img src="https://upload-images.jianshu.io/upload_images/664334-942e997ad45940ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>下面用这段代码为例：<br><img src="https://upload-images.jianshu.io/upload_images/664334-f72bf834e7d179a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="词法分析（记号）"><a href="#词法分析（记号）" class="headerlink" title="词法分析（记号）"></a>词法分析（记号）</h3><p>源代码首先被载入扫描器（语法分析器）。扫描器主要作用就是进行词法分析。运用类似有限状态机的算法将源代码字符序列分隔为一系列的记号。其主要作用就是分隔为一系列的记号。</p><p>如上面代码词法分析结果：<br><img src="https://upload-images.jianshu.io/upload_images/664334-47ea45389559901e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/664334-bb0d34d1730f29bc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>把这些记号归类可以有：关键字、标识符、字面量（包含数字、字符串）、特殊符号（加、等号）。然后将这些记号分别存入到对应的表中，以便后续使用。比如标识符放到符号表，数字、字符串放到文字表。</p><h3 id="语法分析（语法树）"><a href="#语法分析（语法树）" class="headerlink" title="语法分析（语法树）"></a>语法分析（语法树）</h3><p>语法分析器读取上面词法分析的字符流、从中识别出<strong>语素</strong>、最后生成不同类型的标记。其间一旦发现无效标记，便会报错。</p><p>对扫描器产生的记号进行语法分析会生成语法树，语法树就是以表达式为结点的树。一个语句可能由多个表达式组成，如上面的例子。最终产生的语法树如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-7726d8fe60d20be8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>解读一下：整个语句看做是一个赋值表达式，左边是要给数组表达式，右边是一个乘法表达式，数组表达式由连个符号表达式组成。<strong>符号和数字是最小的表达式，所以作为整个语法书的结点</strong>。同时优先级和含义也会在这个过程中确定下来，比如乘法优先级比加法搞。</p><p><strong>如果出现表达式不合法，比如括号不匹配，缺少什么操作符等，编译器就会报语法分析错误。</strong></p><h3 id="语义分析（标识类型）"><a href="#语义分析（标识类型）" class="headerlink" title="语义分析（标识类型）"></a>语义分析（标识类型）</h3><p>语法分析主要是完成对表达式的语法层面的分析，但是不了解这个语句是否真的有含义。比如c语言两个指针做乘法是没有意义的，但语句是合法的。<strong>编译能分析的只能是静态语义，也即是在编译阶段可以确定的语义。动态语义只能在运行期才能确定。</strong></p><p>常见的静态语义包括声明和类型匹配、类型转换。比如浮点表达式赋值给整型表达式，隐含着浮点转整型的过程；浮点赋值给指针的时候，语义分析这个类型不匹配，编译器也会报错。动态最长见得就是将0作为除数就是运行期语义错误。</p><p><strong>经过语义分析极端，整个语法树表达式都被标识了类型。</strong><br><img src="https://upload-images.jianshu.io/upload_images/664334-794cd4e5a54375f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="中间语言生成（跨平台）"><a href="#中间语言生成（跨平台）" class="headerlink" title="中间语言生成（跨平台）"></a>中间语言生成（跨平台）</h3><p>编译器有很多层次优化，并且在源代码就会有优化。<strong>这里提到的是源码级别的而优化器。</strong></p><p>比如源码级别的优化针对上面的（2+6）表达式就会直接优化为8，因为这个值在编译期就可以确定了。最终生成如下语法树<br><img src="https://upload-images.jianshu.io/upload_images/664334-36ed6931418b546d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>直接在语法树上做优化比较困难，<strong>所以源代码优化器往往把语法树转换为中间代码，他是语法树的顺序表示</strong>。非常接近目标代码，但是不保护数据尺寸，变量地址，寄存器名字等。</p></blockquote><p>中间有很多种，比如三地址码和P-代码。</p><p>三地址码：x = y op z<br>表示把变量y和z操作以后赋值给x。因为三个地址码语句有三个变量地址因此得名。</p><p>上面的语法树转为三地址码如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-de0cb0b209fd95c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里利用几个临时变量，优化程序会将2+6计算出来，得到t1=6然后将t1带入后面的代码。其实还可以省略t3。因为t2可以复用。最终简化如下：<br><img src="https://upload-images.jianshu.io/upload_images/664334-158dd3adfccde8f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/664334-bc6082b86ee16cdb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>中间代码使得编译器分为前端和后端，前端负责产生平台无关的中间代码，后端将中间代码转为平台相关的代码。如果是跨平台的编译器，可以针对不同的平台使用同一个前端，不同的平台用多个后端。</p><h3 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h3><p>中间代码之后就术语编译器后端，<strong>主要包含代码生成及目标代优化</strong>。</p><p>代码生成将中间代码转换为目标的机器代码，这个过程依赖于机器，不同的机器有不同的字长，寄存器，整数数据类型及浮点数类型。上面生成的中间代码会可能会生成如下代码序列（X86下的汇编语言 ）</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-b25edee1e6f603d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>高级编程语言本身非常复杂，如C++的定义极为复杂，目前没有任何一个编译器完整支持C++所有特性。其次CPU异常复杂，本身采用了流水线、多发射、超标量等特性，为了支持这些特性，编译器也异常复杂，尤其是表一起支持多硬件平台。</p><blockquote><p>经过了扫描、语法分析、语义分析，源代码优化、代码生成及目标代码优化，最终编译为了目标代码。但是目标代码中的变量如index、array地址还没确定。<strong>如果index、array在同一编译单元里面，那么编译器可以为index和array分配内存空间，确定地址，如果是定义在其他程序模块，则还需要链接其他模块</strong></p></blockquote><h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>符号（Symbol）这个概念随着汇编语言的普及而迅速被使用，<strong>用来表示一个地址。可以使一段子程序（函数的其实地址），也可以是一个变量的地址。</strong></p><p>重用，划分更小的粒度，最开始程序时写在一个文件中，后来拆分为多个模块。</p><p>模块之间如何组合可以归结为模块之前如何通信，最常见的就是C/C++这种静态语言两章方式：一种模块间函数调用，一种是模块间变量访问。函数调用必须知道目标函数的其实地址，变量访问也需要知道变量地址。</p><blockquote><p><strong>最终归结为一种方式，那么就是模块间符号引用，模块间通过符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块搞好少了那个区域——拼接过程就是链接</strong></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/664334-de49295cbfc931ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="模块拼装"><a href="#模块拼装" class="headerlink" title="模块拼装"></a>模块拼装</h4><p>链接的主要内容就是将各个模块之间相互引用的部分都处理好，是模块之间能够正确的衔接。<strong>本质就是将依稀额之灵对其他符号地址的引用加以修正。</strong></p><blockquote><p>链接过程包含<strong>地址空间分配、符号决议和重定位</strong></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/664334-948a3bcaf9a8eaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>每个模块的源代码进过编译器便以为目标文件，目标文件和库一起链接为最终的可执行文件。最常见的就是运行时库（Runtime Library），<strong>它是支持程序运行的基本函数集合。</strong>库本身是一组目标文件的包，包含一些常用代码编译为目标文件打包之后的集合。</p><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>在链接过程中，对其他定义在目标文件中的函数、变量调用的指令都需要重新调整，结合CPU指令来理解。</p><p>假设有个全局变量var目标文件在目标文件A里面定义，现在在目标文件B要访问这个全局变量，比如执行var = 42这段代码。对应的汇编<br><img src="https://upload-images.jianshu.io/upload_images/664334-ba8a1a84010479d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>现在编译目标文件得到这个机器码：<br><img src="https://upload-images.jianshu.io/upload_images/664334-1c61d36b9bf320f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>由于目标文件并不知道var的变量地址，所以编译器没有办法确认，这里默认将目标地址置位0，<strong>等待编译器在链接目标文件A、B的时候在将其修正。</strong></p><p>加入A、B链接之后，变量var的地址为0x1000，那么连接器就会把这个目标地址修正为0x1000。</p><blockquote><p>上面的这个过程就是<strong>重定位</strong>，修正的地方叫做重定位入口。</p></blockquote><h2 id="目标文件与可执行文件对比"><a href="#目标文件与可执行文件对比" class="headerlink" title="目标文件与可执行文件对比"></a>目标文件与可执行文件对比</h2><p>这里用的工具是hooper，在iOS逆向的时候经常用到</p><p>目标文件hello.o的内容<br><img src="https://upload-images.jianshu.io/upload_images/664334-fce0a70915a80657.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>可执行文件a.out的内容<br><img src="https://upload-images.jianshu.io/upload_images/664334-5e13451e2731a94b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上对比就能看到，目标文件与可执行文件的差别很大。可执行文件中包含了其他.o文件的符号。</p><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><h3 id="原程序"><a href="#原程序" class="headerlink" title="原程序"></a>原程序</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预编译后的内容"><a href="#预编译后的内容" class="headerlink" title="预编译后的内容"></a>预编译后的内容</h3><pre><code># 1 &quot;hello.c&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 331 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;hello.c&quot; 2# 1 &quot;/usr/include/stdio.h&quot; 1 3 4# 64 &quot;/usr/include/stdio.h&quot; 3 4# 1 &quot;/usr/include/sys/cdefs.h&quot; 1 3 4# 587 &quot;/usr/include/sys/cdefs.h&quot; 3 4# 1 &quot;/usr/include/sys/_symbol_aliasing.h&quot; 1 3 4# 588 &quot;/usr/include/sys/cdefs.h&quot; 2 3 4# 653 &quot;/usr/include/sys/cdefs.h&quot; 3 4# 1 &quot;/usr/include/sys/_posix_availability.h&quot; 1 3 4# 654 &quot;/usr/include/sys/cdefs.h&quot; 2 3 4# 65 &quot;/usr/include/stdio.h&quot; 2 3 4# 1 &quot;/usr/include/Availability.h&quot; 1 3 4# 190 &quot;/usr/include/Availability.h&quot; 3 4# 1 &quot;/usr/include/AvailabilityInternal.h&quot; 1 3 4# 191 &quot;/usr/include/Availability.h&quot; 2 3 4# 66 &quot;/usr/include/stdio.h&quot; 2 3 4# 1 &quot;/usr/include/_types.h&quot; 1 3 4# 27 &quot;/usr/include/_types.h&quot; 3 4# 1 &quot;/usr/include/sys/_types.h&quot; 1 3 4# 33 &quot;/usr/include/sys/_types.h&quot; 3 4# 1 &quot;/usr/include/machine/_types.h&quot; 1 3 4# 32 &quot;/usr/include/machine/_types.h&quot; 3 4# 1 &quot;/usr/include/i386/_types.h&quot; 1 3 4# 37 &quot;/usr/include/i386/_types.h&quot; 3 4typedef signed char __int8_t;typedef unsigned char __uint8_t;typedef short __int16_t;typedef unsigned short __uint16_t;typedef int __int32_t;typedef unsigned int __uint32_t;typedef long long __int64_t;typedef unsigned long long __uint64_t;typedef long __darwin_intptr_t;typedef unsigned int __darwin_natural_t;# 70 &quot;/usr/include/i386/_types.h&quot; 3 4typedef int __darwin_ct_rune_t;typedef union { char __mbstate8[128]; long long _mbstateL;} __mbstate_t;typedef __mbstate_t __darwin_mbstate_t;typedef long int __darwin_ptrdiff_t;typedef long unsigned int __darwin_size_t;typedef __builtin_va_list __darwin_va_list;typedef int __darwin_wchar_t;typedef __darwin_wchar_t __darwin_rune_t;typedef int __darwin_wint_t;typedef unsigned long __darwin_clock_t;typedef __uint32_t __darwin_socklen_t;typedef long __darwin_ssize_t;typedef long __darwin_time_t;# 33 &quot;/usr/include/machine/_types.h&quot; 2 3 4# 34 &quot;/usr/include/sys/_types.h&quot; 2 3 4# 55 &quot;/usr/include/sys/_types.h&quot; 3 4typedef __int64_t __darwin_blkcnt_t;typedef __int32_t __darwin_blksize_t;typedef __int32_t __darwin_dev_t;typedef unsigned int __darwin_fsblkcnt_t;typedef unsigned int __darwin_fsfilcnt_t;typedef __uint32_t __darwin_gid_t;typedef __uint32_t __darwin_id_t;typedef __uint64_t __darwin_ino64_t;typedef __darwin_ino64_t __darwin_ino_t;typedef __darwin_natural_t __darwin_mach_port_name_t;typedef __darwin_mach_port_name_t __darwin_mach_port_t;typedef __uint16_t __darwin_mode_t;typedef __int64_t __darwin_off_t;typedef __int32_t __darwin_pid_t;typedef __uint32_t __darwin_sigset_t;typedef __int32_t __darwin_suseconds_t;typedef __uint32_t __darwin_uid_t;typedef __uint32_t __darwin_useconds_t;typedef unsigned char __darwin_uuid_t[16];typedef char __darwin_uuid_string_t[37];# 1 &quot;/usr/include/sys/_pthread/_pthread_types.h&quot; 1 3 4# 57 &quot;/usr/include/sys/_pthread/_pthread_types.h&quot; 3 4struct __darwin_pthread_handler_rec { void (*__routine)(void *); void *__arg; struct __darwin_pthread_handler_rec *__next;};struct _opaque_pthread_attr_t { long __sig; char __opaque[56];};struct _opaque_pthread_cond_t { long __sig; char __opaque[40];};struct _opaque_pthread_condattr_t { long __sig; char __opaque[8];};struct _opaque_pthread_mutex_t { long __sig; char __opaque[56];};struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8];};struct _opaque_pthread_once_t { long __sig; char __opaque[8];};struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192];};struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16];};struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[8176];};typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t *__darwin_pthread_t;# 81 &quot;/usr/include/sys/_types.h&quot; 2 3 4# 28 &quot;/usr/include/_types.h&quot; 2 3 4# 39 &quot;/usr/include/_types.h&quot; 3 4typedef int __darwin_nl_item;typedef int __darwin_wctrans_t;typedef __uint32_t __darwin_wctype_t;# 68 &quot;/usr/include/stdio.h&quot; 2 3 4# 1 &quot;/usr/include/sys/_types/_va_list.h&quot; 1 3 4# 31 &quot;/usr/include/sys/_types/_va_list.h&quot; 3 4typedef __darwin_va_list va_list;# 72 &quot;/usr/include/stdio.h&quot; 2 3 4# 1 &quot;/usr/include/sys/_types/_size_t.h&quot; 1 3 4# 30 &quot;/usr/include/sys/_types/_size_t.h&quot; 3 4typedef __darwin_size_t size_t;# 73 &quot;/usr/include/stdio.h&quot; 2 3 4# 1 &quot;/usr/include/sys/_types/_null.h&quot; 1 3 4# 74 &quot;/usr/include/stdio.h&quot; 2 3 4# 1 &quot;/usr/include/sys/stdio.h&quot; 1 3 4# 39 &quot;/usr/include/sys/stdio.h&quot; 3 4int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));int renamex_np(const char *, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));int renameatx_np(int, const char *, int, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));# 76 &quot;/usr/include/stdio.h&quot; 2 3 4typedef __darwin_off_t fpos_t;# 88 &quot;/usr/include/stdio.h&quot; 3 4struct __sbuf { unsigned char *_base; int _size;};struct __sFILEX;# 122 &quot;/usr/include/stdio.h&quot; 3 4typedef struct __sFILE { unsigned char *_p; int _r; int _w; short _flags; short _file; struct __sbuf _bf; int _lbfsize; void *_cookie; int (* _Nullable _close)(void *); int (* _Nullable _read) (void *, char *, int); fpos_t (* _Nullable _seek) (void *, fpos_t, int); int (* _Nullable _write)(void *, const char *, int); struct __sbuf _ub; struct __sFILEX *_extra; int _ur; unsigned char _ubuf[3]; unsigned char _nbuf[1]; struct __sbuf _lb; int _blksize; fpos_t _offset;} FILE;extern FILE *__stdinp;extern FILE *__stdoutp;extern FILE *__stderrp;# 231 &quot;/usr/include/stdio.h&quot; 3 4void clearerr(FILE *);int fclose(FILE *);int feof(FILE *);int ferror(FILE *);int fflush(FILE *);int fgetc(FILE *);int fgetpos(FILE * restrict, fpos_t *);char *fgets(char * restrict, int, FILE *);FILE *fopen(const char * restrict __filename, const char * restrict __mode) __asm(&quot;_&quot; &quot;fopen&quot; );int fprintf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));int fputc(int, FILE *);int fputs(const char * restrict, FILE * restrict) __asm(&quot;_&quot; &quot;fputs&quot; );size_t fread(void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream);FILE *freopen(const char * restrict, const char * restrict,                 FILE * restrict) __asm(&quot;_&quot; &quot;freopen&quot; );int fscanf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));int fseek(FILE *, long, int);int fsetpos(FILE *, const fpos_t *);long ftell(FILE *);size_t fwrite(const void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream) __asm(&quot;_&quot; &quot;fwrite&quot; );int getc(FILE *);int getchar(void);char *gets(char *);void perror(const char *);int printf(const char * restrict, ...) __attribute__((__format__ (__printf__, 1, 2)));int putc(int, FILE *);int putchar(int);int puts(const char *);int remove(const char *);int rename (const char *__old, const char *__new);void rewind(FILE *);int scanf(const char * restrict, ...) __attribute__((__format__ (__scanf__, 1, 2)));void setbuf(FILE * restrict, char * restrict);int setvbuf(FILE * restrict, char * restrict, int, size_t);int sprintf(char * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((__availability__(swift, unavailable, message=&quot;Use snprintf instead.&quot;)));int sscanf(const char * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));FILE *tmpfile(void);__attribute__((__availability__(swift, unavailable, message=&quot;Use mkstemp(3) instead.&quot;)))__attribute__((deprecated(&quot;This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.&quot;)))char *tmpnam(char *);int ungetc(int, FILE *);int vfprintf(FILE * restrict, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0)));int vprintf(const char * restrict, va_list) __attribute__((__format__ (__printf__, 1, 0)));int vsprintf(char * restrict, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((__availability__(swift, unavailable, message=&quot;Use vsnprintf instead.&quot;)));# 297 &quot;/usr/include/stdio.h&quot; 3 4char *ctermid(char *);FILE *fdopen(int, const char *) __asm(&quot;_&quot; &quot;fdopen&quot; );int fileno(FILE *);# 321 &quot;/usr/include/stdio.h&quot; 3 4int pclose(FILE *) __attribute__((__availability__(swift, unavailable, message=&quot;Use posix_spawn APIs or NSTask instead.&quot;)));FILE *popen(const char *, const char *) __asm(&quot;_&quot; &quot;popen&quot; ) __attribute__((__availability__(swift, unavailable, message=&quot;Use posix_spawn APIs or NSTask instead.&quot;)));# 342 &quot;/usr/include/stdio.h&quot; 3 4int __srget(FILE *);int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));int __swbuf(int, FILE *);# 353 &quot;/usr/include/stdio.h&quot; 3 4inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) { if (--_p-&gt;_w &gt;= 0 || (_p-&gt;_w &gt;= _p-&gt;_lbfsize &amp;&amp; (char)_c != &#39;\n&#39;))  return (*_p-&gt;_p++ = _c); else  return (__swbuf(_c, _p));}# 379 &quot;/usr/include/stdio.h&quot; 3 4void flockfile(FILE *);int ftrylockfile(FILE *);void funlockfile(FILE *);int getc_unlocked(FILE *);int getchar_unlocked(void);int putc_unlocked(int, FILE *);int putchar_unlocked(int);int getw(FILE *);int putw(int, FILE *);__attribute__((__availability__(swift, unavailable, message=&quot;Use mkstemp(3) instead.&quot;)))__attribute__((deprecated(&quot;This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.&quot;)))char *tempnam(const char *__dir, const char *__prefix) __asm(&quot;_&quot; &quot;tempnam&quot; );# 417 &quot;/usr/include/stdio.h&quot; 3 4# 1 &quot;/usr/include/sys/_types/_off_t.h&quot; 1 3 4# 30 &quot;/usr/include/sys/_types/_off_t.h&quot; 3 4typedef __darwin_off_t off_t;# 418 &quot;/usr/include/stdio.h&quot; 2 3 4int fseeko(FILE * __stream, off_t __offset, int __whence);off_t ftello(FILE * __stream);int snprintf(char * restrict __str, size_t __size, const char * restrict __format, ...) __attribute__((__format__ (__printf__, 3, 4)));int vfscanf(FILE * restrict __stream, const char * restrict __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));int vscanf(const char * restrict __format, va_list) __attribute__((__format__ (__scanf__, 1, 0)));int vsnprintf(char * restrict __str, size_t __size, const char * restrict __format, va_list) __attribute__((__format__ (__printf__, 3, 0)));int vsscanf(const char * restrict __str, const char * restrict __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));# 442 &quot;/usr/include/stdio.h&quot; 3 4# 1 &quot;/usr/include/sys/_types/_ssize_t.h&quot; 1 3 4# 30 &quot;/usr/include/sys/_types/_ssize_t.h&quot; 3 4typedef __darwin_ssize_t ssize_t;# 443 &quot;/usr/include/stdio.h&quot; 2 3 4int dprintf(int, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));int vdprintf(int, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));ssize_t getdelim(char ** restrict __linep, size_t * restrict __linecapp, int __delimiter, FILE * restrict __stream) __attribute__((availability(macosx,introduced=10.7)));ssize_t getline(char ** restrict __linep, size_t * restrict __linecapp, FILE * restrict __stream) __attribute__((availability(macosx,introduced=10.7)));# 458 &quot;/usr/include/stdio.h&quot; 3 4extern const int sys_nerr;extern const char *const sys_errlist[];int asprintf(char ** restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));char *ctermid_r(char *);char *fgetln(FILE *, size_t *);const char *fmtcheck(const char *, const char *);int fpurge(FILE *);void setbuffer(FILE *, char *, int);int setlinebuf(FILE *);int vasprintf(char ** restrict, const char * restrict, va_list) __attribute__((__format__ (__printf__, 2, 0)));FILE *zopen(const char *, const char *, int);FILE *funopen(const void *,                 int (* _Nullable)(void *, char *, int),                 int (* _Nullable)(void *, const char *, int),                 fpos_t (* _Nullable)(void *, fpos_t, int),                 int (* _Nullable)(void *));# 498 &quot;/usr/include/stdio.h&quot; 3 4# 1 &quot;/usr/include/secure/_stdio.h&quot; 1 3 4# 31 &quot;/usr/include/secure/_stdio.h&quot; 3 4# 1 &quot;/usr/include/secure/_common.h&quot; 1 3 4# 32 &quot;/usr/include/secure/_stdio.h&quot; 2 3 4# 42 &quot;/usr/include/secure/_stdio.h&quot; 3 4extern int __sprintf_chk (char * restrict, int, size_t,     const char * restrict, ...);# 52 &quot;/usr/include/secure/_stdio.h&quot; 3 4extern int __snprintf_chk (char * restrict, size_t, int, size_t,      const char * restrict, ...);extern int __vsprintf_chk (char * restrict, int, size_t,      const char * restrict, va_list);extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,       const char * restrict, va_list);# 499 &quot;/usr/include/stdio.h&quot; 2 3 4# 2 &quot;hello.c&quot; 2int main(){ printf(&quot;Hello World&quot;); return 0;}</code></pre><h3 id="编译之后的内容"><a href="#编译之后的内容" class="headerlink" title="编译之后的内容"></a>编译之后的内容</h3><pre><code>    .section    __TEXT,__text,regular,pure_instructions    .macosx_version_min 10, 12    .globl    _main    .p2align    4, 0x90_main:                                  ## @main    .cfi_startproc## BB#0:    pushq    %rbpLcfi0:    .cfi_def_cfa_offset 16Lcfi1:    .cfi_offset %rbp, -16    movq    %rsp, %rbpLcfi2:    .cfi_def_cfa_register %rbp    subq    $16, %rsp    leaq    L_.str(%rip), %rdi    movl    $0, -4(%rbp)    movb    $0, %al    callq    _printf    xorl    %ecx, %ecx    movl    %eax, -8(%rbp)          ## 4-byte Spill    movl    %ecx, %eax    addq    $16, %rsp    popq    %rbp    retq    .cfi_endproc    .section    __TEXT,__cstring,cstring_literalsL_.str:                                 ## @.str    .asciz    &quot;Hello World&quot;.subsections_via_symbols</code></pre><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://man.linuxde.net/gcc" target="_blank" rel="noopener">gcc命令</a><br><a href="http://www.shanghai.ws/gnu/gcc_2.htm" target="_blank" rel="noopener">gcc 手册</a><br><a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA" target="_blank" rel="noopener">有限状态机</a><br><a href="https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90" target="_blank" rel="noopener">词法分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》读书笔记——操作系统温故知新</title>
      <link href="/2018/03/28/2018/3/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/"/>
      <url>/2018/03/28/2018/3/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>很早就听过这本书的介绍，每次想静下心来研读的时候总会被一些琐事打断。这段时间比较空闲，正好把这把咀嚼一下。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/664334-0b9c629c58d86ee4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这本书详细描述了Windows和Linux操作系统各自的可执行文件、目标文件格式。</p><ul><li>C/C++代码如何被编译成目标文件及程序在目标文件中文件存储。</li><li>目标文件如何被链接器链接到一起，并且形成可执行文件的。</li><li>目标文件在链接时符号处理、重定位及地址分配如何进行</li><li>可执行文件如何被装载并且执行</li><li>…..</li><li>什么是堆，什么是栈</li><li>……</li></ul><p>下面开始探索之旅吧！</p><h1 id="操作系统基础回顾"><a href="#操作系统基础回顾" class="headerlink" title="操作系统基础回顾"></a>操作系统基础回顾</h1><blockquote><p>温故而知新，可以为师</p></blockquote><p>下图为全文的导图</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-cc3dd2317edb8cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>计算机三个最为重要的部件：中央处理器CPU、内存、I/O控制芯片。</p><p>早起计算机因为核心频率不高所以设备都是连在同一条总线上，并且每个设备都还有一个响应的I/O控制器。<br><img src="https://upload-images.jianshu.io/upload_images/664334-40274c429f380982.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>后来核心频率提升，内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线，CPU采用倍频的方式与系统总线通信。再到后来出现了北桥芯片（协调高速芯片），南桥芯片（协调低速设备）</p><p>北桥芯片：协调CPU、内存、高速的图形设备，以便高速的交换数据<br>南桥芯片：协调磁盘、USB、键盘、鼠标等慢速设备</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-509f726685647904.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>上图可见，<strong>位于中间的是连接所有高速芯片的北桥（PCI），他的左边是CPU，右边是内存。</strong></p><blockquote><p>系统软件可以分为两块，一块是平台性的，比如操作系统内核，驱动程序，运行库和数以千计的系统工具；另一块是用于程序开发的，比如编译器、汇编器、链接器、开发库和开发工具。这里主要介绍的是链接器及库相关的内容。</p></blockquote><p><strong>无论是在计算机软件体系还是硬件体系有一句至理名言：计算机科学领域的任何问题都可以通过一个间接的中间层来解决。基本上这菊花概括了所有的设计要点。（想想我们平时所用的什么架构、模式都是这个道理）</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-d41dcf292af89d7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以把这种方式叫做层次体系，相邻的层次通过定义接口实现通讯，一般是下面那层是接口的提供者，上层使用接口<strong>（对应到软件开发中也就是面向接口编程，这套在Java中的Spring框架体现得淋漓尽致）</strong>。接口都是被精心设计过的，尽量保证稳定不变，这样对上层屏蔽了具体实现，任何一层次能都可以被修改或者被替换。</p><p>整体体系结构依赖关系：上次应用层程序——》操作系统应用程序编程接口——》运行库——》系统调用接口（以软件终端的方式）——》硬件接口</p><ul><li>运行库API：Linux下的GLibc库提供的POSIX的API，Window运行库提供Windows API，比如Win32</li><li>系统调用接口：系统调用接口在实现中以一般软件中断的方式提供，Linux中以0x80号中断作为系统调用接口，Winodows以0x2E作为系统调用接口</li></ul><p>硬件的接口定义决定操作系统内核，确定驱动程序如何操作硬件，如何与硬件通信，这种接口叫做<strong>硬件规格</strong>，硬件厂商负责提供硬件规格，操作系统及驱动程序的开发者通过阅读硬件规格，文档来编写。</p><blockquote><p>操作系统主要是提供抽象的接口以及管理硬件资源（大学的时候老师讲过）。</p></blockquote><p>CPU进化过程：CPU只能运行一个程序——》多道程序（监控CPU是否空闲）——》分时系统（每个程序都有机会运行一小段时间，任何一个死循环都可能导致死机）——》多任务系统（操作系统管理硬件资源，运行在硬件保护的级别。）</p><p>多任务系统中所有应用程序<strong>都以进程的方式运作</strong>，但是比操作系统的权限更低，每个进程有自己独立的地址空间，进程之前的地址空间相互隔离。CPU由操作系统统一分配，根据进程优先级调度，如果进程占用CPU太久的时间则会被暂停，进而分配给其他等待运行的进程。<strong>分配给每个进程的时间都很短，CPU在多个进程间快速切换，造成了多个进程同时运行的假象。</strong></p><h2 id="内存、分段、分页（这个很重要！）"><a href="#内存、分段、分页（这个很重要！）" class="headerlink" title="内存、分段、分页（这个很重要！）"></a>内存、分段、分页（这个很重要！）</h2><p>早期计算机中，程序是直接运行在物理内存的。比如计算机128M，程序A10M，程序B100M，程序C20M。那么最直接的就是将内存的前10M给A，10M-110M给B。但是这种方式有很多问题：</p><ul><li>地址空间不隔离（非常危险）：直接访问物理地址，恶意程序很容易改写其他程序的内存数据；除此之外如果程序有bug，同样会出现不小心改了其他程序的数据现象。这样就非常不安全，稳定</li><li>内存使用率低：比如上面例子想要运行C，这个时候内存空间已经不足了，这个时候需要把其中部分数据写到磁盘上，等到要用的时候在读回来。由于程序空间是连续的，将A写到磁盘还是不够用还需要将B程序到磁盘。<strong>中间有大量数据的换入换出</strong></li><li>程序运行地址不确定：程序每次载入运行的时候，需要从内测中分配一块足够大的空间，但是这个无内置是不确定会给编写程序带来麻烦。<strong>因为编写程序的时候，访问数据、指令的目标地址很多是固定的，需要重定位。</strong></li></ul><p>以上几个问题通过增加了一个中间层解决，也就是间接访问地址。<strong>将程序给出的地址看做是虚拟地址，然后通过映射关系，将虚拟地址转换为物理地址。只要能够管理好映射过程就能保证程序之间的内存区域不会重叠，达到地址空间隔离的效果。</strong>——虚拟内存</p><p>分段用来解决前面提到的地址空间不隔离和程序运行地址不确定。基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间，比如A程序10M，0X00000000到0X00A00000的10M虚拟空间，然后物理地址分配同样大小的区域，比如0x00100000到0x00B00000。然后将这两块相同大小的地址做空间一一映射，<strong>操作系统提供这个映射函数，实际由硬件转换，后面会提到具体是由MMU（内存管理单元）实现。</strong></p><p>比如A中访问0x00001000，CPU会将这个二地址转换为实际物理地址的0X00101000.<br><img src="https://upload-images.jianshu.io/upload_images/664334-2df0111da7d963d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>异常情况处理：虽然分段做到了地址隔离，A和B没有任何重叠，但是如果A访问虚拟地址空间超过了0x00A00000范围，那么硬件就会判断这是一个非法访问，拒绝这地址请求，<strong>并将这个请求报告给操作系统或监控程序，让它们进行下一步处理，一般就是产生异常</strong>。</p><p>分段也做到了程序不需要重定位，对程序而言不需要关系物理地址变化，只需要安装从地址0X00000000到0X00A00000l来编写程序。<strong>但是还是没有解决内存使用效率的问题。如果内存不足还是会造成很大的换入换出（以程序为单位，粒度还是太大）</strong></p><blockquote><p>根据<strong>程序局部性原理，当程序运行时，某个时间段内，它只会频繁的使用到一小部分数据</strong>，也就是说很多数据其实并不会被使用到，于是<strong>粒度更小的内存分隔和映射方法孕育而生</strong>，那就是分页。</p></blockquote><p>分页是把地址空间人为的分成固定大小的页，页大小范围由硬件决定，其次由操作系统最终确定页大小。</p><p>举个例子：<br><img src="https://upload-images.jianshu.io/upload_images/664334-2cde40b9a210b0b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>把进程的虚拟空间地址以页分隔，数据和代码也装载到内存，不常用的放到磁盘保存，需要的时候在从磁盘中读取处理。默认情况下虚拟也大小为4k。</p><ul><li>有两个进程Process1、Process2</li><li>Process1中虚拟页VP0、VP1、VP7映射到物理页PP0、PP2、PP3</li><li>Process2中虚拟页VP0、VP2、VP3、VP7映射到物理页PP5、PP0、PP1、PP3</li><li>虚拟VP2、VP3页面保存在磁盘页中的DP0、DP1，并不在内存中，当进程需要这两个也的时候，硬件会捕获这个信息，就是所谓的页错误，然后操作系统接管进程，负责将VP2、VP3从磁盘中载入到内存。</li><li><strong>可以看到到物理页中的PP0、PP3在进程Process1、Process2都有虚拟页映射到其中。这样就实现了内存共享</strong></li></ul><blockquote><p>虚拟内存实现需要依赖硬件支持，不同CPU处理方式不同，但是所有的硬件都采用MMU（内存管理单元）部件来进行页映射管理。MMU将CPU发出的虚拟地址转换为物理地址。<br><img src="https://upload-images.jianshu.io/upload_images/664334-a4ec3da8af7a4579.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程被称为轻量级进程，程序执行流的最小单元。<strong>线程由线程ID，当前指令指针，寄存器和堆栈组成</strong>。进程由多个线程组成，各个线程之间共享内存空间（代码段、数据段、堆）及进程级别的资源（打开文件和信号）。</p><p>进程、线程关系图：<br><img src="https://upload-images.jianshu.io/upload_images/664334-4cf1f46ca1eb5be1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>线程访问非常自由，可以访问进程内存中的所有数据，甚至包含其他线程转给你的堆栈（如果知道其他线程的堆栈地址，但是很少见），线程也拥有自己的私有存储空间。</p><ul><li>栈：虽然不是被其他线程完全无法访问，但是一般可以认为是私有数据</li><li>线程局部存储（TLS）：操作系统为线程单独提供的私有空间，但是很有限</li><li>寄存器：<strong>包括PC，寄存器是执行流的基本数据，为线程私有。</strong></li></ul><p>可以总结如下表<br><img src="https://upload-images.jianshu.io/upload_images/664334-9a6b203d075038ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>线程总是<code>并发</code>的执行，线程数小于等于处理器数量，线程的并发才是真真的并发（同一时刻，多个进行），不同线程运行在不同的处理器上；当大于处理器数量，此时会出现一个处理器运行多个线程的情况。</p><blockquote><p>单处理器情况下，多线程并发是一种模拟出来的状态，操作系统让多线程轮流执行，每次仅仅执行很小一段时间，这称作<strong>线程调度</strong>。</p></blockquote><p>线程调度至少有三个状态：</p><ul><li>运行：线程正在执行。</li><li>就绪：<strong>线程可以立刻运行，但CPU被其他线程占用</strong>。</li><li>等待：<strong>线程在等待某一个事件（比如：I/O或者同步）发生，无法执行</strong>。</li></ul><p>运行状态下的线程执行时间叫做时间片，</p><ol><li>时间片用尽了就进入就绪状态；——用尽</li><li>如果时间片用尽之前线程就开始等待某事件，则会就进入等待状态；——事件</li><li>线程离开运行态，操作系统就会调度其他就绪的线程执行；</li><li>在等待状态的线程等待的事件发生之后，线程就进入就绪状态；</li></ol><p>状态切换如下图：<br><img src="https://upload-images.jianshu.io/upload_images/664334-4b8f53dfa58b153b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>主流的调度策略虽然不同但是都有<strong>优先级调度及轮转法。</strong></p><ul><li>轮转法：让各个线程轮流执行一小段时间的方法，线程之间交错执行</li><li>优先级调度：确定线程按照什么顺序轮流执行难，线程都有自己的优先级，具有高优先级的会更早的执行，低优先级的需要等待没有高优先级线程存在的时候才执行。<strong>比如Linux中就是通过pthread来实现，iOS中也是</strong></li></ul><p>线程可以只定义优先级，系统也会根据线程执行状态改变线程的优先级。<strong>频繁进入等待状态的线程（处理I/O）比频繁进行大量计算（每次把时间片用尽的线程）有更多的机会执行，因为频繁等待的线程只占用很少的时间片，CPU喜欢先执行简单的。</strong></p><p>如果一个线程一直都得不到执行，这就是<strong>饿死现象</strong>。优先级较低，总有较高优先级在占用CPU，为了避免这种现象，调度系统会逐步提升等待时间过长却得不到机会执行的线程优先级。</p><p>优先级改变触发条件：</p><ul><li>用户指定优先级</li><li>根据线程进入等待状态的频率提升或降低优先级</li><li>长时间得不到执行而被提升优先级</li></ul><p>抢占：线程在用尽时间片之后被强制剥夺执行的权利进入就绪状态，这个过程叫做抢占，这样的线程就是抢占线程。目前基本所有的线程都是抢占式的。<br>不可抢占线程：也就是线程不可被抢占，只有线程主动发出放弃执行的命令，主动进入就绪态，而不靠时间片才会空出当前占用的资源。</p><p>不可抢占线程触动放弃情况：</p><ul><li>线程视图等待某事件</li><li>线程主动放弃时间片</li></ul><blockquote><p>虽然不可抢占线程可以避免一些因为抢占线程里调度时机不确定而产生的线程安全问题，但是现在非抢占式线程很少。</p></blockquote><h3 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h3><p>Linux<strong>内核中并不存在真正的线程概念</strong>，Linux将所有的执行实体（线程还是进程都一样）都称为任务，<strong>每一个任务都类似于一个单线程的进程，具有内存空间，执行实体，文件资源等</strong>。</p><blockquote><p>进程：不同任务之间可以选择共享内存空间，共享同一个内存空间的多任务构成一个进程，这些任务也就是这个进程里面的线程。</p></blockquote><p>Linux创建一个新的任务的方式:</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-e03304008d60180e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>fork函数产生一个和当前进程完全一样的新进程，fork产生的新任务速度非常快，<strong>因为不会复制原任务的内存空间，而是共享一个写时复制的内存空间</strong>。</p><p>写时复制就是指两个任务可以同时自由得读取内存，但任意一个任务要对内存修改，内存就会赋值一份给修改方使用。<strong>fork只能产生本任务的镜像，所以需要用exec才能启动新的任务。</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/664334-0b9f2e6c533ce559.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="线程安全（开发中经常遇到的）"><a href="#线程安全（开发中经常遇到的）" class="headerlink" title="线程安全（开发中经常遇到的）"></a>线程安全（开发中经常遇到的）</h3><p>多线程程序中，可访问的<strong>全局变量及堆数据随时都可能被其他线程改变</strong>，由此产生了的线程安全。</p><blockquote><p>线程安全的根本原因是同时写一个共享数据，每个线程都有自己的寄存器。</p></blockquote><p>计算机中单条指令在执行的时候不会被打断，所以在执行单条指令的时候不会存在线程安全问题，称为具有原子性；<strong>常见的自增++操作，因为自增++操作会被汇编为多条指令，所以在执行自增的时候可能被打断，去执行其他代码，不具有原子性，就有可能造成线程安全的问题</strong></p><p>一个例子：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-7a6dfd0508f749a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>其中的i为共享变量。</p><p>在计算机中会按照下面的步骤</p><ol><li><strong>读取i到某个寄存器X（每个线程有自己的寄存器）</strong></li><li>X++</li><li>将X的内容返回给i（也就是从寄存器取值然后送入内存）</li></ol><p>由于1、2线程是并发执行，隐藏坑出现如下的执行序列（<strong>每个线程有自己独立寄存器</strong>）<br><img src="https://upload-images.jianshu.io/upload_images/664334-c042562e5abeafc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如果按照正常逻辑来看i的值应该为1。但是通过上面的执行顺序最后的结果是0，所以出现了问题。实际上可能会是0或者1或者2。<strong>i的最终值取决于最终是从哪个线程中赋值的，也就是最终是由哪个线程的寄存器回写到内存中的。</strong></p><h3 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h3><p>所谓同步就是指在<strong>一个线程访问数据未结束的时候其他线程不能对同一数据访问</strong>。最常见的同步方式就是使用锁，分为加锁和解锁过程，在加锁之后其他线程需要等待解锁之后才能访问资源。</p><p>其次还有二元信号量，也即是占有和非占有两个状态，如果允许对个线程并发访问资源，多远信号量简称信号量。给定一个初始值为N的信号量则允许N个线程并发访问。具体来讲：</p><ul><li>信号量值减去1</li><li>如果信号量值小于0则进入等待状态，否则继续执行。访问完资源之后，线程释放信号量</li><li>将信号量加1</li><li>如果信号量的值大于1，则唤醒一个等待中的线程</li></ul><p>互斥量和二元信号量类似，资源同一时刻只能一个线程访问，<strong>和信号量不同的是，信号量在整个系统可以被任意线程获取并释放，而互斥量只能在哪个线程获取的，也就只能在获取的那个线程释放，跨线程释放是无效的</strong>。——任意线程</p><p>临界区是比互斥量更加严格的同步方式，临界区与信号量大而区别在于，互斥量和幸好量在系统的任何进程里都是可见的，也即是一个进程创建了互斥量或信号量，其他进程视图去获取该锁是合法的，<strong>临界区作用范围仅仅限于本进程，其他进程无法获取该锁</strong>，除此之外临界区和互斥量具有相同的性质。——任意进程</p><p>条件变量同样是一个同步的手段，作用类似于栅栏。线程对条件变量有两种操作方式，一种是条件变量可以被多个线程等待；另一种是线程可以唤醒条件变量，此时所有等待此条件变量的线程都会被唤醒。<strong>也就是条件变量可以让许多线程一起等待某个事件的发生。当事件发生时（条件变量被唤醒），线程继续执行</strong>——栅栏、多个线程</p><p>函数被重入表示这个函数没有执行完成，又进入 了该函数的执行。在多线程同时执行这个函数或者函数自身调用自己就会出现重入现象。如果函数被重入之后不会产生任何不良后果函数被称为具有可重入性。</p><p>比如：<br><img src="https://upload-images.jianshu.io/upload_images/664334-bbc4d36342b6fff6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>类似这样的函数，没有使用任何局部静态或全局的变量、没有依赖调用方提供的参数、不调用任何不可重入的函数，是线程安全的。</p><blockquote><p>在开发中，有时候即使使用了锁也不一定能保证线程安全。<strong>这是因为落后的编译技术无法满足增长的并发需求</strong>。这样会导致很多看似不合理的情况！</p></blockquote><p>比如：<br><img src="https://upload-images.jianshu.io/upload_images/664334-6264466f24c97ac5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>从代码上来讲有了lock和unlock的包含，x++的是原子性的，那么值似乎必然是2，但是如<strong>果编译器为了提高x的访问速度，把x放到某个寄存器里，</strong>我们知道不同线程的寄存器是独立的<strong>，因此Thread1先获得锁，则程序执行可能会出现如下情况<br><img src="https://upload-images.jianshu.io/upload_images/664334-339f37462f472b91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>可见这样并不能达到线程安全，</strong>原因就是在R1++之后没有立即回写到内存中，而是缓存在寄存器中，过了一段时间才回写到内存中。**</p><p>另一个例子</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-3d46a5e899de7538.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>逻辑上讲r1、r2至少有一个为1，不可能同时为0。但是这种同时为0的情况确实存在。<strong>因为CPU有动态调度的特性，在执行程序的时候为了提高效率有可能交换指令的顺序，同样编译器在优化的时候也可能为了效率而交换毫不相干的相邻指令如x=1、r1=y的执行顺序。</strong></p><p>上面的代码可能就变成了：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-4a0a2dbdedcf47a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这个时候就可能出现r1=r2=0，关键词volatile（C语言中）可以阻止这种过度优化。它可以实现两件事：</p><ol><li>阻止编译器为了提高速度将一个变量缓存在寄存器内不回写到内存中。</li><li>阻止编译器调整操作volatile变量的指令顺序。</li></ol><h3 id="CPU动态调度换序"><a href="#CPU动态调度换序" class="headerlink" title="CPU动态调度换序"></a>CPU动态调度换序</h3><p>CPU动态调用换序也算是过度优化的范畴。</p><p>源代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-a83ba77c5345e087.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>从逻辑上讲是没有问题的，函数返回时，Pinst总是指向一个有效的对象，同时也加了锁。<strong>其实有问题，主要是因为CPU乱序执行，C++中的new包含了两个步骤</strong></p><ul><li>分配内存</li><li>调用构造函数</li></ul><p>那么Pinst = new T其实包含了三个步骤</p><ol><li>分配内存</li><li>调用构造函数</li><li>将内存地址复制给PInst</li></ol><p>其中2和3顺序可以颠倒。产生的问题就是<strong>这个时候PInst虽然不是NULL，但还没构造完成，这个时候如果另一个线程滴啊用了GetInstance，那么就会直接返回PInst，但是这个地址是并没有构造完全的对象地址。如果后面使用了这个没有被构造完成的毒性地址，那么会发生异常现象</strong></p><p>所以需要阻止CPU换序，但是并不存在这样的方法。而是通过一条 指令解决，指令叫做barrier，barrier会阻止CPU将之前的指令交换到barrier之后，相当于一个栅栏。</p><p>改进后的代码如下<br><img src="https://upload-images.jianshu.io/upload_images/664334-21bf9328b5629dde.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>通过barrier保证了对象构造一定是在barrier之前完成的，那么PInst被复制的时候对象是完整的。</p><blockquote><p>这种情况什么时候会出现，目前我也没遇到过类似的场景。</p></blockquote><h3 id="多线程内部"><a href="#多线程内部" class="headerlink" title="多线程内部"></a>多线程内部</h3><p>这里涉及到内核线程与用户线，一些轻量级的线程，对用户而言如果有三个线程同时执行，对内核而言可能就只有一个线程。</p><p>一对一的线程模型最为简单，一个用户线程对应一个内核线程（但是内核态的线程不一定在用户太有对应的线程）。这样方式实现了真真的并发，一个线程阻塞不会应影响其他线程。但是也有缺点：</p><ul><li>许多操作系统限制了内核线程的数量，一次一对一的线程会让用户线程受到限制</li><li>许多操作系统内核线程调度时，上下文切换开销比较大，导致用户线程的执行效率下降</li></ul><p>除了一对一还有多对一的线程模型</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-ee3d7bfd4ed90fd1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>多对一将多个用户线程映射到一个内核线程上，线程之间由用户态的代码来惊醒，因此对弈一对一的线程模型而言，多对一在线程切换的时候就快很多。多对一的问题：</p><ul><li>最大问题就是一旦其中一个用户线程被阻塞了，那么所有的线程都无法继续执行，因此内核里面的线程也被阻塞；<strong>最大的好处就是线程的上下文切换和无限制的线程数量</strong></li></ul><p>多对多的线程模型结合了一对一，多对一的特点。将多个用户线程映射到不知一个内核线程上。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-041fd8a80818cf0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>一个线程阻塞并不会影响其他线程，而且也没有用户线程数量的限制。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>第一篇就到这里了，这一节主要是复习操作系统层面的知识。其中比较难（现在也没弄明白）就是CPU的动态调度。不知道有没有大咖懂的。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>下面这几篇都讲得比较深入，比如关于虚拟地址、进程、线程等。可以看一看！</p><p><a href="http://www.cnblogs.com/clover-toeic/p/3754433.html" target="_blank" rel="noopener">Linux虚拟地址空间布局</a><br><a href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726" target="_blank" rel="noopener">Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</a><br><a href="http://www.cnblogs.com/hicjiajia/archive/2011/01/20/1940154.html" target="_blank" rel="noopener">Linux下Fork与Exec使用</a><br><a href="https://www.cnblogs.com/xzzzh/p/6596982.html" target="_blank" rel="noopener">Linux虚拟地址空间布局以及进程栈和线程栈总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解iOS NSNotification</title>
      <link href="/2018/03/21/2018/3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%20NSNotification/"/>
      <url>/2018/03/21/2018/3/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%20NSNotification/</url>
      
        <content type="html"><![CDATA[<p>NSNotification在平时开发中使用非常频繁。网上关于NSNotification介绍大多是停留在用法的介绍，基本上没有深入介绍NSNotification原理的文章。故有此文！</p><a id="more"></a><h2 id="通知基础"><a href="#通知基础" class="headerlink" title="通知基础"></a>通知基础</h2><p>NSNotification 是iOS中一个调度消息通知的类,采用单例模式设计,在程序中实现传值、回调等地方应用很广。在iOS中，<strong>NSNotification是使用观察者模式来实现的用于跨层传递消息。往往也用NSNotification来实现解耦的目的。</strong></p><p>通知这种传值方式一般用于一对多的情况，iOS中常见的还有代理传值、block传值等。代理实现和block一般用于一对一的情况。至于具体区别接不赘述了。</p><p><strong>总结一下笔者在项目中使用通知的过程中，平时注意的几点：</strong></p><ul><li>通知的定义最好统一放在一个头文件中定义好，命名也尽量规范，比如用APP名_模块名_通知名这种方式，便于区分该通知具体实现什么目的。</li><li>全局最好维护一个单例来进行通知的发送。<strong>并且建立一张通知发送对象的表及接收通知对象表。</strong>因为在比较大的项目中，通知使用很频繁的情况下，很难找到对应的位置。往往给开发埋下了严重的坑。</li><li>接收通知的线程，和发送通知所处的线程是同一个线程。<strong>也就是说如果如果要在接收通知的时候更新UI，需要注意发送通知的线程是否为主线程。</strong></li></ul><h2 id="通知中的数据结构"><a href="#通知中的数据结构" class="headerlink" title="通知中的数据结构"></a>通知中的数据结构</h2><p>在介绍原理之前，先弄清通知中的常见数据结构有助于深刻的理解整个过程。这也是笔者分析源码常用方式。</p><h3 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h3><p>NSNotification包含了一些用于向其他对象发送通知的必要信息，发送通知通过NSNotificationCenter发送，其中NSNotification主要的字段有如下几个，也是发送通知必要的，<strong>注意NSNotification是一个不可变的对象</strong>。</p><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>通知的名称，用于通知的唯一标识</td></tr><tr><td>object</td><td>保存发送通知的对象</td></tr><tr><td>userinfo</td><td>保存给通知接受者传递的额外信息</td></tr></tbody></table><p>可以使用<code>notificationWithName:object:</code>或者<code>notificationWithName:object:userInfo:</code>创建通知对象，但是一般情况下不会这样直接创建。实际工作中更多是直接使用NSNotificationCenter调用<code>postNotificationName:object:</code>或者 <code>postNotificationName:object:userInfo:</code>方法发出通知，<strong>这两个方法会在内部直接创建这个对象</strong>。</p><p>NSNotification是一个类簇，不能通过init实例化,比如<code>NSNotification *notif = [[NSNotification alloc]init];</code>这样会引起下面的异常。<br><img src="media/15216032504004/15216087045336.jpg" alt></p><p><strong>但是可以通过装饰构造方法创建实例对象，</strong>装饰构造方法如下。：</p><pre class="line-numbers language-objecteive-c"><code class="language-objecteive-c">initWithName:(NSNotificationName)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) NS_DESIGNATED_INITIALIZER;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想要附加更多信息在NSNotification中，可以子类化NSNotification，额外新加的字段。<strong>需要注意的一点就是虽然可以自己去实现装饰构造方法，但是切记在自定义的装饰构造方法中不要调用[super init]。</strong></p><h3 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h3><p>NSNotificationCenter提供了一套机制来发送通知，本质上来讲NSNotificationCenter其实就是一个通知派发表。至于为什么这么讲，后面在介绍发送流程的时候会详细介绍。</p><p>NSNotificationCenter暴露给外部的字段不多就只有一个defaultCenter，而且这个字段还是只读的，其余的全是对通知操作的函数。</p><p><img src="media/15216032504004/15216099755130.jpg" alt></p><p>暴露出来的方法也就三种。前两种是对观察者的管理，第三种是用于发送通知。</p><table><thead><tr><th>作用</th><th>相关方法</th></tr></thead><tbody><tr><td>添加通知观察者</td><td>addObserverForName:object:queue:usingBlock:<br>addObserver:selector:name:object:<br></td></tr><tr><td>移除通知观察者</td><td>removeObserver:<br>emoveObserver:name:object:<br></td></tr><tr><td>发出通知</td><td>postNotification:<br>postNotificationName:object:<br>postNotificationName:object:userInfo:</td></tr></tbody></table><p>这里有下面几点需要说明：</p><ul><li>参数object表示的是观察者只会接受来至object对象发出的所注册的通知。而不会接受其他对象发送的所注册的通知。</li><li>方法<code>addObserverForName:object:queue:usingBlock:</code>。因为平时这个用得不是特别多。相比<code>addObserver:selector:name:object:</code>这种方式添加通知，多了个queue和block。<strong>这里的queue就是决定将block提交到那个队列里面执行。通知接受是和发送通知的线程是同一个。常见的会把这个queue设置为主队列，因为主队列的任务都会在主线程下完成，所以可以用这种方式来实现通知更新UI。而不使用注册SEL的方式。</strong></li></ul><blockquote><p>如果你还不清楚队列与线程的区别，建议自己亲手去实践一遍。可以简单说下主队列，主队列(串行队列)中的任务都是在主线程中完成，无论是同步还是异步执行。</p></blockquote><h3 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h3><p>NSNotificationQueue在NSNotificationCenter起到了一个缓冲的作用。尽管NSNotificationCenter已经分发通知，<strong>但放入队列的通知可能会延迟，直到当前的runloop结束或runloop处于空闲状态才发送。具体策略是由后面的参数决定。</strong></p><p>如果有多个相同的通知，可以在NSNotificationQueue进行合并，这样只会发送一个通知。NSNotificationQueue会通过先进先出的方式来维护NSNotification的实例，当通知实例位于队列首部，通知队列会将它发送到通知中心，然后依次的像注册的所有观察者派发通知。</p><p>每个线程有一个默认和 default notification center相关联的的通知队列。</p><p><img src="media/15216032504004/15216152003737.jpg" alt></p><p>如上图所示主要是提供了一些方法给外部调用。<br>通过调用<code>initWithNotificationCenter</code>和外部的NSNotificationCenter关联起来，最终也是通过NSNotificationCenter来管理通知的发送、注册。除此之外这里有两个枚举值需要特别注意一下。</p><ul><li>NSPostingStyle：用于配置通知什么时候发送<ul><li>NSPostASAP：在当前通知调用或者计时器结束发出通知</li><li>NSPostWhenIdle：当runloop处于空闲时发出通知</li><li>NSPostNow：在合并通知完成之后立即发出通知。</li></ul></li><li>NSNotificationCoalescing（注意这是一个NS_OPTIONS）：用于配置如何合并通知<ul><li>NSNotificationNoCoalescing：不合并通知</li><li>NSNotificationNoCoalescing：按照通知名字合并通知</li><li>NSNotificationCoalescingOnSender：按照传入的object合并通知</li></ul></li></ul><h2 id="通知的实现原理"><a href="#通知的实现原理" class="headerlink" title="通知的实现原理"></a>通知的实现原理</h2><p>上面介绍完了关键对象的数据结构，可以用下图归纳总结：<br><img src="media/15216032504004/15216163825794.jpg" alt></p><p>前面提到过NSNotification是一个类簇不能够实例化的，当我们调用<code>initWithName:object: userInfo:</code>方法的时候，系统内部会自己实现一个基于NSNotification的子类NSConcreteNotification。并且在这个子类中重写了NSNotification定义的相关字段及方法。</p><p>NSNotificationCenter是中心管理类，实现较复杂。总的来讲在NSNotificationCenter中定义了两个Table，同时为了封装观察者信息，也定义了一个Observation保存观察者信息。<strong>他们的结构体可以简化如下</strong>：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> NCTbl <span class="token punctuation">{</span>  Observation    <span class="token operator">*</span>wildcard<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 保存既没有没有传入通知名字也没有传入object的通知*/</span> MapTable        nameless<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*保存没有传入通知名字的通知 */</span> MapTable        named<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*保存传入了通知名字的通知 */</span><span class="token punctuation">}</span> NCTable<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span>    <span class="token keyword">struct</span>    Obs <span class="token punctuation">{</span>  id        observer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 保存接受消息的对象*/</span>  SEL        selector<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 保存注册通知时传入的SEL*/</span>  <span class="token keyword">struct</span> Obs    <span class="token operator">*</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 保存注册了同一个通知的下一个观察者*/</span>  <span class="token keyword">struct</span> NCTbl    <span class="token operator">*</span>link<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 保存改Observation的Table*/</span><span class="token punctuation">}</span> Observation<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在NSNotificationCenter内部一共保存了两张表。一张用于保存添加观察者的时候传入了NotifcationName的情况;一张用于保存添加观察者的时候没有传入了NotifcationName的情况，下面分两种情况分析。</p><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><h4 id="Named-Table"><a href="#Named-Table" class="headerlink" title="Named Table"></a>Named Table</h4><p>先看一下表中保存的内容及Key，Value类型<br><img src="media/15216032504004/15216241969049.jpg" alt></p><p>在Named Table中，NotifcationName作为表的key，<strong>因为我们在注册观察者的时候是可以传入一个参数object用于只监听指定该对象发出的通知，并且一个通知可以添加多个观察者，所以还需要一张表来保存object和Observer的对应关系。这张表的是key、Value分别是以object为Key，Observer为value。如何来实现保存多个观察者的情况呢？用链表这种数据结构最合适不过了。</strong></p><p>所以对于Named Table而已，最终的结构：</p><ul><li>首先外层有一个Table，以通知名称为Key。其Value同样是一个Table（简称内Table）.</li><li>为了实现可以传入一个参数object用于只监听指定该对象发出的通知，及一个通知可以添加多个观察者。则内Table的以传入的Object为Key，用链表来保存所有的观察者，并且以这个链表为Value。</li></ul><blockquote><p>在实际开发中我们经常传一个nil的object。这个时候系统会根据nil自动生产一个key（可以理解为一个nil_key）。相当于这个key对应的value(链表)保存的就是对于当前NotifcationName没有传入object的所有观察者。当NotifcationName被发送时，所以在链表中的观察者都会收到通知。</p></blockquote><h4 id="UnNamed-Table"><a href="#UnNamed-Table" class="headerlink" title="UnNamed Table"></a>UnNamed Table</h4><p>UnNamed Table结构比Named Table简单很多。因为没有NotifcationName作为Key。这里直接就以object为key。比Named Table少了一层Table嵌套。<br><img src="media/15216032504004/15216242250822.jpg" alt></p><p>如果在注册观察者的时候既没有NotifcationName，同时没有传入Object。<strong>经过代码实践，所以的系统通知都会发送到注册的对象这里。恰恰对应到上面提到的数据结构中的wildcard字段。</strong></p><h3 id="添加观察者的流程"><a href="#添加观察者的流程" class="headerlink" title="添加观察者的流程"></a>添加观察者的流程</h3><p>有了上面的基本的结构关系，再来看添加过程就会很简单。总的过程就是按照上面的数据结构添加数据，中间会判断Table及Observation结点是否存，不存在则创建新的，存在则直接使用。</p><p>首先在初始化NSNotificationCenter会创建一个对象，这个对象里面保存了NamedTable、UNnmedTable和一下其他信息。</p><p>所有的添加通知操作最后都会调用到<code>addObserver: selector: name: object:</code>。</p><ol><li>首先会根据传入的参数，实例化一个Observation。这个Observation保存了观察者对象、接收到通知观察者对所执行的方法，由于Observation是一个链表，还保存了下一个Observation的地址。</li><li>根据是否传入通知的Name选择在Named Table还是UNamed Table操作。</li><li>如果传入通知的Name，则会先去用Name去查找是否已经有对应的Value(<strong>注意这个时候返回的Value是一个Table</strong>)</li><li>如果没有对应的Value，则创建一个新的Table，然后将这个Table以Name为Key添加到Named Table。如果有Value，那么直接去取出这个Table。</li><li>得到了保存Observation的Table之后，就通过传入的object去拿对应的链表。<strong>如果object为空，会默认有一个key表示传入object为空的情况，取的时候也会直接用这个key去取。表示所有任何地方发送通知都会监听。</strong></li><li>如果在保存Observation的Table中根据object作为key没有找到对应的链表，则会创建一个节点，作为头结点插入进去；如果找到了则直接在链表末尾插入之前实例化好的Observation。</li></ol><p>在没有传入通知名字的情况和上面的过程类似，只不过是直接根据object去对应的链表而已。</p><blockquote><p>如果既没有传入NotifcationName也没有传入Object。则这个观察者会添加到wildcard（在介绍Table数据结构中提到够）链表中。</p></blockquote><h3 id="发送通知的流程"><a href="#发送通知的流程" class="headerlink" title="发送通知的流程"></a>发送通知的流程</h3><p>发送通知的一般是调用<code>postNotificationName:(NSNotificationName)aName object:(nullable id)anObject</code>来实现。</p><p>postNotificationName内部会实例化一个NSNotification来保存传入的各种参数。根据之前介绍的数据结构，包含name、object和一个userinfo。</p><blockquote><p><strong>发送通知的流程总体来讲就是根据NotifcationName查找到对应的Observer链表，然后遍历整个链表，给每个Observer结点中保持存的对象及SEL，来像对象发送信息（也即是调用对象的SEL方法）</strong></p></blockquote><ol><li>首先会定义一个数组ObserversArray来保存需要通知的Observer。<strong>之前在添加观察者的时候把既没有传入NotifcationName也没有传入object保存在了wildcard。因为这样的观察者会监听所有NotifcationName的通知，所以先把wildcard链表遍历一遍，将其中的Observer加到数组中ObserversArray</strong></li><li>找到以object为key的Observer链表。这个过程分为在Named Table中找，以及在UNamed Table中查找。然后将遍历找到的链表，同样加入到最开始创建的数组ObserversArray中。</li><li>至此所有关于NotifcationName的Observer<strong>（wildcard+UNamed Table+Named Table）</strong>已经加入到了数组ObserversArray。接下来就是遍历这个ObserversArray数组，一次取出区中的Observer结点。因为这个几点保存了观察者对象以及selector。所以最终调用形式如下：</li></ol><pre class="line-numbers language-c"><code class="language-c"> <span class="token punctuation">[</span>observerNode<span class="token operator">-></span>observer performSelector<span class="token punctuation">:</span> o<span class="token operator">-></span>selector withObject<span class="token punctuation">:</span> notification<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这个方式也就能说明，发送通知的线程和接收通知的线程是同一个线程。在工作中经常为了保持在主线程中更新UI，所以经常会做接受通知的方法中用<code>dispatch_async(dispatch_get_main_queue(), ^{});</code>处理一下，以保障无论从什么线程发出的通知，都能在主线程中更新UI。</p></blockquote><h3 id="移除通知的流程"><a href="#移除通知的流程" class="headerlink" title="移除通知的流程"></a>移除通知的流程</h3><p>根据前面分析的添加观察及发送通知的流程可以类比出移除通知的流程是如何的。<strong>掌握好核心就是操作两个Table及一个链表。</strong></p><p>结合上面讲的相关数据结构，移除的通知的流程留给读者自己去思考。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实分析NSNotification过程中间还有一些细节没有考虑到。比如在整个Table非常非常大的时候如何保证查找的效率，而且这种场景在实际开发中也经常遇到，尤其是一些大型项目，随随便便就是成百上千个通知。关于这个问题，后面分析吧。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop从源码到应用全面解析</title>
      <link href="/2018/03/18/2018/3/RunLoop%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%BA%94%E7%94%A8%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/03/18/2018/3/RunLoop%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%BA%94%E7%94%A8%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在开始之前有必要重点说明一下：现在开发中用到的所有的内容其实早在官方文档及相关API中已经介绍过，<strong>不要认为大神有多牛逼，他只是比你先阅读官方文档及使用维基百科，StackOverFlow而已。</strong>所以在你开始研究某个知识点之前看这些东西远比去读别人消化过得有用得多。一句话<strong>学会如何学习才是核心竞争力的关键。</strong></p><a id="more"></a><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#/apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">RunLoop官方介绍</a></p><h2 id="理解RunLoop"><a href="#理解RunLoop" class="headerlink" title="理解RunLoop"></a>理解RunLoop</h2><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a>这是国内对runloop写得非常非常好的文章。本文除了源码分析部分，也很多地方参考了其中的内容。非常感谢作者！</p><h3 id="从Event-Loop开始谈起"><a href="#从Event-Loop开始谈起" class="headerlink" title="从Event Loop开始谈起"></a>从Event Loop开始谈起</h3><p>RunLoop源码在CoreFoundation里面，下载地址如下：</p><ul><li><a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="noopener">CFRunLoopRef 源码</a></li><li><a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CF 源码</a></li><li><a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="noopener">Swift-Corelibs-foundation</a></li></ul><p>一般情况下，一个线程执行完之后就会停止。为了保证线程能随时处理事件并不退出，于是最简单的想到就是一个for循环。</p><pre class="line-numbers language-c"><code class="language-c">function <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        var message <span class="token operator">=</span> <span class="token function">get_next_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process_message</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>message <span class="token operator">!=</span> quit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这种模型叫做事件循环，<strong>实现这种模型的关键点就是如何在没有消息到来的情况下休眠以避免系统资源的占有，消息一到来立刻恢复。</strong></p><p>Runloop就是用来处理上面提到的事件及消息，执行上面的Event Loop模型。线程执行了这个函数之后就会一直处于这个函数内部，<strong>接受消息——》等待消息——》处理消息</strong>的循环中。直到循环结束（传入quit），然后函数返回。</p><h3 id="Runloop内部数据结构"><a href="#Runloop内部数据结构" class="headerlink" title="Runloop内部数据结构"></a>Runloop内部数据结构</h3><p>在进行RunLoop的执行过程分析之前，需要熟悉内部的各个数据结构。在 CoreFoundation 里面关于 RunLoop 有5个类，这几个类都是结构体指针，对应后面会讲到的结构体。</p><ul><li>CFRunLoopRef：对外部暴露的对象，外界通过CFRunLoopRef的接口来管理整个Runloop。</li><li>CFRunLoopModeRef：</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><p>他们之间的关系（一对多模式）可以如下图（来源于网上）所示，后面会更加详细的说明这种关系。</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt></p><p><strong>接下来通过源码来了解其中数据结构，也是对上面这种图的进一步解释。</strong></p><h4 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="CFRunLoop"></a>CFRunLoop</h4><p>对应CFRunLoopRef，其数据结构如下。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> __CFRunLoop <span class="token punctuation">{</span>    CFRuntimeBase _base<span class="token punctuation">;</span>    pthread_mutex_t _lock<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* locked for accessing mode list */</span>    __CFPort _wakeUpPort<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// used for CFRunLoopWakeUp </span>    Boolean _unused<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> _per_run_data <span class="token operator">*</span>_perRunData<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// reset for runs of the run loop</span>    pthread_t _pthread<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//runloop对应的线程</span>    uint32_t _winthread<span class="token punctuation">;</span>    CFMutableSetRef _commonModes<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储的是字符串，记录所有标记为common的mode</span>    CFMutableSetRef _commonModeItems<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储所有commonMode的item(source、timer、observer)</span>    CFRunLoopModeRef _currentMode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前运行的mode</span>    CFMutableSetRef _modes<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储的是CFRunLoopModeRef，</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>_blocks_head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>_blocks_tail<span class="token punctuation">;</span>    CFAbsoluteTime _runTime<span class="token punctuation">;</span>    CFAbsoluteTime _sleepTime<span class="token punctuation">;</span>    CFTypeRef _counterpart<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面可以看出一个RunLoop包含一个线程，<strong>也就是和线程是一一对应的</strong>；以及若干个Mode、若干个commonModeItem，还有一个当前运行的CurrentMode。<strong>如果在RunLoop中需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</strong></p><blockquote><p>重点说一下modes，在主线程的runloop中存在很多model，但是runloop在一个时间点只能在其中一种model下。</p></blockquote><p>下图是来至<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">维基百科中对runloop中的Model说明</a>：</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-d5544ebe487d47c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>但是我在模拟器中测试下只看到了UITrackingRunLoopMode、GSEventReceiveRunLoopMode、kCFRunLoopDefaultMode、kCFRunLoopCommonMode四种Model。</p></blockquote><h4 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h4><p>对应CFRunLoopModeRef，结构如下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> __CFRunLoopMode <span class="token punctuation">{</span>    CFRuntimeBase _base<span class="token punctuation">;</span>    pthread_mutex_t _lock<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* must have the run loop locked before locking this */</span>    CFStringRef _name<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//mode名称</span>    Boolean _stopped<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//mode是否被终止</span>    <span class="token keyword">char</span> _padding<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//几种事件，下面这四个字段，在苹果官方文档里面称为Item。runloop中有个commomitems字段，里面就是保持的下面这些内容。</span>    CFMutableSetRef _sources0<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//sources0</span>    CFMutableSetRef _sources1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//sources1</span>    CFMutableArrayRef _observers<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//观察者</span>    CFMutableArrayRef _timers<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定时器</span>    CFMutableDictionaryRef _portToV1SourceMap<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//字典  key是mach_port_t，value是CFRunLoopSourceRef</span>    __CFPortSet _portSet<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span>    CFIndex _observerMask<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span>    dispatch_source_t _timerSource<span class="token punctuation">;</span>    dispatch_queue_t _queue<span class="token punctuation">;</span>    Boolean _timerFired<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// set to true by the source when a timer has fired</span>    Boolean _dispatchTimerArmed<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MK_TIMER_TOO</span>    mach_port_t _timerPort<span class="token punctuation">;</span>    Boolean _mkTimerArmed<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span>    DWORD _msgQMask<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>_msgPump<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    uint64_t _timerSoftDeadline<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* TSR */</span>    uint64_t _timerHardDeadline<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* TSR */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上可以看出一个CFRunLoopMode对象有一个name，若干source0、source1、timer、observer和若干port，其中source，timer，observer 数据结构被统称为 mode item。<strong>上面提到的那几种model（UITrackingRunLoopMode、GSEventReceiveRunLoopMode、kCFRunLoopDefaultMode、kCFRunLoopCommonMode），其实就是这里的name。</strong></p><p>只能通过 mode的name字段（<strong>也就是字符串，前面提到的kCFRunLoopDefaultMode 和 UITrackingRunLoopMode</strong>） 操作内部的 Mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p><p>source、timer、observer可以在多个model中注册，<strong>但是只有runloop当前的currentMode下的source、timer、observer才可以运行。</strong></p><p>Model暴露给外面管理model Item的接口：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">CFRunLoopAddSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">CFRunLoopAddObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">CFRunLoopAddTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">CFRunLoopRemoveSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">CFRunLoopRemoveObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">CFRunLoopRemoveTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h4><p>对应CFRunLoopModeRef，其结构如下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> __CFRunLoopSource <span class="token punctuation">{</span>    CFRuntimeBase _base<span class="token punctuation">;</span>    uint32_t _bits<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于标记Signaled状态，source0只有在被标记为Signaled状态，才会被处理</span>    pthread_mutex_t _lock<span class="token punctuation">;</span>    CFIndex _order<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* immutable */</span>    CFMutableBagRef _runLoops<span class="token punctuation">;</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        CFRunLoopSourceContext version0<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* immutable, except invalidation */</span>        CFRunLoopSourceContext1 version1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* immutable, except invalidation */</span>    <span class="token punctuation">}</span> _context<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Source分为Source、Observer、Timer三种，他们统称为modeItem。</p><p>__CFRunLoopSource是事件产生的地方。Source有两个版本：Source0 和 Source1。</p><ul><li>source0 只包含了一个回调（函数指针），source0是需要手动触发的Source，<strong>它并不能主动触发事件，必须要先把它标记为signal状态。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，也就是通过<code>uint32_t _bits</code>来实现的</strong>，只有_bits标记Signaled状态才会被处理。然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li><li>source1 包含了一个 mach_port 和一个回调（函数指针），<strong>被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程</strong>。简单来说就是更加偏向于底层。</li></ul><p>以下是source0的结构体：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    CFIndex version<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>  info<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>retain<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CFStringRef</span> <span class="token punctuation">(</span><span class="token operator">*</span>copyDescription<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Boolean</span> <span class="token punctuation">(</span><span class="token operator">*</span>equal<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CFHashCode</span>  <span class="token punctuation">(</span><span class="token operator">*</span>hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>schedule<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> CFRunLoopRef rl<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当source加入到model触发的回调</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>cancel<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> CFRunLoopRef rl<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当source从runloop中移除时触发的回调</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>perform<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当source事件被触发时的回调，使用CFRunLoopSourceSignal方式触发。</span><span class="token punctuation">}</span> CFRunLoopSourceContext<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是source1的结构体：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    CFIndex version<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>  info<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>retain<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CFStringRef</span> <span class="token punctuation">(</span><span class="token operator">*</span>copyDescription<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Boolean</span> <span class="token punctuation">(</span><span class="token operator">*</span>equal<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CFHashCode</span>  <span class="token punctuation">(</span><span class="token operator">*</span>hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span>    <span class="token function">mach_port_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>getPort<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当source被添加到mode中的时候，从这个函数中获得具体mach_port_t。</span>    <span class="token keyword">void</span> <span class="token operator">*</span>  <span class="token punctuation">(</span><span class="token operator">*</span>perform<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> CFIndex size<span class="token punctuation">,</span> CFAllocatorRef allocator<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token keyword">void</span> <span class="token operator">*</span>  <span class="token punctuation">(</span><span class="token operator">*</span>getPort<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>perform<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token punctuation">}</span> CFRunLoopSourceContext1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>source1除了多个了getPort。其余的字段含义和source0相同。作用就是当source被添加到mode中的时候，从这个函数中获得具体mach_port_t。</p></blockquote><h4 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="CFRunLoopTimer"></a>CFRunLoopTimer</h4><p>对应RunLoopTimerRef，结构如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> __CFRunLoopTimer <span class="token punctuation">{</span>    CFRuntimeBase _base<span class="token punctuation">;</span>    uint16_t _bits<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//标记fire状态</span>    pthread_mutex_t _lock<span class="token punctuation">;</span>    CFRunLoopRef _runLoop<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加该timer的runloop</span>    CFMutableSetRef _rlModes<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//存放所有包含该timer的 mode的 modeName，意味着一个timer可能会在多个mode中存在</span>    CFAbsoluteTime _nextFireDate<span class="token punctuation">;</span>    CFTimeInterval _interval<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//理想时间间隔  </span><span class="token comment" spellcheck="true">/* immutable */</span>    CFTimeInterval _tolerance<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//时间偏差      </span><span class="token comment" spellcheck="true">/* mutable */</span>    uint64_t _fireTSR<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* TSR units */</span>    CFIndex _order<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* immutable */</span>    CFRunLoopTimerCallBack _callout<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* immutable */</span>    CFRunLoopTimerContext _context<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* immutable, except invalidation */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它和 NSTimer 是toll-free bridged 的（<a href="https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677" target="_blank" rel="noopener">资料可以看这里</a>），可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><blockquote><p>根据上面的分析t一个timer可能会在多个mode中存在。</p></blockquote><h4 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h4><p>对应CFRunLoopObserverRef，结构如下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> __CFRunLoopObserver <span class="token punctuation">{</span>    CFRuntimeBase _base<span class="token punctuation">;</span>    pthread_mutex_t _lock<span class="token punctuation">;</span>    CFRunLoopRef _runLoop<span class="token punctuation">;</span>    CFIndex _rlCount<span class="token punctuation">;</span>    CFOptionFlags _activities<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* immutable */</span>    CFIndex _order<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* immutable */</span>    CFRunLoopObserverCallBack _callout<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* immutable  设置回调函数*/</span>    CFRunLoopObserverContext _context<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* immutable, except invalidation */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，每个 Observer 都包含了一个回调（也就是上面的CFRunLoopObserverCallBack函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。状态定义在_CF_OPTIONS：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* Run Loop Observer Activities */</span><span class="token keyword">typedef</span> <span class="token function">CF_OPTIONS</span><span class="token punctuation">(</span>CFOptionFlags<span class="token punctuation">,</span> CFRunLoopActivity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    kCFRunLoopEntry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//即将进入run loop</span>    kCFRunLoopBeforeTimers <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//即将处理timer</span>    kCFRunLoopBeforeSources <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//即将处理source</span>    kCFRunLoopBeforeWaiting <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//即将进入休眠</span>    kCFRunLoopAfterWaiting <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//被唤醒但是还没开始处理事件</span>    kCFRunLoopExit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//run loop已经退出</span>    kCFRunLoopAllActivities <span class="token operator">=</span> <span class="token number">0x0FFFFFFFU</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是回调函数的原型:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>CFRunLoopObserverCallBack<span class="token punctuation">)</span><span class="token punctuation">(</span>CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFRunLoopActivity activity<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>根据上面的数据结构，总结出如下内容。</p><p>一个model中有多个item，这些item由source、observe、timer组成。对于我们来讲用的最多的应该是observe和timer，常常通过回调来得知当前runloop的状态，进行来优化应用程序（比如监控在waiting状态下，这个时候做一些优化的事情）。其次设置定时器执行定时任务也是很常见的。</p><p>一个runloop包含了多个model，但是runloop在一个时间点只会处于一种model（kCFRunLoopDefaultMode、UITrackingRunLoopMode、）状态下也即是currentModel，<strong>如果该当前应用状态在另一种mode下，则该model下的item（source、observe、timer）就不会工作</strong>。</p><p>runloop其中有一个commomModes的数组，里面保存的是被标记为common的model。这种标记为common的model有种特性，那就是当 RunLoop 的内容发生变化时，RunLoop 都会自动将 commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Model里。<strong>可以这样理解，runloop中的_commonModeItems由被标记为common的model下得各个item（source、observe、timer）组成。</strong></p><p>通过上面三点来理解为什么NSTimer在添加到runloop中的时候要用NSRunLoopCommonModes最为参数了。这里简单说一下。</p><blockquote><p><strong>首先Runloop初始化的时候的会把名字为kCFRunLoopDefaultMode、UITrackingRunLoopMode的model加入到common modesls数组里面，标记为common mode</strong>，上面提到过common mode的特性。NSTimer对应于上面提到的model中的item中的timer，并且NSTimer创建好之后默认是加入名为kCFRunLoopDefaultMode的model中，所以只有应用程序在kCFRunLoopDefaultMode下，Timer才会工作。</p></blockquote><blockquote><p>如果这个时候滑动了屏幕，那么应用的mode就从名字为kCFRunLoopDefaultMode的mode中退出，进入到名称为UITrackingRunLoopMode的model中。因为NSTimer没有添加到名字为UITrackingRunLoopMode的item中，所以只要等待不再滑动回到kCFRunLoopDefaultMode的时候才再次开始工作。</p></blockquote><blockquote><p>怎么解决呢？也就是把Timer加到了UITrackingRunLoopMode的Item。怎么样加到UITrackingRunLoopMode中呢？通过NSRunLoopCommonModes标记之后，Runloop会把NSTimer加入到Runloop中的commonModeItems中。上面讲过RunLoop 都会自动将 commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Model里。</p></blockquote><h3 id="RunLoop内部逻辑"><a href="#RunLoop内部逻辑" class="headerlink" title="RunLoop内部逻辑"></a>RunLoop内部逻辑</h3><p>上面的介绍Source/Timer/Observer 数据结构被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><p>根据上面讲的数据结构可以得出下面这张图：<br><img src="http://7xs6mx.com1.z0.glb.clouddn.com/runloop%20sturct.jpg" alt></p><p>NSRunloop暴露给外界的接口</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-67e2afcf399dc4b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="Runloop执行过程"><a href="#Runloop执行过程" class="headerlink" title="Runloop执行过程"></a>Runloop执行过程</h3><h4 id="RunLoopRun的启动"><a href="#RunLoopRun的启动" class="headerlink" title="RunLoopRun的启动"></a>RunLoopRun的启动</h4><p>首先总的来说逻辑如下图所示：<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt></p><blockquote><p>下面提供了两套代码，简化版与非简化版，如果觉得非简化版代码太长可以直接看简化版的代码，他们所表达的含义是一样的。</p></blockquote><h5 id="简化版代码（来源于网上）"><a href="#简化版代码（来源于网上）" class="headerlink" title="简化版代码（来源于网上）"></a>简化版代码（来源于网上）</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/// 用DefaultMode启动</span><span class="token keyword">void</span> <span class="token function">CFRunLoopRun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">CFRunLoopRunSpecific</span><span class="token punctuation">(</span><span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kCFRunLoopDefaultMode<span class="token punctuation">,</span> <span class="token number">1.0e10</span><span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><span class="token keyword">int</span> <span class="token function">CFRunLoopRunInMode</span><span class="token punctuation">(</span>CFStringRef modeName<span class="token punctuation">,</span> CFTimeInterval seconds<span class="token punctuation">,</span> Boolean stopAfterHandle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">CFRunLoopRunSpecific</span><span class="token punctuation">(</span><span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> seconds<span class="token punctuation">,</span> returnAfterSourceHandled<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/// RunLoop的实现</span><span class="token keyword">int</span> <span class="token function">CFRunLoopRunSpecific</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> seconds<span class="token punctuation">,</span> stopAfterHandle<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// 首先根据modeName找到对应mode</span>    CFRunLoopModeRef currentMode <span class="token operator">=</span> <span class="token function">__CFRunLoopFindMode</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 如果mode里没有source/timer/observer, 直接返回。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopModeIsEmpty</span><span class="token punctuation">(</span>currentMode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span>    <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 内部函数，进入loop</span>    <span class="token function">__CFRunLoopRun</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> seconds<span class="token punctuation">,</span> returnAfterSourceHandled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Boolean sourceHandledThisLoop <span class="token operator">=</span> NO<span class="token punctuation">;</span>        <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span>            <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopBeforeTimers<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span>            <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopBeforeSources<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 执行被加入的block</span>            <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 4. RunLoop 触发 Source0 (非port) 回调。</span>            sourceHandledThisLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopDoSources0</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> stopAfterHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 执行被加入的block</span>            <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>__Source0DidDispatchPortLastTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Boolean hasMsg <span class="token operator">=</span> <span class="token function">__CFRunLoopServiceMachPort</span><span class="token punctuation">(</span>dispatchPort<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>hasMsg<span class="token punctuation">)</span> <span class="token keyword">goto</span> handle_msg<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sourceHandledThisLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopBeforeWaiting<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span>            <span class="token comment" spellcheck="true">/// • 一个基于 port 的Source 的事件。</span>            <span class="token comment" spellcheck="true">/// • 一个 Timer 到时间了</span>            <span class="token comment" spellcheck="true">/// • RunLoop 自身的超时时间到了</span>            <span class="token comment" spellcheck="true">/// • 被其他什么调用者手动唤醒</span>            <span class="token function">__CFRunLoopServiceMachPort</span><span class="token punctuation">(</span>waitSet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">mach_msg</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> MACH_RCV_MSG<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// thread wait for receive msg</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span>            <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopAfterWaiting<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 收到消息，处理消息。</span>            handle_msg<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg_is_timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">__CFRunLoopDoTimers</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> <span class="token function">mach_absolute_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">/// 9.2 如果有dispatch到main_queue的block，执行block。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>msg_is_dispatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token comment" spellcheck="true">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                CFRunLoopSourceRef source1 <span class="token operator">=</span> <span class="token function">__CFRunLoopModeFindSourceForMachPort</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> livePort<span class="token punctuation">)</span><span class="token punctuation">;</span>                sourceHandledThisLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopDoSource1</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> source1<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sourceHandledThisLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">mach_msg</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span> MACH_SEND_MSG<span class="token punctuation">,</span> reply<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/// 执行加入到Loop的block</span>            <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sourceHandledThisLoop <span class="token operator">&amp;&amp;</span> stopAfterHandle<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/// 进入loop时参数说处理完事件就返回。</span>                retVal <span class="token operator">=</span> kCFRunLoopRunHandledSource<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/// 超出传入参数标记的超时时间了</span>                retVal <span class="token operator">=</span> kCFRunLoopRunTimedOut<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsStopped</span><span class="token punctuation">(</span>runloop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/// 被外部调用者强制停止了</span>                retVal <span class="token operator">=</span> kCFRunLoopRunStopped<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopModeIsEmpty</span><span class="token punctuation">(</span>runloop<span class="token punctuation">,</span> currentMode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/// source/timer/observer一个都没有了</span>                retVal <span class="token operator">=</span> kCFRunLoopRunFinished<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>retVal <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// 10. 通知 Observers: RunLoop 即将退出。</span>    <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopExit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的过程是对刚才那种图的具体说明。在整个循环中，通过observer向外界告知当前runloop的状态，事件触发由source(source0，source1）及timer发起，并且通过之前设置的函数进行回调处理，在处理各个回调的时候也触发了block的处理。</p><h5 id="非简化版代码（于CF-855-17）"><a href="#非简化版代码（于CF-855-17）" class="headerlink" title="非简化版代码（于CF-855.17）"></a>非简化版代码（于CF-855.17）</h5><p>下面的源码来至于CF-855.17中</p><p>非简化版代码非常长，要非常有耐心才能看下去。</p><h6 id="CFRunLoopRun（入口函数）"><a href="#CFRunLoopRun（入口函数）" class="headerlink" title="CFRunLoopRun（入口函数）"></a>CFRunLoopRun（入口函数）</h6><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//默认运行runloop的kCFRunLoopDefaultMode</span><span class="token keyword">void</span> <span class="token function">CFRunLoopRun</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* DOES CALLOUT */</span>    int32_t result<span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//默认在kCFRunLoopDefaultMode下运行runloop</span>        result <span class="token operator">=</span> <span class="token function">CFRunLoopRunSpecific</span><span class="token punctuation">(</span><span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kCFRunLoopDefaultMode<span class="token punctuation">,</span> <span class="token number">1.0e10</span><span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>kCFRunLoopRunStopped <span class="token operator">!=</span> result <span class="token operator">&amp;&amp;</span> kCFRunLoopRunFinished <span class="token operator">!=</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="CFRunLoopRunInMode"><a href="#CFRunLoopRunInMode" class="headerlink" title="CFRunLoopRunInMode"></a>CFRunLoopRunInMode</h6><pre class="line-numbers language-c"><code class="language-c">SInt32 <span class="token function">CFRunLoopRunInMode</span><span class="token punctuation">(</span>CFStringRef modeName<span class="token punctuation">,</span> CFTimeInterval seconds<span class="token punctuation">,</span> Boolean returnAfterSourceHandled<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* DOES CALLOUT */</span>    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">CFRunLoopRunSpecific</span><span class="token punctuation">(</span><span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> seconds<span class="token punctuation">,</span> returnAfterSourceHandled<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a>CFRunLoopRunSpecific</h6><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * 指定mode运行runloop * @param rl 当前运行的runloop * @param modeName 需要运行的mode的name * @param seconds  runloop的超时时间 * @param returnAfterSourceHandled 是否处理完事件就返回 */</span>SInt32 <span class="token function">CFRunLoopRunSpecific</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">,</span> CFTimeInterval seconds<span class="token punctuation">,</span> Boolean returnAfterSourceHandled<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* DOES CALLOUT */</span>    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsDeallocating</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> kCFRunLoopRunFinished<span class="token punctuation">;</span>    <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//根据modeName找到本次运行的mode</span>    CFRunLoopModeRef currentMode <span class="token operator">=</span> <span class="token function">__CFRunLoopFindMode</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果没找到 || mode中没有注册任何事件，则就此停止，不进入循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> currentMode <span class="token operator">||</span> <span class="token function">__CFRunLoopModeIsEmpty</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> rl<span class="token operator">-></span>_currentMode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Boolean did <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMode<span class="token punctuation">)</span> <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>currentMode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> did <span class="token operator">?</span> kCFRunLoopRunHandledSource <span class="token punctuation">:</span> kCFRunLoopRunFinished<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">volatile</span> _per_run_data <span class="token operator">*</span>previousPerRun <span class="token operator">=</span> <span class="token function">__CFRunLoopPushPerRunData</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取上一次运行的mode</span>    CFRunLoopModeRef previousMode <span class="token operator">=</span> rl<span class="token operator">-></span>_currentMode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果本次mode和上次的mode一致</span>    rl<span class="token operator">-></span>_currentMode <span class="token operator">=</span> currentMode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化一个result为kCFRunLoopRunFinished</span>    int32_t result <span class="token operator">=</span> kCFRunLoopRunFinished<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.通知observer即将进入runloop</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMode<span class="token operator">-></span>_observerMask <span class="token operator">&amp;</span> kCFRunLoopEntry <span class="token punctuation">)</span> <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token function">__CFRunLoopRun</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> seconds<span class="token punctuation">,</span> returnAfterSourceHandled<span class="token punctuation">,</span> previousMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//10.通知observer已退出runloop</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMode<span class="token operator">-></span>_observerMask <span class="token operator">&amp;</span> kCFRunLoopExit <span class="token punctuation">)</span> <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> currentMode<span class="token punctuation">,</span> kCFRunLoopExit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>currentMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__CFRunLoopPopPerRunData</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> previousPerRun<span class="token punctuation">)</span><span class="token punctuation">;</span>    rl<span class="token operator">-></span>_currentMode <span class="token operator">=</span> previousMode<span class="token punctuation">;</span>    <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果指定了一个不存在的mode来运行RunLoop，那么会失败，mode不会被创建，所以这里传入的mode必须是存在的。</li><li>如果指定了一个mode，但是这个mode中不包含任何modeItem，那么RunLoop也不会运行，所以必须要传入至少包含一个modeItem的mode。</li><li>在进入run loop之前通知observer，状态为kCFRunLoopEntry。</li><li>在退出run loop之后通知observer，状态为kCFRunLoopExit。</li></ul><h6 id="CFRunloopRun（核心！！）"><a href="#CFRunloopRun（核心！！）" class="headerlink" title="__CFRunloopRun（核心！！）"></a>__CFRunloopRun（核心！！）</h6><p>__CFRunloopRun才是最为重要的一步，runloop启动操作最终会执行这个方法。上面提到的简化版主要是对下面这个方法简化。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** *  运行run loop * *  @param rl              运行的RunLoop对象 *  @param rlm             运行的mode *  @param seconds         run loop超时时间 *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止 *  @param previousMode    上一次运行的mode * *  @return 返回4种状态 */</span><span class="token keyword">static</span> int32_t <span class="token function">__CFRunLoopRun</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopModeRef rlm<span class="token punctuation">,</span> CFTimeInterval seconds<span class="token punctuation">,</span> Boolean stopAfterHandle<span class="token punctuation">,</span> CFRunLoopModeRef previousMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获取系统启动后的CPU运行时间，用于控制超时时间</span>    uint64_t startTSR <span class="token operator">=</span> <span class="token function">mach_absolute_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果RunLoop或者mode是stop状态，则直接return，不进入循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsStopped</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">__CFRunLoopUnsetStopped</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> kCFRunLoopRunStopped<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_stopped<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rlm<span class="token operator">-></span>_stopped <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token keyword">return</span> kCFRunLoopRunStopped<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//mach端口，在内核中，消息在端口之间传递。 初始为0</span>    mach_port_name_t dispatchPort <span class="token operator">=</span> MACH_PORT_NULL<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断是否为主线程</span>    Boolean libdispatchQSafe <span class="token operator">=</span> <span class="token function">pthread_main_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY <span class="token operator">&amp;&amp;</span> <span class="token constant">NULL</span> <span class="token operator">==</span> previousMode<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span>HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token function">_CFGetTSD</span><span class="token punctuation">(</span>__CFTSDKeyIsInGCDMainQ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>libdispatchQSafe <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">CFRunLoopGetMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> rl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_commonModes<span class="token punctuation">,</span> rlm<span class="token operator">-></span>_name<span class="token punctuation">)</span><span class="token punctuation">)</span> dispatchPort <span class="token operator">=</span> <span class="token function">_dispatch_get_main_queue_port_4CF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span>    mach_port_name_t modeQueuePort <span class="token operator">=</span> MACH_PORT_NULL<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//mode赋值为dispatch端口_dispatch_runloop_root_queue_perform_4CF</span>        modeQueuePort <span class="token operator">=</span> <span class="token function">_dispatch_runloop_root_queue_get_port_4CF</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>modeQueuePort<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CRASH</span><span class="token punctuation">(</span><span class="token string">"Unable to get port for run loop mode queue (%d)"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token comment" spellcheck="true">//GCD管理的定时器，用于实现runloop超时机制</span>    dispatch_source_t timeout_timer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> __timeout_context <span class="token operator">*</span>timeout_context <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> __timeout_context <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>timeout_context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//立即超时</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>seconds <span class="token operator">&lt;=</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// instant timeout</span>        seconds <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        timeout_context<span class="token operator">-></span>termTSR <span class="token operator">=</span> <span class="token number">0ULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//seconds为超时时间，超时时执行__CFRunLoopTimeout函数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>seconds <span class="token operator">&lt;=</span> TIMER_INTERVAL_LIMIT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dispatch_queue_t queue <span class="token operator">=</span> <span class="token function">dispatch_get_global_queue</span><span class="token punctuation">(</span>DISPATCH_QUEUE_PRIORITY_HIGH<span class="token punctuation">,</span> DISPATCH_QUEUE_OVERCOMMIT<span class="token punctuation">)</span><span class="token punctuation">;</span>        timeout_timer <span class="token operator">=</span> <span class="token function">dispatch_source_create</span><span class="token punctuation">(</span>DISPATCH_SOURCE_TYPE_TIMER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch_retain</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        timeout_context<span class="token operator">-></span>ds <span class="token operator">=</span> timeout_timer<span class="token punctuation">;</span>        timeout_context<span class="token operator">-></span>rl <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">CFRetain</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        timeout_context<span class="token operator">-></span>termTSR <span class="token operator">=</span> startTSR <span class="token operator">+</span> <span class="token function">__CFTimeIntervalToTSR</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch_set_context</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">,</span> timeout_context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// source gets ownership of context</span>        <span class="token function">dispatch_source_set_event_handler_f</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">,</span> __CFRunLoopTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch_source_set_cancel_handler_f</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">,</span> __CFRunLoopTimeoutCancel<span class="token punctuation">)</span><span class="token punctuation">;</span>        uint64_t ns_at <span class="token operator">=</span> <span class="token punctuation">(</span>uint64_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__CFTSRToTimeInterval</span><span class="token punctuation">(</span>startTSR<span class="token punctuation">)</span> <span class="token operator">+</span> seconds<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000000ULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch_source_set_timer</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">,</span> <span class="token function">dispatch_time</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ns_at<span class="token punctuation">)</span><span class="token punctuation">,</span> DISPATCH_TIME_FOREVER<span class="token punctuation">,</span> <span class="token number">1000ULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch_resume</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//永不超时</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// infinite timeout</span>        seconds <span class="token operator">=</span> <span class="token number">9999999999.0</span><span class="token punctuation">;</span>        timeout_context<span class="token operator">-></span>termTSR <span class="token operator">=</span> UINT64_MAX<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//标志位默认为true</span>    Boolean didDispatchPortLastTime <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//记录最后runloop状态，用于return</span>    int32_t retVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化一个存放内核消息的缓冲池</span>        uint8_t msg_buffer<span class="token punctuation">[</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span>        mach_msg_header_t <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        mach_port_t livePort <span class="token operator">=</span> MACH_PORT_NULL<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span>        HANDLE livePort <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        Boolean windowsMessageReceived <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token comment" spellcheck="true">//取所有需要监听的port</span>        __CFPortSet waitSet <span class="token operator">=</span> rlm<span class="token operator">-></span>_portSet<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置RunLoop为可以被唤醒状态</span>        <span class="token function">__CFRunLoopUnsetIgnoreWakeUps</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.通知observer，即将触发timer回调，处理timer事件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_observerMask <span class="token operator">&amp;</span> kCFRunLoopBeforeTimers<span class="token punctuation">)</span> <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> kCFRunLoopBeforeTimers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3.通知observer，即将触发Source0回调</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_observerMask <span class="token operator">&amp;</span> kCFRunLoopBeforeSources<span class="token punctuation">)</span> <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> kCFRunLoopBeforeSources<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//执行加入当前runloop的block</span>        <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//4.处理source0事件</span>        <span class="token comment" spellcheck="true">//有事件处理返回true，没有事件返回false</span>        Boolean sourceHandledThisLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopDoSources0</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> stopAfterHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sourceHandledThisLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//执行加入当前runloop的block</span>            <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果没有Sources0事件处理 并且 没有超时，poll为false</span>        <span class="token comment" spellcheck="true">//如果有Sources0事件处理 或者 超时，poll都为true</span>        Boolean poll <span class="token operator">=</span> sourceHandledThisLoop <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token number">0ULL</span> <span class="token operator">==</span> timeout_context<span class="token operator">-></span>termTSR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//第一次do..whil循环不会走该分支，因为didDispatchPortLastTime初始化是true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>MACH_PORT_NULL <span class="token operator">!=</span> dispatchPort <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>didDispatchPortLastTime<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span>            <span class="token comment" spellcheck="true">//从缓冲区读取消息</span>            msg <span class="token operator">=</span> <span class="token punctuation">(</span>mach_msg_header_t <span class="token operator">*</span><span class="token punctuation">)</span>msg_buffer<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//5.接收dispatchPort端口的消息，（接收source1事件）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopServiceMachPort</span><span class="token punctuation">(</span>dispatchPort<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果接收到了消息的话，前往第9步开始处理msg</span>                <span class="token keyword">goto</span> handle_msg<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopWaitForMultipleObjects</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dispatchPort<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">goto</span> handle_msg<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token punctuation">}</span>        didDispatchPortLastTime <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//6.通知观察者RunLoop即将进入休眠</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>poll <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_observerMask <span class="token operator">&amp;</span> kCFRunLoopBeforeWaiting<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> kCFRunLoopBeforeWaiting<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置RunLoop为休眠状态</span>        <span class="token function">__CFRunLoopSetSleeping</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// do not do any user callouts after this point (after notifying of sleeping)</span>        <span class="token comment" spellcheck="true">// Must push the local-to-this-activation ports in on every loop</span>        <span class="token comment" spellcheck="true">// iteration, as this mode could be run re-entrantly and we don't</span>        <span class="token comment" spellcheck="true">// want these ports to get serviced.</span>        <span class="token function">__CFPortSetInsert</span><span class="token punctuation">(</span>dispatchPort<span class="token punctuation">,</span> waitSet<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span>        <span class="token comment" spellcheck="true">//这里有个内循环，用于接收等待端口的消息</span>        <span class="token comment" spellcheck="true">//进入此循环后，线程进入休眠，直到收到新消息才跳出该循环，继续执行run loop</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>kCFUseCollectableAllocator<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">objc_clear_stack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memset</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            msg <span class="token operator">=</span> <span class="token punctuation">(</span>mach_msg_header_t <span class="token operator">*</span><span class="token punctuation">)</span>msg_buffer<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//7.接收waitSet端口的消息</span>            <span class="token function">__CFRunLoopServiceMachPort</span><span class="token punctuation">(</span>waitSet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">,</span> poll <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> TIMEOUT_INFINITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//收到消息之后，livePort的值为msg->msgh_local_port，</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>modeQueuePort <span class="token operator">!=</span> MACH_PORT_NULL <span class="token operator">&amp;&amp;</span> livePort <span class="token operator">==</span> modeQueuePort<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">_dispatch_runloop_root_queue_perform_4CF</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_timerFired<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Leave livePort as the queue port, and service timers below</span>                    rlm<span class="token operator">-></span>_timerFired <span class="token operator">=</span> false<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">&amp;&amp;</span> msg <span class="token operator">!=</span> <span class="token punctuation">(</span>mach_msg_header_t <span class="token operator">*</span><span class="token punctuation">)</span>msg_buffer<span class="token punctuation">)</span> <span class="token function">free</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Go ahead and leave the inner loop.</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>kCFUseCollectableAllocator<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">objc_clear_stack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        msg <span class="token operator">=</span> <span class="token punctuation">(</span>mach_msg_header_t <span class="token operator">*</span><span class="token punctuation">)</span>msg_buffer<span class="token punctuation">;</span>        <span class="token function">__CFRunLoopServiceMachPort</span><span class="token punctuation">(</span>waitSet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg_buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">,</span> poll <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> TIMEOUT_INFINITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span>        <span class="token comment" spellcheck="true">// Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</span>        <span class="token function">__CFRunLoopWaitForMultipleObjects</span><span class="token punctuation">(</span>waitSet<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> poll <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> TIMEOUT_INFINITY<span class="token punctuation">,</span> rlm<span class="token operator">-></span>_msgQMask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">,</span> <span class="token operator">&amp;</span>windowsMessageReceived<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRunLoopModeLock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Must remove the local-to-this-activation ports in on every loop</span>        <span class="token comment" spellcheck="true">// iteration, as this mode could be run re-entrantly and we don't</span>        <span class="token comment" spellcheck="true">// want these ports to get serviced. Also, we don't want them left</span>        <span class="token comment" spellcheck="true">// in there if this function returns.</span>        <span class="token function">__CFPortSetRemove</span><span class="token punctuation">(</span>dispatchPort<span class="token punctuation">,</span> waitSet<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRunLoopSetIgnoreWakeUps</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// user callouts now OK again</span>        <span class="token comment" spellcheck="true">//取消runloop的休眠状态</span>        <span class="token function">__CFRunLoopUnsetSleeping</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//8.通知观察者runloop被唤醒</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>poll <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_observerMask <span class="token operator">&amp;</span> kCFRunLoopAfterWaiting<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">__CFRunLoopDoObservers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> kCFRunLoopAfterWaiting<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//9.处理收到的消息</span>    handle_msg<span class="token punctuation">:</span><span class="token punctuation">;</span>        <span class="token function">__CFRunLoopSetIgnoreWakeUps</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>windowsMessageReceived<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after</span>            <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_msgPump<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rlm<span class="token operator">-></span><span class="token function">_msgPump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                MSG msg<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PeekMessage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PM_REMOVE <span class="token operator">|</span> PM_NOYIELD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">TranslateMessage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">DispatchMessage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopModeLock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>            sourceHandledThisLoop <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</span>            <span class="token comment" spellcheck="true">// Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we're just checking to see if the things are signalled right now -- we will wait on them again later.</span>            <span class="token comment" spellcheck="true">// NOTE: Ignore the dispatch source (it's not in the wait set anymore) and also don't run the observers here since we are polling.</span>            <span class="token function">__CFRunLoopSetSleeping</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopWaitForMultipleObjects</span><span class="token punctuation">(</span>waitSet<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>livePort<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopModeLock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopUnsetSleeping</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// If we have a new live port then it will be handled below as normal</span>        <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>MACH_PORT_NULL <span class="token operator">==</span> livePort<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CFRUNLOOP_WAKEUP_FOR_NOTHING</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// handle nothing</span>            <span class="token comment" spellcheck="true">//通过CFRunloopWake唤醒</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>livePort <span class="token operator">==</span> rl<span class="token operator">-></span>_wakeUpPort<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//什么都不干，跳回2重新循环</span>            <span class="token comment" spellcheck="true">// do nothing on Mac OS</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span>            <span class="token comment" spellcheck="true">// Always reset the wake up port, or risk spinning forever</span>            <span class="token function">ResetEvent</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_wakeUpPort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span>        <span class="token comment" spellcheck="true">//如果是定时器事件</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>modeQueuePort <span class="token operator">!=</span> MACH_PORT_NULL <span class="token operator">&amp;&amp;</span> livePort <span class="token operator">==</span> modeQueuePort<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CFRUNLOOP_WAKEUP_FOR_TIMER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//9.1 处理timer事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__CFRunLoopDoTimers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> <span class="token function">mach_absolute_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Re-arm the next timer, because we apparently fired early</span>                <span class="token function">__CFArmNextTimerInMode</span><span class="token punctuation">(</span>rlm<span class="token punctuation">,</span> rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token macro property">#<span class="token directive keyword">if</span> USE_MK_TIMER_TOO</span>        <span class="token comment" spellcheck="true">//如果是定时器事件</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_timerPort <span class="token operator">!=</span> MACH_PORT_NULL <span class="token operator">&amp;&amp;</span> livePort <span class="token operator">==</span> rlm<span class="token operator">-></span>_timerPort<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CFRUNLOOP_WAKEUP_FOR_TIMER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.</span>            <span class="token comment" spellcheck="true">// In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span>           <span class="token comment" spellcheck="true">//9.1处理timer事件</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__CFRunLoopDoTimers</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> <span class="token function">mach_absolute_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Re-arm the next timer</span>                <span class="token function">__CFArmNextTimerInMode</span><span class="token punctuation">(</span>rlm<span class="token punctuation">,</span> rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token comment" spellcheck="true">//如果是dispatch到main queue的block</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>livePort <span class="token operator">==</span> dispatchPort<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">_CFSetTSD</span><span class="token punctuation">(</span>__CFTSDKeyIsInGCDMainQ<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span>            <span class="token keyword">void</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>            <span class="token comment" spellcheck="true">//9.2执行block</span>            <span class="token function">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">_CFSetTSD</span><span class="token punctuation">(</span>__CFTSDKeyIsInGCDMainQ<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopModeLock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>            sourceHandledThisLoop <span class="token operator">=</span> true<span class="token punctuation">;</span>            didDispatchPortLastTime <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">CFRUNLOOP_WAKEUP_FOR_SOURCE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Despite the name, this works for windows handles as well</span>            CFRunLoopSourceRef rls <span class="token operator">=</span> <span class="token function">__CFRunLoopModeFindSourceForMachPort</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> livePort<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 有source1事件待处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rls<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span>                mach_msg_header_t <span class="token operator">*</span>reply <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//9.2 处理source1事件</span>                sourceHandledThisLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopDoSource1</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> rls<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> msg<span class="token operator">-></span>msgh_size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reply<span class="token punctuation">)</span> <span class="token operator">||</span> sourceHandledThisLoop<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> reply<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">mach_msg</span><span class="token punctuation">(</span>reply<span class="token punctuation">,</span> MACH_SEND_MSG<span class="token punctuation">,</span> reply<span class="token operator">-></span>msgh_size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MACH_PORT_NULL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MACH_PORT_NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">CFAllocatorDeallocate</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> reply<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span>                sourceHandledThisLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopDoSource1</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> rls<span class="token punctuation">)</span> <span class="token operator">||</span> sourceHandledThisLoop<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">&amp;&amp;</span> msg <span class="token operator">!=</span> <span class="token punctuation">(</span>mach_msg_header_t <span class="token operator">*</span><span class="token punctuation">)</span>msg_buffer<span class="token punctuation">)</span> <span class="token function">free</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>        <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sourceHandledThisLoop <span class="token operator">&amp;&amp;</span> stopAfterHandle<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//进入run loop时传入的参数，处理完事件就返回</span>            retVal <span class="token operator">=</span> kCFRunLoopRunHandledSource<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout_context<span class="token operator">-></span>termTSR <span class="token operator">&lt;</span> <span class="token function">mach_absolute_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//run loop超时</span>            retVal <span class="token operator">=</span> kCFRunLoopRunTimedOut<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsStopped</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//run loop被手动终止</span>            <span class="token function">__CFRunLoopUnsetStopped</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            retVal <span class="token operator">=</span> kCFRunLoopRunStopped<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rlm<span class="token operator">-></span>_stopped<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//mode被终止</span>            rlm<span class="token operator">-></span>_stopped <span class="token operator">=</span> false<span class="token punctuation">;</span>            retVal <span class="token operator">=</span> kCFRunLoopRunStopped<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopModeIsEmpty</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> rlm<span class="token punctuation">,</span> previousMode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//mode中没有要处理的事件</span>            retVal <span class="token operator">=</span> kCFRunLoopRunFinished<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//除了上面这几种情况，都继续循环</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> retVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout_timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dispatch_source_cancel</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch_release</span><span class="token punctuation">(</span>timeout_timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">free</span><span class="token punctuation">(</span>timeout_context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> retVal<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>给源代码添加注释是一件非常需要耐心的事情。</strong></li></ul><blockquote><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。同时RunLoop有很多个mode，但是RunLoop在run的时候必须只能指定其中一个mode，运行起来之后，被指定的mode即为currentMode。</p></blockquote><blockquote><p>这里有个细节RunLoop 的超时时间就是使用 GCD 中的 dispatch_source_t来实现的对应到上面的代码可以看一看。</p></blockquote><h4 id="Runloop相关操作"><a href="#Runloop相关操作" class="headerlink" title="Runloop相关操作"></a>Runloop相关操作</h4><p>CFRunLoop是基于pthread来管理。iOS中不能直接创建Runloop，只能从系统中获取CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p><p>系统一共提供了如下几种方式，区别在于面向的框架不一样：</p><pre><code>CFRunLoopRef CFRunLoopGetCurrent(void);//获取当前线程的RunLoop对象CFRunLoopRef CFRunLoopGetMain(void);//获取主线程的RunLoop对象+(NSRunLoop *)currentRunLoop+(NSRunLoop *)mainRunLoop</code></pre><h5 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//取当前所在线程的RunLoop</span>CFRunLoopRef <span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CFRunLoopRef rl <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">_CFGetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rl<span class="token punctuation">)</span> <span class="token keyword">return</span> rl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//传入当前线程</span>    <span class="token keyword">return</span> <span class="token function">_CFRunLoopGet0</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在CFRunLoopGetCurrent函数内部调用了_CFRunLoopGet0()，传入的参数是当前线程（<code>eturn _CFRunLoopGet0(pthread_self());</code>）。这里可以看出，CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取。</p><h5 id="CFRunLoopGetMain"><a href="#CFRunLoopGetMain" class="headerlink" title="CFRunLoopGetMain"></a>CFRunLoopGetMain</h5><pre><code>//取主线程的RunLoopCFRunLoopRef CFRunLoopGetMain(void) {    CHECK_FOR_FORK();    static CFRunLoopRef __main = NULL; // no retain needed    //传入主线程    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed    return __main;}</code></pre><p>在CFRunLoopGetMain函数内部也调用了_CFRunLoopGet0()，传入的参数是主线程。可以看出，CFRunLoopGetMain()不管在主线程还是子线程中调用，都可以获取到主线程的RunLoop。</p><h5 id="CFRunLoopGet0"><a href="#CFRunLoopGet0" class="headerlink" title="CFRunLoopGet0"></a>CFRunLoopGet0</h5><p>获取当前的及主线程的runloop最终都是调用CFRunLoopGet0来实现的。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><span class="token keyword">static</span> CFMutableDictionaryRef __CFRunLoops <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/// 访问 loopsDic 时的锁, 可以知道__CFRunLoops是线程不安全的</span><span class="token keyword">static</span> CFSpinLock_t loopsLock <span class="token operator">=</span> CFSpinLockInit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// should only be called by Foundation</span><span class="token comment" spellcheck="true">// t==0 is a synonym for "main thread" that always works</span>CF_EXPORT CFRunLoopRef <span class="token function">_CFRunLoopGet0</span><span class="token punctuation">(</span>pthread_t t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果传入线程为空，默认则为主线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_equal</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> kNilPthreadT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    t <span class="token operator">=</span> <span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//加锁访问字典</span>    <span class="token function">__CFSpinLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>__CFRunLoops<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第一次进入时，初始化全局__CFSpinUnlock字典，并先为主线程创建一个 RunLoop。</span>        <span class="token function">__CFSpinUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    CFMutableDictionaryRef dict <span class="token operator">=</span> <span class="token function">CFDictionaryCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kCFTypeDictionaryValueCallBacks<span class="token punctuation">)</span><span class="token punctuation">;</span>    CFRunLoopRef mainLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopCreate</span><span class="token punctuation">(</span><span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CFDictionarySetValue</span><span class="token punctuation">(</span>dict<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span><span class="token function">pthread_main_thread_np</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mainLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//释放临时创建的变量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">OSAtomicCompareAndSwapPtrBarrier</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> dict<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">volatile</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>__CFRunLoops<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">CFRelease</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">CFRelease</span><span class="token punctuation">(</span>mainLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解锁</span>        <span class="token function">__CFSpinLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果不是第一次，则直接从字典里面取</span>    CFRunLoopRef loop <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">CFDictionaryGetValue</span><span class="token punctuation">(</span>__CFRunLoops<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__CFSpinUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果取不到则创建一个新的CFRunLoopRef，然后存在全局的字典里面，传入的参数（线程指针）作为key</span>    CFRunLoopRef newLoop <span class="token operator">=</span> <span class="token function">__CFRunLoopCreate</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFSpinLock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    loop <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token function">CFDictionaryGetValue</span><span class="token punctuation">(</span>__CFRunLoops<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loop<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//保存到字典</span>        <span class="token function">CFDictionarySetValue</span><span class="token punctuation">(</span>__CFRunLoops<span class="token punctuation">,</span> <span class="token function">pthreadPointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> newLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        loop <span class="token operator">=</span> newLoop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//释放资源</span>        <span class="token comment" spellcheck="true">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span>        <span class="token function">__CFSpinUnlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loopsLock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CFRelease</span><span class="token punctuation">(</span>newLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果传入的线程是当前线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_equal</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">_CFSetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoop<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>loop<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">_CFGetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoopCntr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span>            <span class="token function">_CFSetTSD</span><span class="token punctuation">(</span>__CFTSDKeyRunLoopCntr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>PTHREAD_DESTRUCTOR_ITERATIONS<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>__CFFinalizeRunLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> loop<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面代码可以总结出:</p><ul><li>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</li><li>线程刚创建时并没有 RunLoop（没有加到对应的runloop字典中），如果你不主动获取，那它一直都不会有。</li><li>RunLoop 的创建是发生在第一次获取时。一般是获取主线程的时候。</li><li>RunLoop 的销毁是发生在线程结束时。</li><li>只能在一个线程的内部获取其 RunLoop（主线程除外），否则就这个Runloop就没有注册销毁回调。这一点是根据<code>pthread_equal(t, pthread_self())</code>后面的代码，如果是当前线程后面才会注册销毁回调。<strong>因为上面讲过Runlopp暴露给外部的创建方式只有CFRunLoopGetMain() 和 CFRunLoopGetCurrent()两种，所以这种情况不用考虑。</strong>下面是CFRunloop.h的头文件暴露接口，可以看到获取方式只有两种。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/664334-f35be006cb828f58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="Mode相关操作"><a href="#Mode相关操作" class="headerlink" title="Mode相关操作"></a>Mode相关操作</h4><p>在Core Foundation中，针对Mode的操作，苹果只开放了如下API:</p><pre><code>CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode)//向当前RunLoop的common modes中添加一个mode。CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl)//返回当前运行的mode的nameCFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl)//返回当前RunLoop的所有mode</code></pre><blockquote><p>我们没有办法直接创建一个CFRunLoopMode对象，但是我们可以调用CFRunLoopAddCommonMode传入一个字符串向RunLoop中添加Mode，传入的字符串即为Mode的名字，Mode对象应该是此时在RunLoop内部创建的。<strong>特别注意只能通过CFRunLoopAddCommonMode，是CommonMode。</strong></p></blockquote><h5 id="CFRunLoopAddCommonMode"><a href="#CFRunLoopAddCommonMode" class="headerlink" title="CFRunLoopAddCommonMode"></a>CFRunLoopAddCommonMode</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CFRunLoopAddCommonMode</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsDeallocating</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//看rl中是否已经有这个mode，如果有就什么都不做</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_commonModes<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CFSetRef set <span class="token operator">=</span> rl<span class="token operator">-></span>_commonModeItems <span class="token operator">?</span> <span class="token function">CFSetCreateCopy</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> rl<span class="token operator">-></span>_commonModeItems<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//把modeName添加到RunLoop的_commonModes中</span>        <span class="token function">CFSetAddValue</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_commonModes<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            CFTypeRef context<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>rl<span class="token punctuation">,</span> modeName<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* add all common-modes items to new mode */</span>            <span class="token comment" spellcheck="true">//__CFRunLoopAddItemsToCommonMode是一个方法，里面会调用CFRunLoopAddSource/CFRunLoopAddObserver/CFRunLoopAddTimer</span>            <span class="token comment" spellcheck="true">//__CFRunLoopFindMode(rl, modeName, true)，CFRunLoopMode对象在这个时候被创建</span>            <span class="token function">CFSetApplyFunction</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> <span class="token punctuation">(</span>__CFRunLoopAddItemsToCommonMode<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">CFRelease</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以总结出如下几点：</p><ul><li>modeName不能重复，modeName是mode的唯一标识符</li><li>添加commonMode会把commonModeItems数组中的所有item(source，observe，timer,)同步到新添加的mode中。</li></ul><p>CFRunLoopCopyCurrentMode/CFRunLoopCopyAllModes实现比较简单，直接返回对应的model。</p><h4 id="Source相关操作（ModeItem）"><a href="#Source相关操作（ModeItem）" class="headerlink" title="Source相关操作（ModeItem）"></a>Source相关操作（ModeItem）</h4><p>系统提供了如下几个函数来操作Item</p><pre class="line-numbers language-c"><code class="language-c">CF_EXPORT Boolean <span class="token function">CFRunLoopContainsSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT <span class="token keyword">void</span> <span class="token function">CFRunLoopAddSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT <span class="token keyword">void</span> <span class="token function">CFRunLoopRemoveSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT Boolean <span class="token function">CFRunLoopContainsObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT <span class="token keyword">void</span> <span class="token function">CFRunLoopAddObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT <span class="token keyword">void</span> <span class="token function">CFRunLoopRemoveObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT Boolean <span class="token function">CFRunLoopContainsTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT <span class="token keyword">void</span> <span class="token function">CFRunLoopAddTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span>CF_EXPORT <span class="token keyword">void</span> <span class="token function">CFRunLoopRemoveTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFRunLoopMode mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到总体来讲提供了对item的判断是否已经包含item，添加，删除的功能。</p><h5 id="CFRunLoopAddSource"><a href="#CFRunLoopAddSource" class="headerlink" title="CFRunLoopAddSource"></a>CFRunLoopAddSource</h5><p>作用：将一个CFRunLoopAddSource对象添加到一个指定的Runloop Model中。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//添加source事件</span><span class="token keyword">void</span> <span class="token function">CFRunLoopAddSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef rls<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* DOES CALLOUT */</span>    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__CFRunLoopIsDeallocating</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__CFIsValid</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    Boolean doVer0Callout <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是kCFRunLoopCommonModes</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modeName <span class="token operator">==</span> kCFRunLoopCommonModes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果runloop的_commonModes存在，则copy一个新的复制给set</span>        CFSetRef set <span class="token operator">=</span> rl<span class="token operator">-></span>_commonModes <span class="token operator">?</span> <span class="token function">CFSetCreateCopy</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> rl<span class="token operator">-></span>_commonModes<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果runl _commonModeItems为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> rl<span class="token operator">-></span>_commonModeItems<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//先初始化</span>            rl<span class="token operator">-></span>_commonModeItems <span class="token operator">=</span> <span class="token function">CFSetCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kCFTypeSetCallBacks<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//把传入的CFRunLoopSourceRef加入_commonModeItems</span>        <span class="token function">CFSetAddValue</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_commonModeItems<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果刚才set copy到的数组里有数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>            CFTypeRef context<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>rl<span class="token punctuation">,</span> rls<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* add new item to all common-modes */</span>            <span class="token comment" spellcheck="true">//则把set里的所有mode都执行一遍__CFRunLoopAddItemToCommonModes函数</span>            <span class="token function">CFSetApplyFunction</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> <span class="token punctuation">(</span>__CFRunLoopAddItemToCommonModes<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">CFRelease</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//以上分支的逻辑就是，如果你往kCFRunLoopCommonModes里面添加一个source，那么所有_commonModes里的mode都会添加这个source</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据modeName查找mode</span>        CFRunLoopModeRef rlm <span class="token operator">=</span> <span class="token function">__CFRunLoopFindMode</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果_sources0不存在，则初始化_sources0，_sources0和_portToV1SourceMap</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm <span class="token operator">&amp;&amp;</span> <span class="token constant">NULL</span> <span class="token operator">==</span> rlm<span class="token operator">-></span>_sources0<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rlm<span class="token operator">-></span>_sources0 <span class="token operator">=</span> <span class="token function">CFSetCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kCFTypeSetCallBacks<span class="token punctuation">)</span><span class="token punctuation">;</span>            rlm<span class="token operator">-></span>_sources1 <span class="token operator">=</span> <span class="token function">CFSetCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kCFTypeSetCallBacks<span class="token punctuation">)</span><span class="token punctuation">;</span>            rlm<span class="token operator">-></span>_portToV1SourceMap <span class="token operator">=</span> <span class="token function">CFDictionaryCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果_sources0和_sources1中都不包含传入的source</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources0<span class="token punctuation">,</span> rls<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources1<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果version是0，则加到_sources0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">CFSetAddValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources0<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果version是1，则加到_sources1</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">CFSetAddValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources1<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>                __CFPort src_port <span class="token operator">=</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version1<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span>rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version1<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>CFPORT_NULL <span class="token operator">!=</span> src_port<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//此处只有在加到source1的时候才会把souce和一个mach_port_t对应起来</span>                    <span class="token comment" spellcheck="true">//可以理解为，source1可以通过内核向其端口发送消息来主动唤醒runloop</span>                    <span class="token function">CFDictionarySetValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_portToV1SourceMap<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>src_port<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">__CFPortSetInsert</span><span class="token punctuation">(</span>src_port<span class="token punctuation">,</span> rlm<span class="token operator">-></span>_portSet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">__CFRunLoopSourceLock</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//把runloop加入到source的_runLoops中</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> rls<span class="token operator">-></span>_runLoops<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rls<span class="token operator">-></span>_runLoops <span class="token operator">=</span> <span class="token function">CFBagCreateMutable</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kCFTypeBagCallBacks<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// sources retain run loops!</span>            <span class="token punctuation">}</span>            <span class="token function">CFBagAddValue</span><span class="token punctuation">(</span>rls<span class="token operator">-></span>_runLoops<span class="token punctuation">,</span> rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopSourceUnlock</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>schedule<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    doVer0Callout <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>doVer0Callout<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// although it looses some protection for the source, we have no choice but</span>        <span class="token comment" spellcheck="true">// to do this after unlocking the run loop and mode locks, to avoid deadlocks</span>        <span class="token comment" spellcheck="true">// where the source wants to take a lock which is already held in another</span>        <span class="token comment" spellcheck="true">// thread which is itself waiting for a run loop/mode lock</span>        rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>info<span class="token punctuation">,</span> rl<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* CALLOUT */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以总结如下：</p><ul><li>source会被runloop持有。</li><li>如果modeName传入kCFRunLoopCommonModes，则该source会被保存到RunLoop的commonModeItems中，然后添加到common models每个mode下面，进而被所有的common models监控。</li><li>如果modeName传入的不是kCFRunLoopCommonModes，则会先查找该Mode，如果没有，会创建一个。</li><li>同一个source在一个mode中只能被添加一次。</li><li>只有在加到source1的时候才会把souce和一个mach_port_t对应起来，这个mach_port_t由source传入。</li></ul><h5 id="CFRunLoopRemoveSource"><a href="#CFRunLoopRemoveSource" class="headerlink" title="CFRunLoopRemoveSource"></a>CFRunLoopRemoveSource</h5><p>remove操作和add操作的逻辑基本一致，很容易理解</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//移除source</span><span class="token keyword">void</span> <span class="token function">CFRunLoopRemoveSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef rls<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* DOES CALLOUT */</span>    <span class="token function">CHECK_FOR_FORK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Boolean doVer0Callout <span class="token operator">=</span> false<span class="token punctuation">,</span> doRLSRelease <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果是kCFRunLoopCommonModes，则从_commonModes的所有mode中移除该source</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modeName <span class="token operator">==</span> kCFRunLoopCommonModes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rl<span class="token operator">-></span>_commonModeItems <span class="token operator">&amp;&amp;</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_commonModeItems<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            CFSetRef set <span class="token operator">=</span> rl<span class="token operator">-></span>_commonModes <span class="token operator">?</span> <span class="token function">CFSetCreateCopy</span><span class="token punctuation">(</span>kCFAllocatorSystemDefault<span class="token punctuation">,</span> rl<span class="token operator">-></span>_commonModes<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">CFSetRemoveValue</span><span class="token punctuation">(</span>rl<span class="token operator">-></span>_commonModeItems<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>                CFTypeRef context<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>rl<span class="token punctuation">,</span> rls<span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* remove new item from all common-modes */</span>                <span class="token function">CFSetApplyFunction</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> <span class="token punctuation">(</span>__CFRunLoopRemoveItemFromCommonModes<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">CFRelease</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据modeName查找mode，如果不存在，返回NULL</span>        CFRunLoopModeRef rlm <span class="token operator">=</span> <span class="token function">__CFRunLoopFindMode</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> modeName<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm<span class="token operator">-></span>_sources0 <span class="token operator">&amp;&amp;</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources0<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm<span class="token operator">-></span>_sources1 <span class="token operator">&amp;&amp;</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources1<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">CFRetain</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//根据source版本做对应的remove操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>                __CFPort src_port <span class="token operator">=</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version1<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span>rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version1<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>CFPORT_NULL <span class="token operator">!=</span> src_port<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">CFDictionaryRemoveValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_portToV1SourceMap<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>src_port<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">__CFPortSetRemove</span><span class="token punctuation">(</span>src_port<span class="token punctuation">,</span> rlm<span class="token operator">-></span>_portSet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">CFSetRemoveValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources0<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">CFSetRemoveValue</span><span class="token punctuation">(</span>rlm<span class="token operator">-></span>_sources1<span class="token punctuation">,</span> rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">__CFRunLoopSourceLock</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rls<span class="token operator">-></span>_runLoops<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">CFBagRemoveValue</span><span class="token punctuation">(</span>rls<span class="token operator">-></span>_runLoops<span class="token punctuation">,</span> rl<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">__CFRunLoopSourceUnlock</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>cancel<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    doVer0Callout <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            doRLSRelease <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> rlm<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>doVer0Callout<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// although it looses some protection for the source, we have no choice but</span>        <span class="token comment" spellcheck="true">// to do this after unlocking the run loop and mode locks, to avoid deadlocks</span>        <span class="token comment" spellcheck="true">// where the source wants to take a lock which is already held in another</span>        <span class="token comment" spellcheck="true">// thread which is itself waiting for a run loop/mode lock</span>        rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span>rls<span class="token operator">-></span>_context<span class="token punctuation">.</span>version0<span class="token punctuation">.</span>info<span class="token punctuation">,</span> rl<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* CALLOUT */</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>doRLSRelease<span class="token punctuation">)</span> <span class="token function">CFRelease</span><span class="token punctuation">(</span>rls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="CFRunLoopAddItemToCommonModes"><a href="#CFRunLoopAddItemToCommonModes" class="headerlink" title="CFRunLoopAddItemToCommonModes"></a>CFRunLoopAddItemToCommonModes</h5><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__CFRunLoopAddItemToCommonModes</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    CFStringRef modeName <span class="token operator">=</span> <span class="token punctuation">(</span>CFStringRef<span class="token punctuation">)</span>value<span class="token punctuation">;</span>    CFRunLoopRef rl <span class="token operator">=</span> <span class="token punctuation">(</span>CFRunLoopRef<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CFTypeRef <span class="token operator">*</span><span class="token punctuation">)</span>ctx<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取出runloop</span>    CFTypeRef item <span class="token operator">=</span> <span class="token punctuation">(</span>CFTypeRef<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CFTypeRef <span class="token operator">*</span><span class="token punctuation">)</span>ctx<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取出添加到item(可能是source、observer、timer)</span>    <span class="token comment" spellcheck="true">//根据类型添加到对应的model中。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CFGetTypeID</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">CFRunLoopSourceGetTypeID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">CFRunLoopAddSource</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> <span class="token punctuation">(</span>CFRunLoopSourceRef<span class="token punctuation">)</span>item<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CFGetTypeID</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">CFRunLoopObserverGetTypeID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">CFRunLoopAddObserver</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> <span class="token punctuation">(</span>CFRunLoopObserverRef<span class="token punctuation">)</span>item<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CFGetTypeID</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">CFRunLoopTimerGetTypeID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">CFRunLoopAddTimer</span><span class="token punctuation">(</span>rl<span class="token punctuation">,</span> <span class="token punctuation">(</span>CFRunLoopTimerRef<span class="token punctuation">)</span>item<span class="token punctuation">,</span> modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Observer-Timer的相关操作"><a href="#Observer-Timer的相关操作" class="headerlink" title="Observer/Timer的相关操作"></a>Observer/Timer的相关操作</h4><p>添加observer和timer的内部逻辑和添加source大体类似。</p><blockquote><p>区别在于observer和timer只能被添加到一个RunLoop的一个或者多个mode中，比如一个timer被添加到主线程的RunLoop中，则不能再把该timer添加到子线程的RunLoop，而source没有这个限制，不管是哪个RunLoop，只要mode中没有，就可以添加。</p></blockquote><p>上面的记录可以从CFRunLoopSource结构体可以明确的知道。<strong>CFRunLoopSource中有保存RunLoop对象的数组，而CFRunLoopObserver和CFRunLoopTimer只有单个RunLoop对象。</strong></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上内容是对runloop从源码角度的理解过程。由于代码比较多，看起来也费事，可以直接选择重点内容看。下面的内容主要来至于<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a>这篇文章。毕竟这篇文章在国内来讲，是研究runloop文章中，国内写得非常有参考价值的文章。</p><h2 id="Runloop在系统中的应用（下面内容大部分来源于深入理解RunLoop）"><a href="#Runloop在系统中的应用（下面内容大部分来源于深入理解RunLoop）" class="headerlink" title="Runloop在系统中的应用（下面内容大部分来源于深入理解RunLoop）"></a>Runloop在系统中的应用（下面内容大部分来源于<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a>）</h2><p>首先把之前的runloop执行过程中的函数使用长函数名改一下，这样便于在实际调试中便于分析。因为在真实debug时不会出现上面的函数名，而是通过长函数名代替，在源码中也能看到之前的函数名和这里的长函数名是同一个函数。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// 1. 通知Observers，即将进入RunLoop</span>    <span class="token comment" spellcheck="true">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span>    <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>kCFRunLoopEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// 2. 通知 Observers: 即将触发 Timer 回调。</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>kCFRunLoopBeforeTimers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>kCFRunLoopBeforeSources<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 4. 触发 Source0 (非基于port的) 回调。</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><span class="token punctuation">(</span>source0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 6. 通知Observers，即将进入休眠</span>        <span class="token comment" spellcheck="true">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>kCFRunLoopBeforeWaiting<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 7. sleep to wait msg.</span>        <span class="token function">mach_msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">mach_msg_trap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 8. 通知Observers，线程被唤醒</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>kCFRunLoopAfterWaiting<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 9. 如果是被Timer唤醒的，回调Timer</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span>        <span class="token function">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="token punctuation">(</span>dispatched_block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span>        <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><span class="token punctuation">(</span>source1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 10. 通知Observers，即将退出RunLoop</span>    <span class="token comment" spellcheck="true">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span>    <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="token punctuation">(</span>kCFRunLoopExit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里举个例子，如下debug信息：<br><img src="https://upload-images.jianshu.io/upload_images/664334-94979e984762bb5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>对应到上面的过程就是：<strong>触发 Source0 (非基于port的) 回调。</strong></p><p>下图是对主线程的runloop的中在kCFRunLoopDefaultMode模式下所有的observer的日志。<br><img src="https://upload-images.jianshu.io/upload_images/664334-ddac29c5cbd56ccc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>在最开始介绍CFRunloop的时候就简单提了一下其中关于block的两个字段blocks_head，blocks_tail。并且也提到在runloop周期中会对此调用__CFRunLoopDoBlocks来执行加入到这个runloop的block。下面从源码来说明一下block如何与runloop结合的。</p><p>先来看看最基本的block_item 数据结构，特别注意这里保存了runloop的model，决定了block是否应该执行。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> _block_item <span class="token punctuation">{</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>_next<span class="token punctuation">;</span>    CFTypeRef _mode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// CFString or CFSet</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>_block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行block的时候会传入</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** 执行block @param rl runloop @param rlm 当前的model @return 是否执行 */</span><span class="token keyword">static</span> Boolean <span class="token function">__CFRunLoopDoBlocks</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopModeRef rlm<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Call with rl and rlm locked</span>   <span class="token comment" spellcheck="true">//如果头结点没有、或者model不存在则强制返回，什么也不做</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rl<span class="token operator">-></span>_blocks_head<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rlm <span class="token operator">||</span> <span class="token operator">!</span>rlm<span class="token operator">-></span>_name<span class="token punctuation">)</span> <span class="token keyword">return</span> false<span class="token punctuation">;</span>    Boolean did <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录其中一个block结点是否被执行过</span>    <span class="token comment" spellcheck="true">//取出头尾结点，并且将当前runloop保存的头尾节点置位NULL</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>head <span class="token operator">=</span> rl<span class="token operator">-></span>_blocks_head<span class="token punctuation">;</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>tail <span class="token operator">=</span> rl<span class="token operator">-></span>_blocks_tail<span class="token punctuation">;</span>    rl<span class="token operator">-></span>_blocks_head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    rl<span class="token operator">-></span>_blocks_tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取出被标记为common的所有mode、及当前model的name</span>    CFSetRef commonModes <span class="token operator">=</span> rl<span class="token operator">-></span>_commonModes<span class="token punctuation">;</span>    CFStringRef curMode <span class="token operator">=</span> rlm<span class="token operator">-></span>_name<span class="token punctuation">;</span>    <span class="token function">__CFRunLoopModeUnlock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__CFRunLoopUnlock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义两个临时变量，用于对保存block链表的遍历</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>item <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录头指针，从头部开始遍历</span>    <span class="token comment" spellcheck="true">//开始遍历block链表</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> _block_item <span class="token operator">*</span>curr <span class="token operator">=</span> item<span class="token punctuation">;</span>        item <span class="token operator">=</span> item<span class="token operator">-></span>_next<span class="token punctuation">;</span>    Boolean doit <span class="token operator">=</span> false；<span class="token comment" spellcheck="true">//表示是否应该执行这个block,注意和前面的did区分开</span>    <span class="token comment" spellcheck="true">//从blockitem结构体就知道,其中的_mode只能是CFString 或者CFSet</span>    <span class="token comment" spellcheck="true">//如果block结点保存的model是CFString类型</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CFStringGetTypeID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">CFGetTypeID</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>_mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//是否执行block只需要满足下面三个条件中的一个</span>       <span class="token comment" spellcheck="true">//1. blockitem 中保存的model是当前的model</span>       <span class="token comment" spellcheck="true">//2. blockitem 中保存的model是标记为kCFRunLoopCommonModes的model</span>       <span class="token comment" spellcheck="true">//3. 当前model保存在commonModes数组</span>        doit <span class="token operator">=</span> <span class="token function">CFEqual</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>_mode<span class="token punctuation">,</span> curMode<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">CFEqual</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>_mode<span class="token punctuation">,</span> kCFRunLoopCommonModes<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>commonModes<span class="token punctuation">,</span> curMode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//如果block结点保存的model是CFSet类型，步骤和上面一样，等于换成了包含。</span>        doit <span class="token operator">=</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CFSetRef<span class="token punctuation">)</span>curr<span class="token operator">-></span>_mode<span class="token punctuation">,</span> curMode<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>CFSetRef<span class="token punctuation">)</span>curr<span class="token operator">-></span>_mode<span class="token punctuation">,</span> kCFRunLoopCommonModes<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">CFSetContainsValue</span><span class="token punctuation">(</span>commonModes<span class="token punctuation">,</span> curMode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果不执行block,则直接移动当前结点，进行下一个blockitem的判断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>doit<span class="token punctuation">)</span> prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>doit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果执行block,则先移动结点。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">)</span> prev<span class="token operator">-></span>_next <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">==</span> head<span class="token punctuation">)</span> head <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">==</span> tail<span class="token punctuation">)</span> tail <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> curr<span class="token operator">-></span>_block<span class="token punctuation">;</span>            <span class="token function">CFRelease</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>_mode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>doit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//最终在这里执行block，__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__的函数原型就是调用block</span>                <span class="token function">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>            did <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token punctuation">}</span>            <span class="token function">Block_release</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">__CFRunLoopLock</span><span class="token punctuation">(</span>rl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">__CFRunLoopModeLock</span><span class="token punctuation">(</span>rlm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//重建循环链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tail<span class="token operator">-></span>_next <span class="token operator">=</span> rl<span class="token operator">-></span>_blocks_head<span class="token punctuation">;</span>    rl<span class="token operator">-></span>_blocks_head <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rl<span class="token operator">-></span>_blocks_tail<span class="token punctuation">)</span> rl<span class="token operator">-></span>_blocks_tail <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> did<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面分析可以知道：</p><ol><li>block其实在runloop中通过循环链表保存的</li><li>如果block可以加入到多个model下面，但是执行block只有在加入的那个model下才能之后，或者加入modle用common标记</li><li>每次调用__CFRunLoopDoBlocks，会把加入的block遍历执行，然后重置循环链表。</li></ol><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。<strong>这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</strong></p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><p><strong>关于Autorelease后面需要一篇源码分析来说明问题。</strong></p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>上面可以看到第二个observe就是_UIGestureRecognizerUpdateObserver，关于手势识别的。</p><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>上面可以看到第三和四个observe分别是_beforeCACommitHandler与_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv，是关于动画及界面更新的。</p><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>上面截图中还有个timer</p><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>当调用 NSObject 的 performSelecter:afterDelay: 来实现延迟执行，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。<strong>所以如果当前线程没有 RunLoop，则这个方法会失效。</strong></p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，<strong>同样的，如果对应线程没有 RunLoop 该方法也会失效。</strong></p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><blockquote><p>在看runloop执行过程的源码中，可以知道RunLoop 的超时时间就是使用 GCD 中的 dispatch_source_t来实现的。</p></blockquote><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p><pre class="line-numbers language-c"><code class="language-c">CFSocketCFNetwork       <span class="token operator">-></span>ASIHttpRequestNSURLConnection <span class="token operator">-></span>AFNetworkingNSURLSession    <span class="token operator">-></span>AFNetworking2<span class="token punctuation">,</span> Alamofire<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>CFSocket 是最底层的接口，只负责 socket 通信。<br>• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。<br>• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。<br>• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。<br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt></p><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="Runloop在平时开发中的应用（深入理解RunLoop）"><a href="#Runloop在平时开发中的应用（深入理解RunLoop）" class="headerlink" title="Runloop在平时开发中的应用（深入理解RunLoop）"></a>Runloop在平时开发中的应用（<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a>）</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p>为了线程保活。<br>代码：</p><pre class="line-numbers language-objective-c"><code class="language-objective-c">- (void)start {    [self.lock lock];    if ([self isCancelled]) {        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];    } else if ([self isReady]) {        self.state = AFOperationExecutingState;        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];    }    [self.lock unlock];}+ (NSThread *)networkRequestThread {    static NSThread *_networkRequestThread = nil;    static dispatch_once_t oncePredicate;    dispatch_once(&oncePredicate, ^{        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];        [_networkRequestThread start];    });    return _networkRequestThread;}+ (void)networkRequestThreadEntryPoint:(id)__unused object {    @autoreleasepool {        [[NSThread currentThread] setName:@"AFNetworking"];        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];        [runLoop run];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面函数的调用关系由上到下调用。</p><p>AF希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop。过程在networkRequestThreadEntryPoint中，因为RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中，具体内容对应start方法。</p><h3 id="UITableView-FDTemplateLayoutCell"><a href="#UITableView-FDTemplateLayoutCell" class="headerlink" title="UITableView+FDTemplateLayoutCell"></a>UITableView+FDTemplateLayoutCell</h3><p>利用runloop的空闲状态计算高度达到预缓存的功能。具体分析见这里<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a></p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><p>可以直接看源码进行分析<a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a>，但是现在更名为<a href="https://github.com/texturegroup/texture/" target="_blank" rel="noopener">Texture</a></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#/apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">RunLoop官方介绍</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS动态库、静态库及使用场景、方式</title>
      <link href="/2018/03/15/2018/3/iOS%E5%8A%A8%E6%80%81%E5%BA%93%E3%80%81%E9%9D%99%E6%80%81%E5%BA%93%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%81%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/03/15/2018/3/iOS%E5%8A%A8%E6%80%81%E5%BA%93%E3%80%81%E9%9D%99%E6%80%81%E5%BA%93%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>前面介绍过制作过程，这里不讲如何制作动态库、静态库。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>静态库和动态库都是以二进制提供代码复用的代码库。</p><ul><li>静态库常见的是 .a</li><li>动态库（共享库）常见的是 Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd。</li></ul><p>特别注意平时我们经常说的Framework(in Apple) 是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用。<strong>也就是说我们的 Framework其实是资源打包的方式，和静态库动态库的本质是没有什么关系。</strong></p><h2 id="静态库和动态库的区别"><a href="#静态库和动态库的区别" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h2><p>首先来看什么是库，库(Library)说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。我们在和别人合作的时候，一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p><ul><li>静态库:<strong>链接时会被完整的复制到可执行文件中</strong>，所以如果两个程序都用了某个静态库，那么每个二进制可执行文件里面其实都含有这份静态库的代码。</li><li>动态库: 链接时不复制，在程序启动后用动态加载，然后再决议符号，<strong>所以理论上动态库只用存在一份，好多个程序都可以动态链接到这个动态库上面，达到了节省内存(不是磁盘是内存中只有一份动态库)，还有另外一个好处，由于动态库并不绑定到可执行程序上</strong>，所以我们想升级这个动态库就很容易，windows和linux上面一般插件和模块机制都是这样实现的。</li></ul><p>动态库和静态库都是由<code>*.o</code>目标文件生成的。</p><p>对比一下静态和动态库的优缺点</p><table><thead><tr><th>库类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>静态库</td><td>1. 目标程序没有外部依赖，直接就可以运行。2. 效率教动态库高。 <br></td><td>1. 会使用目标程序的体积增大。</td></tr><tr><td>动态库</td><td>1. 不需要拷贝到目标程序中，不会影响目标程序的体积。<br> 2. 同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。<br> 3. 编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。实现动态更新</td><td>1. 动态载入会带来一部分性能损失(可以忽略不计）<br>2. 动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux  lib not found 错误）。</td></tr></tbody></table><h2 id="iOS的动态库（被阉割的动态库）"><a href="#iOS的动态库（被阉割的动态库）" class="headerlink" title="iOS的动态库（被阉割的动态库）"></a>iOS的动态库（被阉割的动态库）</h2><p>iOS平台上规定不允许存在动态库，并且所有的 IPA 都需要经过Apple的私钥加密后才能用，基本你用了动态库也会因为签名不对无法加载，(越狱和非 APP store 除外)。于是就把开发者自己开发动态库成为了天方夜谭。</p><p>iOS8之前因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，并且iOS是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，给谁共享呢。同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，<strong>综上所以上动态库也就没有存在的必要了</strong>。</p><p>但是后来iOS8之后，iOS有了App Extesion特性，而且Swift也诞生了。<strong>由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，于是苹果后来提出了Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库。</strong></p><p>但是这种动态库（Embedded Framework） 和系统的 UIKit.Framework 还是有很大区别，传统的动态库是给多个进程用的，而这里的动态库（Embedded Framework）是给单个进程里面多个可执行文件用的。<strong>系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 动态库（Embedded Framework） 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的）。所以苹果没有直接把这种Embedded Framework称作动态库而是叫Embedded Framework。</strong></p><p>上面提到跟Swift也有原因，在Swift的项目中如果要在项目中使用外部的代码，可选的方式只有两种，一种是把代码拷贝到工程中，另一种是用动态 Framework。<strong>使用静态库是不支持的</strong>。这个问题的根本原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），<strong>静态库会导致最终的目标程序中包含重复的运行库</strong>（<a href="https://github.com/ksm/SwiftInFlux#static-libraries" target="_blank" rel="noopener">这是苹果自家的解释</a>）。原文如下：</p><blockquote><p>The current runtime doesn’t ship with the OS, so static libs would lead to multiple runtimes in the final executable. A statically linked runtime would be much more difficult to patch for compatibility with newer OS or Swift.</p></blockquote><p> iOS中的Embedded Framework可以理解为独立的没有main函数的可执行文件。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote><p>前面提到的静态库可以简单理解为<strong>一堆目标文件(.o/.obj)的打包体(并非二进制文件)</strong>，而动态库可以简单理解为 一个没有main函数的可执行文件。</p></blockquote><p>大学再讲编译原理的时候有两个非常重要的过程，编译和链接。编译可以理解为将源代码编译为目标文件，链接可以理解为将各种目标文件上加一些第三方库、并且和系统库链接起来为可执行文件。<strong>因为某个目标文件的符号（可以理解为变化、函数）可能来至其他目标文件，链接最为主要的就是决议符号的地址。</strong></p><p>编译会生成目标文件，目标文件<strong>没有经过链接的过程，某些符号还没有调整过</strong>，Windows下的.obj文件，Linux下的.o文件，Unix的.out文件。</p><p>链接的过程可以简单描述如下：<br>假如主程序main.c 使用了 fun.c 模块的 foo函数，那么main.c在编译的过程，对于调用foo函数的指令，<strong>对于指令的目标地址暂时搁置；待到链接的时候，由链接器来填写foo函数的地址。</strong></p><p>在决议符号的时候有如下规则：</p><ul><li>若符号来自静态库(本质就是.o 的集合包)或 .o，<strong>将其纳入链接产物</strong>，并确定符号地址。<strong>常见的符号冲突就出现在这一步。</strong></li><li><strong>若符号来自动态库，打个标记，等启动的时候再说—交给dyld去加载和链接符号。</strong>也就是把链接的过程推迟到运行时再进行，上面讲到的静态库符号冲突就可以推迟到运行时在解决，而具体怎么解决由系统去决定。如果这两个符号表示的意思是一样（<strong>比如函数符号冲突但是函数的实现是一样的</strong>）的就没有问题。</li></ul><p>如果要深入了解一下相关知识，建议看一下《程序员自我修养》这本书，我也只懂皮毛。</p><h2 id="静态库和动态库依赖关系"><a href="#静态库和动态库依赖关系" class="headerlink" title="静态库和动态库依赖关系"></a>静态库和动态库依赖关系</h2><ul><li>第一种静态库互相依赖，这种情况非常常见，制作静态库的时候<strong>只需要有被依赖的静态库头文件在就能编译出来</strong>。但是这就意味者你要收到告诉使用者你的依赖关系。</li><li>第二种动态库依赖动态库，<strong>两个动态库是相互隔离的具有隔离性</strong>。在制作的静态库的时候需要被依赖动态库参与链接，最终具体的符号决议交给dyld来做。</li><li>第三种，静态库依赖动态库，也很常见，静态库制作的时候也需要动态库参与链接，但是符号的决议交给dyld来做。</li><li>第四种，动态库依赖静态库，这种情况就有点特殊。首先我们设想动态库编译的时候需要静态库参与编译，但是静态库交由dyld来做符号决议，这和我们前面说的就矛盾了啊。<strong>静态库本质是一堆.o 的打包体，首先并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件。</strong></li></ul><p>对于第四种情况解决办法如下：</p><blockquote><p>目前的编译器的解决办法是，首先我无法保证主程序是否包含静态库，再者静态库也无法被dyld加载，那么我直接把你静态库的.o 偷过来，共同组成一个新的二进制。<strong>也被称做吸附性</strong>。</p></blockquote><p>如果有多个动态库依赖这个静态库就会，每个动态库为了保证自己的正确性会把静态库吸附进来。然后两个库包含了同样的静态库，于是问题就出现了。</p><h2 id="利用动态库解决相关问题"><a href="#利用动态库解决相关问题" class="headerlink" title="利用动态库解决相关问题"></a>利用动态库解决相关问题</h2><p>有了上面的知识就可以解决一些平时遇到的疑难杂症。</p><h3 id="处理多个动态库依赖一个静态库问题"><a href="#处理多个动态库依赖一个静态库问题" class="headerlink" title="处理多个动态库依赖一个静态库问题"></a>处理多个动态库依赖一个静态库问题</h3><p>通过前面我们知道可执文件（主程序或者动态库）在构建的链接阶段，<strong>遇到静态库，吸附进来；遇到动态库，打标记，彼此保持独立。</strong></p><p>正因为动态库是保持独立的，那么我们可以自定义一个动态库把依赖的静态库吸附进来。<strong>对外整体呈现的是动态库特性。其他的组件依赖我们自定义的动态库，由于隔离性的存在，不会出现问题。</strong></p><blockquote><p>这个思路在处理项目组件化的时候非常有用，尤其是在使用Swift的项目中。</p></blockquote><h3 id="利用动态库处理静态库与静态库的符号冲突问题"><a href="#利用动态库处理静态库与静态库的符号冲突问题" class="headerlink" title="利用动态库处理静态库与静态库的符号冲突问题"></a>利用动态库处理静态库与静态库的符号冲突问题</h3><blockquote><p>需要知道，在打包IPA的时候，最终静态库会被连接到最终的那个可执行文件中。所以如果多个静态库拥有了相同的符号必定会产生符号冲突。</p></blockquote><p>前面讲过可以把动态库看成一个独立的没有main函数入口的可执行文件，在iOS打包中直接copy到应用程序<code>.app</code>目录下的Frameworks目录。既然是可执行文件那么内部编译连接过程已经完成了，要处理的连接也只有在加载的时候由操作系统的dyld自动load + link。</p><p>所以最终系统在加载动态库的时候和静态库的符号根本没有丝毫关系，进而避免了链接时产生的符号冲突。</p><blockquote><p>这一点在处理一些由于底层三方库源码不能手动修改（比如boringssl与openssl）的时候，非常有用。</p></blockquote><h2 id="动态库的动态装载"><a href="#动态库的动态装载" class="headerlink" title="动态库的动态装载"></a>动态库的动态装载</h2><p>目前iOS中动态更新方案有如下几种：</p><ul><li>HTML 5</li><li>lua（wax）hotpatch</li><li>react native</li><li>framework</li></ul><p>使用 framework 的方式来更新可以不依赖第三方库，使用原生的 OC/Swift 来开发，体验更好。由于 Apple 不希望开发者绕过 App Store 来更新 app，因此只有对于不需要上架的应用，才能以 framework 的方式实现 app 的更新。</p><p>使用framework实现动态更新常用用到的一些函数如下：</p><ul><li><p>dlfcn.h中的的方法：用于处理动态库的装载、卸载。</p><ul><li>dlopen打开动态链接库；</li><li>dlerror返回错误；</li><li>dlsym获取函数名或者变量名；</li><li>dlclose关闭动态库；</li></ul></li><li><p>Objective-C的方法： 用于动态库中对象的具体使用。</p><ul><li>NSClassFromString根据名字返回类；</li><li>NSSelectorFromString根据名字返回方法；</li><li>performSelector执行方法；</li></ul></li></ul><p>注意：<strong>没有在在Linked的设置里面设置的动态库，通过dlopen的形式来打开。如果动态库在Link Framwokrs and Libraries中设置了会在应用启动的时候就会被加载。</strong></p><p>在使用动态库对象的时候必须使用NSClassFromString的方式，使用常见对象创建的方式是不可以的。在使用dlopen打开动态库的时候注意在build settings里面设置对应的路径，其中的@executable_path/表示可执行文件所在路径，即沙盒中的.app目录，注意不要漏掉最后的/。如果你将动态库放到了沙盒中的其他目录，只需要添加对应路径的依赖就可以了。</p><p><img src="https://upload-images.jianshu.io/upload_images/664334-202a85fa2e6eac8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>实例代码的代码如下：</p><p>打开动态库</p><pre class="line-numbers language-objective-c"><code class="language-objective-c">- (IBAction)onDlopenLoadAtPathAction1:(id)sender{    NSString *documentsPath = [NSString stringWithFormat:@"%@/Documents/Dylib.framework/Dylib",NSHomeDirectory()];    [self dlopenLoadDylibWithPath:documentsPath];}- (void)dlopenLoadDylibWithPath:(NSString *)path{    libHandle = NULL;    libHandle = dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW);    if (libHandle == NULL) {        char *error = dlerror();        NSLog(@"dlopen error: %s", error);    } else {        NSLog(@"dlopen load framework success.");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用动态库中的内容</p><pre class="line-numbers language-objective-c"><code class="language-objective-c">- (IBAction)onTriggerButtonAction:(id)sender{    Class rootClass = NSClassFromString(@"Person");    if (rootClass) {        id object = [[rootClass alloc] init];        [(Person *)object run];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">编译器的工作过程</a><br><a href="https://www.objccn.io/issue-6-2/" target="_blank" rel="noopener">编译器</a><br><a href="https://www.objccn.io/issue-6-3/" target="_blank" rel="noopener">Mach-O 可执行文件</a><br><a href="https://segmentfault.com/a/1190000005988462" target="_blank" rel="noopener">Linux下的静态库、动态库和动态加载库</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>挺实用的Tips</title>
      <link href="/2018/02/19/2018/2/%E6%8C%BA%E5%AE%9E%E7%94%A8%E7%9A%84Tips/"/>
      <url>/2018/02/19/2018/2/%E6%8C%BA%E5%AE%9E%E7%94%A8%E7%9A%84Tips/</url>
      
        <content type="html"><![CDATA[<p>这里总结一下平时实践出来的的Tips，不能保证成为IT大牛，但能保证成为一个优秀的程序员。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>只要被产品经理坑过的，已经对这个深恶痛绝。</p><ul><li><strong>多花点时间沟通清楚需求，才能把握正确方向！</strong></li><li><strong>修复需求错误的成本是代码错误的几十倍！</strong>：</li></ul><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>是IT农民工还是正常程序员，习惯就是差距。</p><ul><li><strong>想清楚，写清楚，说清楚，才是真正的清楚！</strong></li><li>程序员最大的坏习惯就是：急于动手写代码！</li><li>写代码之前三件事：<ul><li>弄清楚做什么！</li><li>想清楚怎么测！</li><li>说清楚怎么做！</li></ul></li><li>提高开发效率的捷径：一次做对，不返工！</li><li><strong>每日构建，每日确认，尽早发现错误，尽早返工！</strong></li><li><strong>职业的程序员设计程序，业余的程序员调试程序</strong>；</li><li>职业的程序员是预防BUG，业余程序员是修改BUG；</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>小细节，大未来。</p><ul><li>拷贝粘贴式的作业方式，最容易导入bug，最难调试！</li><li><strong>重复代码是万恶之源！</strong></li><li><strong>小函数，小方法，以功能命名，可以消除注释！</strong></li><li><strong>做一点，测一点，测试驱动的开发，返工最少，返工最易；</strong></li><li>一个方法的复杂度应该小于10，否则很难调试它！</li><li><strong>随时重构代码，不遗留垃圾代码!</strong></li><li>消除静态检查的warning和error！</li></ul><h2 id="心法"><a href="#心法" class="headerlink" title="心法"></a>心法</h2><p>要练就上层武功，必须懂心法。</p><ul><li>经常总结自己的经验教训，写下来！汇总在一起！</li><li>任何复杂的问题都可以简化，两种简化的手段： 按时序拆分，按整体部分拆分；</li></ul>]]></content>
      
      
      <categories>
          
          <category> tip </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS Push的前世今生</title>
      <link href="/2018/02/12/2018/2/iOS%E6%8E%A8%E9%80%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2018/02/12/2018/2/iOS%E6%8E%A8%E9%80%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>网上介绍iOS Push的文章有很多，但是大部分都总结得非常零散，加上之前也一直没好好总结过，对某些地方也不求甚解。于是抽空把苹果这套复杂而有趣的推送机制总结了一遍，终有此文！</p><a id="more"></a><blockquote><p>注意：本文大部分内容基于iOS10新增通知框架UserNotifications。</p></blockquote><h1 id="全文导图"><a href="#全文导图" class="headerlink" title="全文导图"></a>全文导图</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-658360562d3b691e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="对Push的理解"><a href="#对Push的理解" class="headerlink" title="对Push的理解"></a>对Push的理解</h1><blockquote><p>苹果对Push的所有优化最终目的都是为了<strong>提升用户体验</strong>。这一点上不得不佩服Apple！</p></blockquote><p>在讲Push之前先谈谈为什么需要推送。对用户而言大部分就是为了获得最新的信息，感兴趣的资讯；对app开发者而言大部分是为了通过推送让用户打开app增加日活（别喷我），其次是为了向用户提供更好的资讯；对苹果而言因为iOS系统给app在后台最多存活的时间最多三分钟（后来新增后台模式后增加到十分钟），为了保证这个iOS平台能够给用户良好的体验（对推送可控），app可以主动和用户沟通。</p><h2 id="对APNS（Remote-Push）的理解"><a href="#对APNS（Remote-Push）的理解" class="headerlink" title="对APNS（Remote Push）的理解"></a>对APNS（Remote Push）的理解</h2><p>可以通俗的把APNS理解为iOS系统为每个app提供的长连接通道。只是这个通道需要通过苹果中转，为什么苹果要设计这么一套服务呢。上面也提到了过，下面在针对用户体验详细一点介绍。</p><ol><li><strong>提升用户体验</strong>：苹果限制了每个app在后台存活的时间，最重要的目的是为了省电，其次优化内存这些。<strong>如果彻彻底底的将app杀死了，服务端永远不能主动和客户端建立联系。所以需要一种机制来保证在必要的时候让用户知道服务端所做的改变。技术上只要只有长连接可以做到。</strong></li><li><strong>便于苹果、用户控制</strong>：如果直接让app和服务端建立长连接（比如iOS8之前的voip，就是app在后台保持长连接），苹果是不能控制的。所以通过在app和服务端中间加一个APNS可以有效的进行拦截处理。比如可以由用户开启是否接受远程推送。退一万步讲，如果哪天苹果对你上架的app进行了下架处理。即使有用户安装了你的app，切掉你的APNS，用户也无法收到推送，除非用户自己点开app否则你的app永远不会存活。</li></ol><p>APNS缺点也很明显</p><ol><li>可靠性、稳定性。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。<strong>不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。</strong>而且这最后一条离线push也是有<strong>过期时间</strong>的。一些用户应该有过这种经历，在使用某些的时候，明明对方发送了多条消息，却只收到了一条push。 </li><li>消息大小限制：由于苹果APNS服务于以万计的app，所以对消息内容大小有严格限制。只能传递一些文本信息。Apple在文档里清楚的说明，<strong>push只应该用来通知用户有新的内容，而不应该用来承载内容本身</strong>。理论上payload size越小，push到达设备的概率就越高。苹果一直在改善，在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到的iOS9发布，引入了HTTP2.0，payload size又被设为4KB（4 * 1024字节）了。</li></ol><h2 id="对Local-Push的理解"><a href="#对Local-Push的理解" class="headerlink" title="对Local Push的理解"></a>对Local Push的理解</h2><p>有了APNS（Remote Push）为什么苹果还搞了一套Local Push呢。从笔者的角度能做出如下猜测:</p><ol><li>苹果开发者中，有很大一部分是个人开发者。对于个人开发者而言，做一款小型的app，很多时候用APNS需要搭建服务，成本太高。</li><li>APNS前提条件是必须在联网的状态下，这样一些不需要联网的app，比如日程提醒类，就和Push彻底告别了。但是对于这种小型app，Local Push非常适合。</li><li>APNS稳定性及成功率并不是那么高。大型app可以采用两种渠道提高通知用户的成功率。比如后面会讲到的voip Push的使用一般就是结合local Push使用。</li><li>Local Push比APNS更加灵活。参数更加多样。</li><li>……</li></ol><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>因为app不总是会运行的，Local Push提供了另一种提醒用户信息的方式。比如应用在后台没有被杀死的时候，从服务端拉取数据更新，本地就可以根据服务端返回的信息，删选出是否有用户感兴趣的部分，然后组织好消息，通过本地推送告诉用户。当然也可以用远程push。但是这个时候远程push并没有本地push可靠。</p><p>Remote Push一般在应用杀死的情况下才使用。用户主动去打开app，之后请求数据。</p><blockquote><p>简单总结一下，如果能够直接拿到数据最好用本地push，如果拿不到，比如说应用被杀死采用远程push。</p></blockquote><p>从用户角度，这两种Push没有任何区别，具体来讲我们可以控制Push的如下形式：</p><ol><li>显示提示框还是横幅</li><li>app icon上显示的数字</li><li>显示横幅、数字、提示框所用的提示音</li></ol><ul><li>特别需要注意的几点：</li></ul><ol><li>App在前台运行的时候，通知不会展示出来（**在iOS10之后可以在userNotificationCenter:willPresentNotification:<pre><code> withCompletionHandler:进行处理，满足可以在前台显示通知**）</code></pre></li><li>点击通知，默认会自动打开推送通知的App </li><li>不管App是否打开，通知都可以发出 </li><li>可以取消本地push</li><li>可以设定本地push的自定义处理action（控制点击Push是否打开App）</li></ol><p>上面这几点注意事项可以在在UILocalNotification Class Reference找到（最好的资料还是官方文档）</p><h1 id="本地推送（Local-Push）"><a href="#本地推送（Local-Push）" class="headerlink" title="本地推送（Local Push）"></a>本地推送（Local Push）</h1><p>Local Push是不需要走APNS，让客户端更加灵活的控制。常见的比如一款闹钟App。app本地处理好推送逻辑，然后把推送逻辑交给系统。即使当app不在前台的时候也可以由系统发出通知告知用户。</p><p>App在启动的时候就需要对本地和远程推送进行设置，也就是不能晚于application:didFinishLaunchingWithOptions:调用。官方文档上说其实也可以，只要在处理只通知之前配置过就行。</p><h2 id="配置推送"><a href="#配置推送" class="headerlink" title="配置推送"></a>配置推送</h2><p>使用Push第一步需要向用户申请权限</p><p>iOS10之后直接用下面这代码</p><pre><code>UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];[center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert + UNAuthorizationOptionSound)   completionHandler:^(BOOL granted, NSError * _Nullable error) {      // Enable or disable features based on authorization.}];</code></pre><blockquote><p>注意：因为系统会保存用户的授权状态，所以下次启动的时候虽然调用了这代码，依然不会再次提示用户。</p></blockquote><h2 id="通知类别和通知Action"><a href="#通知类别和通知Action" class="headerlink" title="通知类别和通知Action"></a>通知类别和通知Action</h2><p><strong>通知类别：类别定义了app是如何展示通知的。将类别和自定义的action关联起来，并且设置具体的选项（option）。让推送更加灵活</strong></p><p>Action（UNNotificationAction）具体来讲长什么样：一般推送就一个横幅，下面没有按钮。Action其实就是横幅下面的按钮。截图如下<br><img src="http://upload-images.jianshu.io/upload_images/664334-aff902669726c05d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Actionable notifications的界面提供了用户可以点击的按钮，Actionable notifications让用户可以快速的执行相关的操作，不用强迫用户打开你的app(通过option设置是否打开app)。当用户点击的时候，会把相关的事件立即转发到app中处理。</p><p>在启动的时候。app可以注册一个或多个的通知类别，这些类别决定了app会发出哪中类型的通知。 通过设置UNNotificationCategoryOptions决定。</p><p>总的来讲这里有如下几个重要的类：</p><ol><li>UNUserNotificationCenter ：iOS10之后新增加的通知框架中。可以简单理解为这就是一个单例的Service。基本所有的通知设置都是通过去设置的。<strong>设置通知的入口 Manages the notification-related activities for your app or app extension.</strong>大致来讲有如下几个作用：<ul><li>请求通知权限</li><li>声明app支持的通知类型及自定义action。</li><li>安排发出通知</li><li>管理在通知中心显示的具体通知。</li><li>获取通知相关的设置</li></ul></li><li>UNNotificationCategory :设置类别的名称和各个可选项。类别的名称就是这个通知的唯一标识，系统会用来查找和显示相关通知。<strong>Defines the types of notifications your app supports and the custom actions displayed for each type.</strong></li><li>UNNotificationAction：定义响应通知的具体任务。比如设置当点击action的时候是否打开app，处理通知是否在非锁屏状态。<strong>Defines a task to perform in response to a delivered notification.</strong></li></ol><h3 id="创建及注册类别"><a href="#创建及注册类别" class="headerlink" title="创建及注册类别"></a>创建及注册类别</h3><p>前面提到过每个通知类别可以包含最多四个自定义action。如果类别包含了自定义的action，系统会在通知界面上添加按钮，每个都会以设置的action的title为按钮的title。如果用户点击了其中任何一个action。系统将会发送相关的action标识给app，app可以使用这个标识来标识后面执行的任务。</p><pre><code>// Create the custom actions for expired timer notifications.UNNotificationAction* snoozeAction = [UNNotificationAction      actionWithIdentifier:@&quot;SNOOZE_ACTION&quot;      title:@&quot;Snooze&quot;      options:UNNotificationActionOptionNone];UNNotificationAction* stopAction = [UNNotificationAction      actionWithIdentifier:@&quot;STOP_ACTION&quot;      title:@&quot;Stop&quot;      options:UNNotificationActionOptionForeground];// Create the category with the custom actions.UNNotificationCategory* expiredCategory = [UNNotificationCategory      categoryWithIdentifier:@&quot;TIMER_EXPIRED&quot;      actions:@[snoozeAction, stopAction]      intentIdentifiers:@[]      options:UNNotificationCategoryOptionNone];// Register the notification categories.UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];[center setNotificationCategories:[NSSet setWithObjects:generalCategory, expiredCategory,      nil]];</code></pre><blockquote><p>有时候虽然为类别设置了四个action，但是系统在某些环境下只有显示前两个。比如系统会在以横幅显示通知的时候只会显示前两个action。所以初始化action的时候，最好把优先级高的设置在前面。如果使用UNTextInputNotificationAction , 系统会提供用户一个输入框最为这个通知的响应。文本输入框这种通知响应方式对IM相关的app非常有用。截图如下：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/664334-e01a4a74eae2a90b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="配置推送的声音"><a href="#配置推送的声音" class="headerlink" title="配置推送的声音"></a>配置推送的声音</h3><p>本地推送和远程推送可以自定义提示音。因为是通过系统声音渠道播放的，所以自定义声音必须遵循如下几种数据格式：</p><ul><li>Linear PCM</li><li>MA4 (IMA/ADPCM)</li><li>µLaw</li><li>aLaw</li></ul><p>具体来讲：声音文件可以放到app bundle里面，或者如果是从网上下载的话就放在你pp沙盒目录下的Library/Sounds。自定义声音必须少于30秒。如果大于30秒将会用默认的系统的提示音取代。</p><h3 id="需要注意的几点"><a href="#需要注意的几点" class="headerlink" title="需要注意的几点"></a>需要注意的几点</h3><ul><li>通知类别UNNotificationCategoryOptions参数含义。</li></ul><pre><code>typedef NS_OPTIONS(NSUInteger, UNNotificationCategoryOptions) {    // 用户点击系统取消Action是否响应到通知代理    UNNotificationCategoryOptionCustomDismissAction = (1 &lt;&lt; 0),    // 通知在CarPlay(CarPlay 是美国苹果公司发布的车载系统)    UNNotificationCategoryOptionAllowInCarPlay = (1 &lt;&lt; 1),    // 通知预览关闭情况下是否显示通知的title    UNNotificationCategoryOptionHiddenPreviewsShowTitle __IOS_AVAILABLE(11.0) __WATCHOS_PROHIBITED = (1 &lt;&lt; 2),    // 通知预览关闭情况下是否显示通知的子title    UNNotificationCategoryOptionHiddenPreviewsShowSubtitle __IOS_AVAILABLE(11.0) __WATCHOS_PROHIBITED  = (1 &lt;&lt; 3),}</code></pre><p>这里简单说一下什么是通知预览。在设置里面<br><img src="http://upload-images.jianshu.io/upload_images/664334-c1237349d8787c7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>关闭之后设置UNNotificationCategoryOptions为UNNotificationCategoryOptionHiddenPreviewsShowTitle | UNNotificationCategoryOptionHiddenPreviewsShowSubtitle。效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-58811f0296e37a66.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>显示的内容就用数字代替了。</p><ul><li>通知Action参数UNNotificationActionOptions含义</li></ul><pre><code>typedef NS_OPTIONS(NSUInteger, UNNotificationActionOptions) {    //执行代理是否需要在非锁屏状态下    UNNotificationActionOptionAuthenticationRequired = (1 &lt;&lt; 0),    //决定按钮显示是否为红色。（红色代表消极？）    UNNotificationActionOptionDestructive = (1 &lt;&lt; 1),    //决定点击action是否打开app    UNNotificationActionOptionForeground = (1 &lt;&lt; 2),} </code></pre><p>特别注意当设置为UNNotificationActionOptionAuthenticationRequired的时候，即使点击了action代理方法userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler也不会走。如果设置为UNNotificationActionOptionNone。则即使在锁屏情况下也会走代理方法</p><h2 id="创建本地推送"><a href="#创建本地推送" class="headerlink" title="创建本地推送"></a>创建本地推送</h2><p>在app运行的时候（无论是前台还是后台），设置好本地推送，然后系统会在合适的时间发出推送。</p><ul><li>如果app没有在运行或者在后台，系统将直接向用户展示通知，<strong>如果app提供了app通知扩展，系统使用用户自定义的界面提示用户</strong>。</li><li>如果app在前台，系统会给app<strong>在内部处理通知的机会</strong>。</li></ul><p>前面讲过配置本地推送，总结一下有如下几个步骤：</p><ol><li><strong>设置内容</strong>：创建并设置好UNMutableNotificationContent。</li><li><strong>设置触发器</strong>：创建通知触发器UNCalendarNotificationTrigger, UNTimeIntervalNotificationTrigger, UNLocationNotificationTrigger其中一种。设置好触发通知的条件。</li><li><strong>连接内容和触发器</strong>：创建UNNotificationRequest ，设置content和trigger。</li><li><strong>添加通知</strong>：调用`addNotificationRequest:withCompletionHandler:计划通知。</li></ol><pre><code> UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];    content.title = [NSString localizedUserNotificationStringForKey:@&quot;Wake up!&quot; arguments:nil];    content.body = [NSString localizedUserNotificationStringForKey:@&quot;Rise and shine! It&#39;s morning time!&quot;                                                         arguments:nil];NSDateComponents* date = [[NSDateComponents alloc] init];    date.second = 10;    UNCalendarNotificationTrigger* trigger = [UNCalendarNotificationTrigger                                              triggerWithDateMatchingComponents:date repeats:NO];    // Create the request object.    UNNotificationRequest* request = [UNNotificationRequest                                      requestWithIdentifier:@&quot;MorningAlarm&quot; content:content trigger:trigger];</code></pre><p>这里提供的唯一标识是为了后面查找或者取消通知。</p><p>前面提到的通知类别，这个时候就可以排上用场了。在<code>UNMutableNotificationContent</code>设置好之前已经注册了的通知类别categoryIdentifier。注意必须在安排全这个通知请求之前就设置好这个值。</p><pre><code>UNNotificationContent *content = [[UNNotificationContent alloc] init];// Configure the content. . .// Assign the category (and the associated actions).content.categoryIdentifier = @&quot;TIMER_EXPIRED&quot;;</code></pre><p>前面提到过可以自定义通知的声音。这里同样是在<code>UNMutableNotificationContent</code>对象上设置。使用<code>UNNotificationSound</code>对象，这个对象决定是使用自定义的声音还是系统默认声音。<strong>注意自定义的音频文件必须在设备上存在。</strong>存储在app的main bundle里面，或者下载并存储到app沙盒路径下得Library/Sounds子目录。</p><pre><code>content.sound = [UNNotificationSound soundNamed:@&quot;MySound.aiff&quot;];</code></pre><p>发出或者安排通知：系统是异步的安排本地通知。当安排完成或者出错之后通过回调block告知。</p><pre><code>// Create the request object.UNNotificationRequest* request = [UNNotificationRequest       requestWithIdentifier:@&quot;MorningAlarm&quot; content:content trigger:trigger];UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {   if (error != nil) {       NSLog(@&quot;%@&quot;, error.localizedDescription);   }}];</code></pre><p>安排过的通知会一直存活到系统取消或者app处理过。当通知发出过了系统会自己取消掉通知，除非这个通知设定为重复通知。取消通知可以通过<code>removePendingNotificationRequestsWithIdentifiers:</code>实现。上面提到过，取消是通过之前设置的标识取消的。</p><p>为了响应用户对通知的处理。需要实现那UNUserNotificationCenter的代理UNUserNotificationCenterDelegate。当自定义了action的时候代理必须实现。</p><pre><code>// The method will be called on the delegate only if the application is in the foreground. If the method is not implemented or the handler is not called in a timely manner then the notification will not be presented. The application can choose to have the notification presented as a sound, badge, alert and/or in the notification list. This decision should be based on whether the information in the notification is otherwise visible to the user.- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);// The method will be called on the delegate when the user responded to the notification by opening the application, dismissing the notification or choosing a UNNotificationAction. The delegate must be set before the application returns from application:didFinishLaunchingWithOptions:.- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)(void))completionHandler __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0) __TVOS_PROHIBITED;</code></pre><p>以下几点值得注意下：</p><ol><li>当app在前台的时候，app可以静音掉通知（也就是不处理）或者告诉系统自己展示其他页面。<strong>再次提醒，系统会默认静音掉所有通知当app在前台的时候。</strong>系统或直接把通知给app，让app自己使用通知传递的数据去做app自定义的任务。<strong>如果该需要系统继续显示通知界面，需要为UNUserNotificationCenter提供一个代理对象，实现userNotificationCenter:willPresentNotification:withCompletionHandler: 方法，在这个方法里面应该处理通知数据。完成之后，执行app想让系统去使用的通知发出选项。如果不做任何配置，系统将会静音掉这个通知。</strong></li><li>当app在后台或者已经停止运行。系统不会调用userNotificationCenter:willPresentNotification:withCompletionHandler:，在这种情况下，系统会自己提示用户根据通知的设置。app可以使用getDeliveredNotificationsWithCompletionHandler: 来查看已经发送过得通知。</li><li>当用户通过界面选择了自定义的action，系统将会通知app，用户当前所做的选择。同样是通过代理告诉app。在代理userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: 必须实现那能够处理所有自定义的action。app如果没有运行，而用户点击了action。系统将会以后台模式打开app用于处理用户的选择。<strong>千万不要在这段时间处理一些无关的任务。</strong></li></ol><p>除了自定义的，还有系统的action。用户可能没有选择自定义的action而是取消掉通知页面或者打开app。和自定义action一样，系统的action也有对应的唯一标识：</p><ul><li>UNNotificationDismissActionIdentifier ：用户没有选择action，直接取消了通知界面</li><li>UNNotificationDefaultActionIdentifier ：用户没有选择action，直接打开了app</li></ul><pre><code>    // The user dismissed the notification without taking action.    }    else if ([response.actionIdentifier isEqualToString:UNNotificationDefaultActionIdentifier]) {        // The user launched the app.    }    if ([response.notification.request.content.categoryIdentifier isEqualToString:@&quot;TIMER_EXPIRED&quot;]) {        // Handle the actions for the expired timer.        if ([response.actionIdentifier isEqualToString:@&quot;SNOOZE_ACTION&quot;])        {            // Invalidate the old timer and create a new one. . .        }        else if ([response.actionIdentifier isEqualToString:@&quot;STOP_ACTION&quot;])        {            // Invalidate the timer. . .        }    }</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>（针对本地推送）应用在前台并不是不能弹出系统通知框。上面提到如果该需要系统继续显示通知界面，需要为UNUserNotificationCenter提供一个代理对象，实现userNotificationCenter:willPresentNotification:withCompletionHandler: 方法，在这个方法里面应该处理通知数据。完成之后，执行app想让系统去使用的通知发出选项。如果不做任何配置，系统将会静音掉这个通知。</p><p>```</p></li><li><p>(void)userNotificationCenter:(UNUserNotificationCenter *)center</p><pre><code>willPresentNotification:(UNNotification *)notification  withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler{</code></pre><p>  //1. 处理通知</p><p>  //2. 处理完成后条用 completionHandler ，用于指示在前台显示通知的形式<br>  completionHandler(UNNotificationPresentationOptionAlert);<br>}<br>```</p></li><li><p>UNNotificationTrigger：系统提供了基于时间和基于地理位置的Trigger。<strong>如果想设置为时间Trigger为Repeat，至少需要60s</strong>，如果用UNCalendarNotificationTrigger，虽然可以设置小于60s的时间间隔但是并不是按照设置的时间执行</p></li><li><p>重复的通知只会在通知栏显示一个</p></li></ul><h1 id="远程推送（Remote-Push）"><a href="#远程推送（Remote-Push）" class="headerlink" title="远程推送（Remote Push）"></a>远程推送（Remote Push）</h1><p>远程推送稍微大点的app都有有这功能。为了接受远程推送需要有如下几步：</p><ol><li>开启远程推送</li><li>注册APNS服务，接收苹果返回的device token</li><li>把收到的device token发送给服务端</li><li>处理接收到的远程推送</li></ol><h2 id="配置推送-1"><a href="#配置推送-1" class="headerlink" title="配置推送"></a>配置推送</h2><p>开启远程推送直接可以在xcode中操作。之前需要申请推送证书。如果没有必须得entitlements，那么app在被app store审核的时候会被拒。</p><p>每一次app启动，都会在APNS注册。大致流程如下：</p><ol><li>app请求APNS注册</li><li>注册成功之后，APNS会把对应的token返回给app</li><li>系统通过代理告诉app接收到的token</li><li>app把这个token发送给服务端。</li></ol><blockquote><p>token其实就是当前这个app在APNS中的唯一标识。服务端拿着这个token，向APNS服务发送推送请求</p></blockquote><p>绝对不要在app里面缓存token，应该直接从系统获取。在某些情况下APNS为了保证token的唯一性会更新app的token。比如用户从备份中恢复系统、用户在全新的设备上安装了app，用户重新安装了操作系统。<strong>当token在APNS没有改变的时候，去获取，APNS会快速的返回（也就是APNS或者系统其实做了缓存的，只是不要在app内部去做缓存）。</strong></p><p>调用registerForRemoteNotifications注册APNS。在app启动的时候都会调用这个方法。系统会异步的回调回来。</p><blockquote><p>Token长度是不确定的，所以不要写死token的长度。在注册成功之后，只要当token改变之后才APP才和APNS再次交互。否则调用registerForRemoteNotifications的时候，application:didRegisterForRemoteNotificationsWithDeviceToken: 会立即返回已经存在的token。</p></blockquote><p>如果token在app运行的时候 改变。app会直接调用application:didRegisterForRemoteNotificationsWithDeviceToken:。</p><pre><code>- (void)applicationDidFinishLaunching:(UIApplication *)app {    // Configure the user interactions first.    [self configureUserInteractions];   // Register for remote notifications.    [[UIApplication sharedApplication] registerForRemoteNotifications];}// Handle remote notification registration.- (void)application:(UIApplication *)app        didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)devToken {    // Forward the token to your provider, using a custom method.    [self enableRemoteNotificationFeatures];    [self forwardTokenToServer:devTokenBytes];}- (void)application:(UIApplication *)app        didFailToRegisterForRemoteNotificationsWithError:(NSError *)err {    // The token is not currently available.    NSLog(@&quot;Remote notification support is unavailable due to error: %@&quot;, err);    [self disableRemoteNotificationFeatures];}</code></pre><h2 id="修改系统推送的展示方式"><a href="#修改系统推送的展示方式" class="headerlink" title="修改系统推送的展示方式"></a>修改系统推送的展示方式</h2><p>iOS10之后可以通过 notification service app extension 修改通知的展现方式。（原理就是在之前推送的基础上增加一层notification service app extension ，用于过滤服务端推送过来的数据，根据数据进行自定义）</p><p>分如下几个步骤：</p><ol><li>解密从服务端传过来的加密数据</li><li>下载多媒体资源，并且作为通知附件</li><li>改变通知的title和文本</li><li>增加线程标识用于修改通知的userinfo参数</li></ol><p>如何实现那notification service app extension网上很多，这里不累赘了。可以看看<a href="http://www.cocoachina.com/ios/20161017/17769.html" target="_blank" rel="noopener">iOS10推送必看UNNotificationServiceExtension</a></p><p>一张图解释<br><img src="http://upload-images.jianshu.io/upload_images/664334-b8810d02f36b2f9f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>同宿主target一样， app extension的target也需要在 notification service app extension的target中打开推送的capability才能正常收到推送。</strong></li></ol><p>该特性是在iOS7添加的，一句话来讲就是：应用在后台收到通知后能够运行一段代码，可用于从服务器获取内容更新。</p><p>静默推送和一般推送的区别：<br>iOS7之前<br><img src="http://upload-images.jianshu.io/upload_images/664334-eff9ed1c9490990c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>iOS7之后<br><img src="http://upload-images.jianshu.io/upload_images/664334-e3a18c289ccbf549.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>如果只携带content-available: 1 不携带任何badge，sound 和消息内容等参数，则可以不打扰用户的情况下进行内容更新等操作即为“Silent Remote Notifications”</p></blockquote><p>具体设置如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-53df5b55ec1bca54.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当启用Backgroud Modes -&gt; Remote notifications 后，notification 处理函数一律切换到下面函数，后台推送代码也在此函数中调用</p><pre><code>/*! This delegate method offers an opportunity for applications with the &quot;remote-notification&quot; background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you&#39;re finished performing that operation, so the system can accurately estimate its power and data cost. This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler NS_AVAILABLE_IOS(7_0);</code></pre><p>这里提到了application:didReceiveRemoteNotification，看了一下还有这些知识点。</p><pre><code>- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo NS_DEPRECATED_IOS(3_0, 10_0, &quot;Use UserNotifications Framework&#39;s -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:] for user visible notifications and -[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:] for silent remote notifications&quot;);</code></pre><p>一定要注意这几个方法是属于不同类的</p><ul><li>application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler ：是属于AppDelegate，用于静默推送，用户不可见。</li><li>其余两个是是属于UNUserNotificationCenter，用于用户可见的推送，比如有提示横幅。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>Silent Remote Notifications是在 Apple 的限制下有一定的频率控制，但具体频率不详。所以并不是所有的 “Silent Remote Notifications” 都能按照预期到达客户端触发函数。</p></li><li><p>Background下提供给应用的运行时间窗是有限制的，如果需要下载较大的文件请参考 Apple 的 NSURLSession 的介绍。</p></li><li><p>Background  Remote Notification 的前提是要求客户端处于Background 或 Suspended 状态，<strong>如果用户通过 App Switcher 将应用从后台 Kill 掉应用将不会唤醒应用处理 background 代码。</strong>（这一点通过voip Push可以实现）</p></li><li><p>静默推送格式：</p><ul><li>增加content-available字段，并设成1</li><li>alert字段必须为空，否则收到的就不是静默推送</li><li>sound字段设不设不影响静默推送的接收。</li><li>badge字段设不设不影响静默推送的接收。<br><img src="http://upload-images.jianshu.io/upload_images/664334-1a44b8bcef171db3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li><li><p>再次强调：<strong>静默推送只能在应用在前台和应用在后台挂起时收到，也就是说，如果应用未启动或进程被杀掉，静默推送是唤醒不了设备的。</strong></p></li><li><p>推送回调方法</p><ul><li>willPresentNotification:withCompletionHandler 用于前台运行</li><li>didReceiveNotificationResponse:withCompletionHandler 用于后台及程序退出</li><li>didReceiveRemoteNotification:fetchCompletionHandler用于静默推送</li><li>(void)application:(UIApplication *)application didReceiveRemoteNotification（会处理所有推送，iOS10之前）</li></ul></li></ul><h1 id="Voip推送（Voip-Push）"><a href="#Voip推送（Voip-Push）" class="headerlink" title="Voip推送（Voip Push）"></a>Voip推送（Voip Push）</h1><p>Voip Push相对于Silent Push又更近一步。解决了Silent Push使用场景必须是app必须存活的问题。Voip Push可以在应用被杀死的情况下，也可以唤醒app。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>苹果在iOS8引入PushKit framework，app可以通过远程推送就可以唤醒，不过这个特性只有在voip类应用起作用。在之前voip类app需要在后台保持长连接，才能实时收到voip，这样非常耗电，于是在iOS8之后引入了Push Kit解决这个问题。</p><p>之前有人分析过what’s up 在iOS8之后的变化，原文入下：</p><blockquote><p>每次用户有新的<strong>离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。</strong>等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。</p></blockquote><p>voip 推送和传统的推送的区别如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-58dfeafd2aa8a692.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>通过上图可以知道voip push有着自己完整的一套逻辑，与此同时同样需要申请相关证书。可以把voip push 、 远程push 与本地 push三者视为同一级别。</p><p>下图是voip push 对应的证书<br><img src="http://upload-images.jianshu.io/upload_images/664334-13490c954498e513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>代码来讲实现下面两个代理就行了</p><pre><code>- (void)pushRegistry:(PKPushRegistry *)registry didUpdatePushCredentials:(PKPushCredentials *)pushCredentials forType:(PKPushType)type {    NSData *voipToken = pushCredentials.token;    NSLog(@&quot;voip token:%@&quot;, voipToken);}- (void)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(NSString *)type {    //用户处理    // 呼出系统接听界面    // 或者生成本地推送}</code></pre><h2 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>voip Push和remote Push 在token获取、服务端交互是大致相同的。</li><li>voip Push和silent Push最大的不同在于，silent Push必须是app没有被杀死才能在后台唤醒应用，而voip Push是可以在app杀死之后，唤醒应用。</li><li>voip Push一般使用方式是<ul><li>服务端发出推送，app收到推送</li><li>app解析数据，根据数据先处理好业务逻辑。比如更新数据</li><li>通过本地推送告诉用户</li><li>用户打开app，显示之前已经处理好的内容</li></ul></li></ul><h1 id="苹果-Push的优化记录"><a href="#苹果-Push的优化记录" class="headerlink" title="苹果 Push的优化记录"></a>苹果 Push的优化记录</h1><p>去了解一项技术的进化史，最好的方式就是去看官方的文档更新记录。<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/RevisionHistory.html#//apple_ref/doc/uid/TP40008194-CH99-SW1" target="_blank" rel="noopener">苹果 Push的优化记录</a>可以看到苹果本地推送和远程推送文档更新记录。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>花了将近两天的时间总结Push这块知识。过程中甚至感受到了苹果为提升用户体验而做的努力。从最开始的只要应用不在前台就无法唤醒的普通Push，到iOS7的新增的只能在后台唤醒app静默Push，再到后面iOS8新增的即使app没有运行也可以唤醒app的voip Push。Push技术的演变也是苹果对用户体验提升的见证。</p><p>回到作为技术人的角度，最近大半年都过得太过于浮躁。之前的炒得风风火火的数字货币，ICO项目等让自己太过于浮躁。直到前不久认识了一个技术大牛，才让自己认识到做技术还是需要沉淀，还是要形成知识体系，静下心来好好打磨。</p><p>内心激荡着那句对我说的话：“多看看计算机原理、底层相关的书。<strong>遇到问题多想几个为什么</strong>”。虽然这句话有装逼嫌疑，但是不得不说是走向技术大牛的最佳途径。</p><blockquote><p>最近打算出一系列关于计算机底层、原理的文章。敬请期待！！！！</p></blockquote><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://zeropush.com/guide/guide-to-pushkit-and-voip" target="_blank" rel="noopener">How to use PushKit for VoIP Push </a><br><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1" target="_blank" rel="noopener">Background Execution</a><br><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194-CH3-SW1" target="_blank" rel="noopener">Local and Remote Notification Programming Guide</a><br><a href="http://www.jb51.net/article/93464.htm" target="_blank" rel="noopener">iOS10最新实现远程通知的开发教程详解</a><br><a href="http://blog.csdn.net/jueyi1127/article/details/56012082" target="_blank" rel="noopener">iOS 静默推送实现（推送背景为个推）</a><br><a href="http://www.cocoachina.com/ios/20161017/17769.html" target="_blank" rel="noopener">iOS10推送必看UNNotificationServiceExtension</a><br><a href="http://blog.csdn.net/u012701023/article/details/53464876" target="_blank" rel="noopener">iOS开发-本地通知与远程通知</a><br><a href="http://mrpeak.cn/ios/2016/01/06/push" target="_blank" rel="noopener">iOS Push的门道</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Charles配合WireShark找到元凶</title>
      <link href="/2017/12/26/2017/12/%E7%94%A8Charles%E9%85%8D%E5%90%88WireShark%E6%89%BE%E5%88%B0%E5%85%83%E5%87%B6/"/>
      <url>/2017/12/26/2017/12/%E7%94%A8Charles%E9%85%8D%E5%90%88WireShark%E6%89%BE%E5%88%B0%E5%85%83%E5%87%B6/</url>
      
        <content type="html"><![CDATA[<p>最近感觉自己把做客户端，玩成了做服务端的感觉。凌晨一两点老大还在群里吼，整个人都不好，每天精神都很敏感。<strong>一次线上的重大bug，app瘫痪了一个小时，彻底让人怀疑人生。这都是钱呀！/(ㄒoㄒ)/~~</strong></p><a id="more"></a><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>大概晚上九点多，服务端上线了一套新的功能。因为一般情况下不会对客户端造成什么影响就没有经过QA。<strong>但一上线不久，iOS客户端线上的一打开闪退，根本无法用。大佬气得都快炸了，后经服务端代码回滚，还是一打开就闪退。</strong></p><blockquote><p>由于线上的app是经过<code>**</code>企业重签名的渠道，非AppStore渠道，所以客户端无法联机调试。</p></blockquote><p>现象很奇怪：</p><ul><li>如果断网情况下，可以进入app，过一段时间重新联网<strong>就可以正常使用</strong></li><li>服务端确实改了部分接口代码，但是已经回滚了，还是闪退。</li><li>之前上线AppStore的版本没有闪退 </li><li><strong>自己打的包根本就不会闪退，只有经过企业重签的才会闪退。</strong></li></ul><blockquote><p>最开始猜测跟服务端回滚不彻底导致的，可是从AppStore下载的是可以正常使用。自己打的包又没有出现崩溃的现象。<strong>根据app是在启动的时候就会崩溃，定位到是app请求全局配置的时候就崩溃了，连signup都没走到。</strong></p></blockquote><p>因为无法连接崩溃版本直接测试，于是想到通过抓包工具，抓取到底是哪个接口反馈的数据出现了问题。问题转移到抓包解析错误结果。</p><h1 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h1><p>首先用到了WireShark。一般使用Wireshark只能看到ip地址，但是看域名更方便更简明。想看域名需要简单去设置一下。<br><img src="http://upload-images.jianshu.io/upload_images/664334-55694be13a7b74bb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>抓到的数据如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-5e11c31f41dc7b52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>但是由于现在用的都是https，如果不解密根本看不了返回了什么内容。这他妈就尴尬了。</p><p>网上搜了一下究竟有什么办法可以让wireshark解密数据？大致可以通过下面几种方法来使wireshark能解密https数据包。</p><ol><li>中间人攻击;</li><li>设置web服务器使用RSA作为交换密钥算法;</li><li>如果是用chrome,firefox，可以设置导出pre-master-secret log，然后wireshark设置pre-master-secret log路径，这样就可以解密了。</li></ol><p>一看这种就得花大把时间去弄。<strong>于是转到了使用Charles抓包的思路上</strong></p><p>虽然Charles并没有WireShark那么牛逼，但是在客户端抓包分析方面确实比WireShark简单不少。</p><p>使用Charles抓包https几个需要注意的地方这里提示一下。</p><p>没正确设置的时候左边显示如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-449e8db0186fa5ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>设置正确之后：</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-089ef284e70e9ad6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>一、安装SSL证书到手机设备<br>点击 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device</p><p><strong>出现弹窗得到地址 chls.pro/ssl</strong></p><p>在手机Safari浏览器输入地址 chls.pro/ssl，出现证书安装页面，点击安装<br>手机设置有密码的输入密码进行安装</p><p>iOS 10.3之后系统，需要在 设置→通用→关于本机→证书信任设置 里面启用完全信任Charles证书</p><p>二、Charles设置Proxy<br>Proxy -&gt; SSL Proxying Settings…</p><p>勾选Enable SSL Proxying,点击Add</p><p>设置端口443</p><h1 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h1><p>通过分析请求的域名，对比发现自己打的包一起启动请求的数据和三个域名相关。而通过企业重签名的包和四个域名想。</p><p>自己打的包：<br><img src="http://upload-images.jianshu.io/upload_images/664334-421ca4b63416b456.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>企业重签名的包：<br><img src="http://upload-images.jianshu.io/upload_images/664334-3c6c3106ace1034f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>对比下来最终确定是企业重签名的包多了一个www.开头的请求。</p><blockquote><p>但是到这里还是无法保证就是这个请求这个域名导致的问题。<strong>接下来就是通过修改本地的host文件，把上面的几个域名重定向到本地127.0.01。一个一个去排查到底是哪个域名导致的。</strong></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/664334-4995dcbd9016cb48.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>通过更改本地Host，强制让请求这个域名的接口不返回数据。</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-7a0a5350c8604a83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>最终的确没有发现崩溃了。</p><blockquote><p>原因就是请求这个域名导致的。这个时候大家已经找大线索。顺藤摸瓜，肯定是重签名导致的，后来结果和对方沟通。是因为<strong>重签名在我们包里面加了一些hack代码，应该和注入dyld差不多，第一次感受到iOS还是要走正规渠道发布才行。</strong></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>市面上的重签名服务太不靠谱，莫名其妙给你插入一些不可靠的代码</li><li>控制变量法，😆在解决问题上还是很管用的</li><li>常见的抓包技巧以及host的这些还是要掌握。比如可以通过Charles设置代理，然后修改host，达到<strong>中间人攻击的效果，给客户端返回自定义的数据。</strong></li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://blog.csdn.net/linuxnews/article/details/51900900" target="_blank" rel="noopener">为什么Wireshark无法解密HTTPS数据</a><br><a href="https://jingyan.baidu.com/article/20b68a88b2af7f796cec62b3.html" target="_blank" rel="noopener">WireShark破解SSL加密网络数据包</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OC限制函数调用的频率</title>
      <link href="/2017/12/14/2017/12/OC%E9%99%90%E5%88%B6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E9%A2%91%E7%8E%87/"/>
      <url>/2017/12/14/2017/12/OC%E9%99%90%E5%88%B6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E9%A2%91%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>最近抽空闲的时间看了一些算法相关的，刷刷LeetCode。实在感觉脑子不好使。想到前段时间处理了一个挺好玩的问题——限制GCD调用的频率。后来扩展到了限制函数调用。这里顺便总结一下。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>为了达到限制调用频率的目的，很容易联想到throttle，也就是限流。最开始是从网络节流了解到这个基础名词的。<strong>简单来理解就是：对要处理的数据进行流量处理，限制频率。</strong>不是很清楚的可以看看这篇文章<a href="http://www.cocoachina.com/ios/20170105/18525.html" target="_blank" rel="noopener">iOS编程中throttle那些事</a></p><p>大致有三种：1、一定时间内，以最早的数据为准。2、一定时间内，以最后的数据为准。3、如果时间在一定时间内，有新的数据来了，从新开始计时。</p><p>一定时间内很简单的可以通过比较上次时间和当前时间来比较，剩下的就是如何取消之前已经产生的数据。这里有两个思路，一个是用最新的覆盖掉之前的数据，二是直接把老数据删掉，重新构造新的数据。</p><p>可能看起来不清楚，现在就用实际例子来说。</p><h1 id="GCD-Throttle"><a href="#GCD-Throttle" class="headerlink" title="GCD Throttle"></a>GCD Throttle</h1><p>需要用到的作料：dispatch_source_t，dispatch_queue_t，dispatch_source_set_timer<br>我们可以比较简单的通过dispatch_source_t来实现GCD的Throttle。得益于GCD提供了取消source的方法dispatch_source_cancel。</p><p>核心思路就是延迟特定时间调用一个任务，如果这段时间来新的任务了就取消掉之间的，如果时间到了就执行任务，需要创建一个对象、或者数组来保存之前的sourcer。代码很简单：</p><pre><code> dispatch_source_t source = scheduledSources[key];//如果有了就取消掉，达到忽略中间的，调用最新的if (source) {    dispatch_source_cancel(source);}dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);        dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, threshold * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 0);        dispatch_source_set_event_handler(source, ^{            block();            dispatch_source_cancel(source);            [scheduledSources removeObjectForKey:key];        });        dispatch_resume(source);</code></pre><blockquote><p>基本的思路就是这样。如果想要写得更加通用一些，就是把需要变化的参数化就可以了。</p></blockquote><h1 id="常规的消息发送Throttle"><a href="#常规的消息发送Throttle" class="headerlink" title="常规的消息发送Throttle"></a>常规的消息发送Throttle</h1><p>如果想解决常规发送消息进行Throttle。这个挺麻烦的。因为RuntTime没有直接提供取消方法执行方式。</p><p>这里有几个思路：</p><ol><li>因为上面已经实现了GCD Throttle调用，那么用GCD的方式把常规的方法调用包装一层就可以实现了。</li><li>利用Runtime消息转发，转发到自定义的方法进行延迟处理。具体逻辑可以看看</li></ol><blockquote><p>给类添加一个新的方法 fixed_selector，对应实现为 rule.selector 的 IMP。<br>利用 Objective-C runtime 消息转发机制，将 rule.selector 对应的 IMP 改成 _objc_msgForward 从而触发调用 forwardInvocation: 方法。<br>将 forwardInvocation: 的实现替换为自己实现的 IMP，并在自己实现的逻辑中将 invocation.selector 设为 fixed_selector。并限制 [invocation invoke] 的调用频率。</p></blockquote><p>这里有个非常不错的库，已经把这个功能实现。<a href="http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/" target="_blank" rel="noopener">Objective-C Message Throttle and Debounce</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归、递归的常见例子</title>
      <link href="/2017/12/09/2017/12/%E9%80%92%E5%BD%92%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BE%8B%E5%AD%90%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
      <url>/2017/12/09/2017/12/%E9%80%92%E5%BD%92%E3%80%81%E9%80%92%E5%BD%92%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BE%8B%E5%AD%90%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>算法是程序设计的灵魂。为了保持大脑不生锈，一般一两天就刷一刷算法题。这里简单总结下递归、及递归的常见问题。也当是小白教程吧！</p><a id="more"></a><blockquote><p>在开始讲递归之前，先了解下什么是函数调用栈、以及如何对递归最简单的理解</p></blockquote><h1 id="函数调用、理解递归"><a href="#函数调用、理解递归" class="headerlink" title="函数调用、理解递归"></a>函数调用、理解递归</h1><p>对于程序，编译器会对其分配一段内存，在逻辑上可以分为代码段，数据段，堆，栈。</p><ul><li>代码段：保存程序文本，<strong>指令指针EIP就是指向代码段</strong>，可读可执行不可写</li><li>数据段：保存初始化的全局变量和静态变量，可读可写不可执行</li><li>BSS：未初始化的全局变量和静态变量</li><li>堆(Heap)：动态分配内存，<strong>向地址增大的方向增长，可读可写可执行</strong></li><li>栈(Stack)：存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，非常非常重要，可读可写可执行</li></ul><p>来一张图：<br><img src="http://images.cnitblog.com/i/432341/201403/250854505149178.png" alt></p><p>上面这些对理解调用栈有什么用呢。其实想要彻底弄明白，还需要懂汇编才行。这里我们只需要知道栈会存放<code>局部变量，函数参数，当前状态，函数调用信息</code>对后面的理解就够了。</p><p>下面通过一个例子来理解递归调用的执行过程（Xcode）</p><pre><code>void up_and_down(int n){    printf(&quot;before: Level %d:n location %p\n&quot;,n,&amp;n); /* 1 */    if(n&lt;4)        up_and_down(n+1);    printf(&quot;after: Level %d:n location %p\n&quot;,n,&amp;n); /* 2 */}int main(int argc, const char * argv[]) {    @autoreleasepool {        up_and_down(1);    }    return 0;}</code></pre><p>执行结果</p><pre><code>before: Level 1:n location 0x7fff5fbff75cbefore: Level 2:n location 0x7fff5fbff73cbefore: Level 3:n location 0x7fff5fbff71cbefore: Level 4:n location 0x7fff5fbff6fcafter: Level 4:n location 0x7fff5fbff6fcafter: Level 3:n location 0x7fff5fbff71cafter: Level 2:n location 0x7fff5fbff73cafter: Level 1:n location 0x7fff5fbff75cProgram ended with exit code: 0</code></pre><p>分析过程：　<br>首先， main() 使用参数 1 调用了函数 up_and_down() ，于是 up_and_down() 中形式参数 n 的值是 1, 故打印语句 #1 输出了 Level1 。然后，由于 n 的数值小于 4 ，所以 up_and_down() （第 1 级）使用参数 n+1 即数值 2 调用了 up_and_down()( 第 2 级 ). 使得 n 在第 2级调用中被赋值 2, 打印语句 #1 输出的是 Level2 。与之类似，下面的两次调用分别打印出 Level3 和 Level4 。</p><p>当开始执行第 4 级调用时， n 的值是 4 ，因此 if 语句的条件不满足。这时候不再继续调用 up_and_down() 函数。第 4 级调用接着执行打印语句 <code>/* 2 */</code>，即输出 Level4 ，因为 n 的值是 4 。<strong>现在函数需要执行 return 语句，此时第 4 级调用结束，把控制权返回给该函数的调用函数，也就是第 3 级调用函数。第 3 级调用函数中前一个执行过的语句是在 if 语句中进行第 4 级调用。因此，它继续执行其后继代码，即执行打印语句 <code>/* 2 */</code>，这将会输出 Level3 ．</strong>当第 3 级调用结束后，第 2 级调用函数开始继续执行，即输出Level2 ．依次类推.</p><blockquote><p>注意，每一级的递归都使用它自己的私有的变量 n ．可以查看地址的值来证明。也就是栈保存了调用的参数。</p></blockquote><p>如果还没看懂，没关系，我再用一种最为简单的方式在解释一下。完全可以简单就是把递归函数一层一层展开。比如上面的例子，如果展开就可以写成下面这样</p><pre><code>void up_and_down_simple(int n){    printf(&quot;before: Level %d:n location %p\n&quot;,n,&amp;n); /* 1 */    if(n&lt;4)        up_and_down1(n+1);    printf(&quot;after: Level %d:n location %p\n&quot;,n,&amp;n); /* 2 */}void up_and_down1(int n){    printf(&quot;before: Level %d:n location %p\n&quot;,n,&amp;n); /* 1 */    if(n&lt;4)        up_and_down2(n+1);    printf(&quot;after: Level %d:n location %p\n&quot;,n,&amp;n); /* 2 */}void up_and_down2(int n){    printf(&quot;before: Level %d:n location %p\n&quot;,n,&amp;n); /* 1 */    if(n&lt;4)        up_and_down3(n+1);    printf(&quot;after: Level %d:n location %p\n&quot;,n,&amp;n); /* 2 */}void up_and_down3(int n){    printf(&quot;before: Level %d:n location %p\n&quot;,n,&amp;n); /* 1 */    if(n&lt;4)        up_and_down4(n+1);    printf(&quot;after: Level %d:n location %p\n&quot;,n,&amp;n); /* 2 */}void up_and_down4(int n){    printf(&quot;before: Level %d:n location %p\n&quot;,n,&amp;n); /* 1 */    if(n&lt;4)        up_and_down(n+1);    printf(&quot;after: Level %d:n location %p\n&quot;,n,&amp;n); /* 2 */}int main(int argc, const char * argv[]) {    @autoreleasepool {//        up_and_down(1);        up_and_down_simple(1);    }    return 0;}</code></pre><p>打印的结果：</p><pre><code>before: Level 1:n location 0x7fff5fbff75cbefore: Level 2:n location 0x7fff5fbff73cbefore: Level 3:n location 0x7fff5fbff71cbefore: Level 4:n location 0x7fff5fbff6fcafter: Level 4:n location 0x7fff5fbff6fcafter: Level 3:n location 0x7fff5fbff71cafter: Level 2:n location 0x7fff5fbff73cafter: Level 1:n location 0x7fff5fbff75cProgram ended with exit code: 0</code></pre><blockquote><p>这样一对比二者的结果是一样的所以说，如果你对递归还是很难理解，就去用展开的思路理解吧。</p></blockquote><p>总结一下</p><ul><li>每一次函数调用都会有一次返回．当程序流执行到某一级递归的结尾处时，它会转移到前一级递归继续执行．</li><li>递归函数中，位于递归调用前的语句和各级被调函数具有相同的顺序．如打印语句 #1 位于递归调用语句前，它按照递归调用的顺序被执行了 4 次；位于递归调用语句后的语句的执行顺序和各个被调用函数的顺序相反．</li><li>每一级的函数调用都有自己的私有变量．</li><li>递归函数中必须包含可以终止递归调用的语句．</li></ul><h1 id="常见递归问题"><a href="#常见递归问题" class="headerlink" title="常见递归问题"></a>常见递归问题</h1><p>有了上面的基础，现在开始来刷刷几道简单的题：</p><h2 id="阶乘n！"><a href="#阶乘n！" class="headerlink" title="阶乘n！"></a>阶乘n！</h2><p>按照递归的套路两个：  1. 递归公式： 有反复执行的过程（调用自身） 2. 退出条件： 有跳出反复执行过程的条件（递归出口）</p><ul><li>递归公式  n! = n <em> (n-1) </em> (n-2) <em> …</em> 1(n&gt;0)</li><li>退出条件 n == 0</li></ul><pre><code>int recursive(int n) {    if (0 == n) {        return (1);    }    else {        return n * recursive(n - 1);    }}</code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、……</p><ul><li>递归公式 Fib(n) =  Fib(n-1) + Fib(n-2);</li><li>退出条件 n == 0 ,n == 1</li></ul><pre><code>int Fib(int n) {    if (0 == n) {        return 1;    }    if (1 == n) {        return 1;    }    return Fib(n -1) + Fib(n - 2);}</code></pre><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。</p><p>  如1,2,3三个元素的全排列为：</p><pre><code>  1,2,3  1,3,2  2,1,3  2,3,1  3,1,2  3,2,1 </code></pre><p>这种问题递归公式和退出条件并不是那么明显，需要深入分析。如何去分析呢。一般思路就是总结归纳，先用最简单的例子找到规律，再提炼成公式。</p><p>把123的全排列可以看出三组，分别是1xx，2xx, 3xx。<strong>可以想成一个数列的全排列的公式 ：n个元素的全排列=（一个元素作为前缀）+（其余n-1个元素的全排列）；</strong></p><p>退出条件：如果只有一个元素的全排列，则说明已经排完，则输出数组；</p><p>不断换排头通过for循环就可以实现。然后就是前缀需要交换。先把基本的写好</p><p>交换函数：</p><pre><code>void Swap(char str[], int a, int b) {    char temp = str[a];    str[a] = str[b];    str[b] = temp;}</code></pre><p>主函数</p><pre><code>//全排列int sum = 0;void Perm(char str[], int begin, int end) {    if (begin == end)    {        for (int i = 0; i &lt;= end; i++)        {            cout &lt;&lt; str[i];        }        cout &lt;&lt; endl;        sum++;        return;    }    else    {        for (int j = begin; j &lt;= end; j++)        {            printf(&quot;\n swap begin:%d j:%d \n&quot;, begin, j);            Swap(str, begin, j);//交换是第几个            Perm(str, begin + 1, end);            Swap(str, j, begin);//归位        }    }}</code></pre><p>为了看清整个交换流程，加了个日志</p><pre><code>4abcd swap begin:0 j:0  swap begin:1 j:1  swap begin:2 j:2 abcd swap begin:2 j:3 abdc swap begin:1 j:2  swap begin:2 j:2 acbd swap begin:2 j:3 acdb swap begin:1 j:3  swap begin:2 j:2 adcb swap begin:2 j:3 adbc swap begin:0 j:1  swap begin:1 j:1  swap begin:2 j:2 bacd swap begin:2 j:3 badc swap begin:1 j:2  swap begin:2 j:2 bcad swap begin:2 j:3 bcda swap begin:1 j:3  swap begin:2 j:2 bdca swap begin:2 j:3 bdac swap begin:0 j:2  swap begin:1 j:1  swap begin:2 j:2 cbad swap begin:2 j:3 cbda swap begin:1 j:2  swap begin:2 j:2 cabd swap begin:2 j:3 cadb swap begin:1 j:3  swap begin:2 j:2 cdab swap begin:2 j:3 cdba swap begin:0 j:3  swap begin:1 j:1  swap begin:2 j:2 dbca swap begin:2 j:3 dbac swap begin:1 j:2  swap begin:2 j:2 dcba swap begin:2 j:3 dcab swap begin:1 j:3  swap begin:2 j:2 dacb swap begin:2 j:3 dabc24Program ended with exit code: 0</code></pre><p>  根据日志结合代码来分析就很容易理解了。</p><h2 id="河内塔问题"><a href="#河内塔问题" class="headerlink" title="河内塔问题"></a>河内塔问题</h2><p>n个盘子和3根柱子：A(源)、B(备用)、C(目的)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使用B柱，但盘子也只能放在比它大的盘子上面。</p><p>从上面的分析得出：<br>该问题可以分解成以下子问题：<br>第一步：将n-1个盘子从A柱移动至B柱（借助C柱为过渡柱）<br>第二步：将A柱底下最大的盘子移动至C柱<br>第三步：将B柱的n-1个盘子移至C柱（借助A柱为过渡柱）</p><pre><code>int i;    //记录步数  //i表示进行到的步数,将编号为n的盘子由from柱移动到to柱(目标柱)  void move(int n, char from, char to) {      printf(&quot;第%d步:将%d号盘子%c----&gt;%c\n&quot;, i++, n, from, to);  }  //汉诺塔递归函数  //n表示要将多少个&quot;圆盘&quot;从起始柱子移动至目标柱子  //start_pos表示起始柱子,tran_pos表示过渡柱子,end_pos表示目标柱子  void Hanio(int n, char start_pos, char tran_pos, char end_pos){      if(n == 1) {    //很明显,当n==1的时候,我们只需要直接将圆盘从起始柱子移至目标柱子即可.          move(n,start_pos, end_pos);      }      else {          Hanio(n-1, start_pos, end_pos, tran_pos);   //递归处理,一开始的时候,先将n-1个盘子移至过渡柱上          move(n, start_pos, end_pos);                //然后再将底下的大盘子直接移至目标柱子即可          Hanio(n-1, tran_pos, start_pos, end_pos);    //然后重复以上步骤,递归处理放在过渡柱上的n-1个盘子  此时借助原来的起始柱作为过渡柱(因为起始柱已经空了)      }  }</code></pre><p>这个思考起来有点麻烦，所以注释写得很多。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>除了上面列举的几个例子，还有比较常见的，二分查找，快排也用到了递归的思想。先这样吧。脑子还是得多用才能更加灵活。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://blog.csdn.net/tingyun_say/article/details/52078574" target="_blank" rel="noopener">深入理解递归函数的调用过程</a><br><a href="https://www.cnblogs.com/rain-lei/p/3622057.html" target="_blank" rel="noopener">函数调用–函数栈</a><br><a href="http://blog.csdn.net/morewindows/article/details/7370155/" target="_blank" rel="noopener">算法设计-全排列递归</a><br><a href="http://www.cnblogs.com/xmfdsh/p/4048086.html" target="_blank" rel="noopener">算法设计-全排列递归</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础标签</title>
      <link href="/2017/11/12/2019/11/HTML%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/11/12/2019/11/HTML%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>建议在进行HTML，JS，CSS学习的时候，安装Chorme扩展Web Maker，这样就可以直接在浏览器里面输入测试的代码，非常的便捷，所见即所得。</p></blockquote><p>本文的主要内容如下：</p><ul><li>头标签：<code>!DOCTYPE</code></li><li>排版标签：<code>&lt;p&gt;</code>、 <code>&lt;div&gt;</code>、 <code>&lt;span&gt;</code>、<code>&lt;br&gt;</code> 、 <code>&lt;hr&gt;</code> 、 <code>&lt;center&gt;</code> 、 <code>&lt;pre&gt;</code></li><li>字体标记：<code>&lt;h1&gt;</code>、 <code>&lt;font&gt;</code>、 <code>&lt;b&gt;</code>、 <code>&lt;u&gt;</code> 、<code>&lt;sup&gt;</code> 、<code>&lt;sub&gt;</code></li><li>超链接 <code>&lt;a&gt;</code></li><li>图片标签 <code>&lt;img&gt;</code></li><li>列表标签：<code>&lt;ul&gt;</code>、<code>&lt;OL&gt;</code>、<code>&lt;dl&gt;</code></li><li>表格标签：<code>&lt;table&gt;</code></li><li>框架标签及内嵌框架<code>&lt;iframe&gt;</code></li><li>表单标签：<code>&lt;form&gt;</code></li><li>多媒体标签：<code>&lt;bgsound&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;Object&gt;</code></li><li>滚动字幕标签：<code>&lt;marquee&gt;</code></li></ul><h2 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准</h2><p>web标准介绍：</p><ul><li>w3c：万维网联盟组织，用来制定web标准的机构（组织）</li><li>web标准：制作网页要遵循的规范。</li><li>web标准规范的分类：结构标准、表现标准、行为标准。</li><li>结构：html。表现：css。行为：JavaScript。</li></ul><p>web标准总结：</p><ul><li>结构标准：相当于人的身体。html就是用来制作网页的。</li><li>表现标准： 相当于人的衣服。css就是对网页进行美化的。</li><li>行为标准： 相当于人的动作。JS就是让网页动起来，具有生命力的。</li></ul><h2 id="浏览器介绍"><a href="#浏览器介绍" class="headerlink" title="浏览器介绍"></a>浏览器介绍</h2><p>浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、猎豹浏览器、Safari和Opera等。</p><p>浏览器内核：</p><table><thead><tr><th align="center">浏览器</th><th align="center">内核</th></tr></thead><tbody><tr><td align="center">IE</td><td align="center">trident</td></tr><tr><td align="center">chrome / 欧鹏</td><td align="center">blink</td></tr><tr><td align="center">火狐</td><td align="center">gecko</td></tr><tr><td align="center">Safari</td><td align="center">webkit</td></tr></tbody></table><p>PS：「浏览器内核」也就是浏览器所采用的「渲染引擎」，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。<strong>渲染引擎是兼容性问题出现的根本原因。</strong></p><h1 id="HTML的介绍"><a href="#HTML的介绍" class="headerlink" title="HTML的介绍"></a>HTML的介绍</h1><h2 id="1、HTML的概述："><a href="#1、HTML的概述：" class="headerlink" title="1、HTML的概述："></a>1、HTML的概述：</h2><p><strong>html</strong>全称为HyperText Markup Language，译为<font color="#0000ff"><strong>超文本标记语言</strong></font>，不是一种编程语言，是一种描述性的标记语言，<strong>用于描述超文本中内容的显示方式</strong>。比如字体什么颜色，大小等。</p><ul><li>超文本：音频，视频，图片称为超文本。</li><li>标记 ：&lt;英文单词或者字母&gt;称为标记，一个HTML页面都是由各种标记组成。</li></ul><p><strong>作用</strong>：HTML是负责描述文档<strong>语义</strong>的语言。</p><blockquote><p><strong>注意</strong>：HTML语言不是一个编程语言(有编译过程)，而是一个<strong>标记语言</strong>(<font color="#0000ff"><strong>没有编译过程</strong></font>)，HTML页面直接由浏览器解析执行。</p></blockquote><h3 id="HTML是负责描述文档语义的语言"><a href="#HTML是负责描述文档语义的语言" class="headerlink" title="HTML是负责描述文档语义的语言"></a>HTML是负责描述文档语义的语言</h3><p>html中，除了<strong>语义</strong>，其他什么都没有。</p><p>html是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述文字的语义，这些标签在浏览器里面是看不到的，所以称为“超文本”，所以就是“超文本标记语言”了。<br>所以，接下来，我们肯定要学习一堆html中的标签对儿，这些标签对儿能够给文本不同的语义。</p><p>比如，面试的时候问你，h1标签有什么作用？</p><ul><li>正确答案：给文本增加主标题的语义。</li><li>错误答案：给文字加粗、加黑、变大。</li></ul><h2 id="HTML的历史"><a href="#HTML的历史" class="headerlink" title="HTML的历史"></a>HTML的历史</h2><p><img src="http://img.smyhvae.com/20151001_1001.png" alt="html中标签发展趋势"></p><p>我们专门来对XHTML做一个介绍。</p><p><strong>XHTML介绍：</strong><br>XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。<br>XHTML的主要目的是为了<font color="blue"><strong>取代HTML</strong></font>，也可以理解为HTML的升级版。<br>HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。<br>XHTML与HTML4.0的标记基本上一样。<br>XHTML是<font color="blue"><strong>严格的、纯净的</strong></font>HTML。</p><p>我们稍后将对XHTML的编写规范进行介绍。</p><h2 id="HTML的术语"><a href="#HTML的术语" class="headerlink" title="HTML的术语"></a>HTML的术语</h2><ul><li>网页 ：由各种标记组成的一个页面就叫网页。</li><li>主页(首页) : 一个网站的起始页面或者导航页面。</li><li>标记：  <code>&lt;p&gt;</code>称为开始标记 ，<code>&lt;/p&gt;</code>称为结束标记，也叫标签。每个标签都规定好了特殊的含义。</li><li>元素：<code>&lt;p&gt;内容&lt;/p&gt;</code>称为元素.</li><li>属性：给每一个标签所做的辅助信息。</li><li>xhtml： 符合XML语法标准的HTML。</li><li>dhtml：dynamic，动态的。<code>javascript + css + html</code>合起来的页面就是一个dhtml。</li><li>http：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，ftp：文件传输协议。</li></ul><h2 id="HTML的编辑工具"><a href="#HTML的编辑工具" class="headerlink" title="HTML的编辑工具"></a>HTML的编辑工具</h2><blockquote><p>用的最多的编辑器是： VS Code 和 Sublime Text。</p></blockquote><ul><li>VS Code：最火的前端代码编辑器。</li><li>Sublime Text：很轻量的代码编辑器。</li><li>NotePad：记事本。</li><li>EditPlus：语法高亮显示。技巧： 根据颜色判断单词是否出错 （不是100%）。不好的地方：没有代码提示。</li><li>UltraEdit：根据颜色判断单词是否出错，可以显示2进制数据。</li><li>dw(dreamweaver，专业工具) ：建立WEB站点和应用程序的专业工具。它将布局功能、开发工具、代码编辑组合在一起。有代码提示。</li></ul><h2 id="计算机编码介绍"><a href="#计算机编码介绍" class="headerlink" title="计算机编码介绍"></a>计算机编码介绍</h2><p>计算机，不能直接存储文字，存储的是编码。</p><p>计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们定义一套规则来表示。假如：A用110表示，B用111表示等。</p><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a><strong>ASCII码</strong></h3><p>美国发布的，用<strong>1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符</strong>。美国的国家语言是英语，<strong>只要能表示0-9、a-z、A-Z、特殊符号</strong>。</p><h3 id="ANSI编码"><a href="#ANSI编码" class="headerlink" title="ANSI编码"></a><strong>ANSI编码</strong></h3><p><strong>每个国家为了显示本国的语言，都对ASCII码进行了扩展</strong>。<strong>用2个字节</strong>(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如：<br>中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。<br>日本的ANSI编码是JIS编码。<br>台湾的ANSI编码是BIG5编码（繁体）。</p><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a><strong>GBK</strong></h3><p>对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。</p><h3 id="Unicode编码-统一编码-："><a href="#Unicode编码-统一编码-：" class="headerlink" title="Unicode编码(统一编码)："></a><strong>Unicode编码(统一编码)：</strong></h3><p><strong>用4个字节(32位二进制)来表示一个字符</strong>，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000</p><h3 id="UTF-8-Unicode-Transform-Format-编码："><a href="#UTF-8-Unicode-Transform-Format-编码：" class="headerlink" title="UTF-8(Unicode Transform Format)编码："></a><strong>UTF-8(Unicode Transform Format)编码：</strong></h3><p><strong>根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表</strong>示，一个汉字用2个字节表示。</p><p>毫无疑问，开发中，都用<strong>UTF-8</strong>编码吧，准没错。</p><blockquote><p><strong>中文能够使用的字符集两种：</strong></p></blockquote><ul><li>第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语……</li><li>第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面<strong>仅</strong>涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。</li></ul><p>字库规模：  UTF-8（字全） &gt; gb2312（只有汉字）</p><h3 id="重点1：避免乱码"><a href="#重点1：避免乱码" class="headerlink" title="重点1：避免乱码"></a><strong>重点1：避免乱码</strong></h3><p>我们用meta标签声明的当前这个html文档的字库，<strong>一定要和保存的文件编码类型一样，否则乱码</strong>！（重点）。</p><p>当我们不设置的时候，s<strong>ublime默认类型就是UTF-8</strong>。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： <code>文件→ set File Encoding to → Chinese Simplified(GBK)</code>。</p><h3 id="重点2：UTF-8和gb2312的比较"><a href="#重点2：UTF-8和gb2312的比较" class="headerlink" title="重点2：UTF-8和gb2312的比较"></a><strong>重点2：UTF-8和gb2312的比较</strong></h3><p>保存大小：UTF-8（更臃肿、加载更慢） &gt; gb2312 （更小巧，加载更快）</p><p>总结：</p><ul><li>UTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿；</li><li>gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。</li></ul><p>列出2个使用情形：</p><p>1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。<br>2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。</p><blockquote><p>亲测：</p></blockquote><ul><li>qq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。</li><li>新华网藏语频道，使用的是UTF-8，保证字符集的数量。</li></ul><p>对了，我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，<strong>找到me标签中的charset属性即可</strong>。<br>那么，我们为什么可以查看网页的源代码呢？因为这个打开的网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然剋以查看网页的源代码了。</p><h2 id="HTML颜色介绍"><a href="#HTML颜色介绍" class="headerlink" title="HTML颜色介绍"></a>HTML颜色介绍</h2><p><strong>颜色表示：</strong></p><ul><li>纯单词表示：red、green、blue、orange、gray等</li><li>10进制表示：rgb(255,0,0)</li><li>16进制表示：#FF0000、#0000FF、#00FF00等</li></ul><p><strong>RGB色彩模式：</strong></p><ul><li>自然界中所有的颜色都可以用红、绿、蓝(RGB)这三种颜色波长的不同强度组合而得，这就是人们常说的三原色原理。</li><li>RGB三原色也叫加色模式，这是因为当我们把不同光的波长加到一起的时候，可以得到不同的混合色。例：红+绿=黄色，红+蓝＝紫色，绿+蓝=青</li><li>在数字视频中，对RGB三基色各进行8位编码就构成了大约1678万种颜色，这就是我们常说的真彩色。所有显示设备都采用的是RGB色彩模式。</li><li>RGB各有256级(0-255)亮度，256级的RGB色彩总共能组合出约1678万种色彩，即256×256×256=16777216。</li></ul><h1 id="HTML的规范"><a href="#HTML的规范" class="headerlink" title="HTML的规范"></a>HTML的规范</h1><ul><li>HTML是一个弱势语言</li><li><strong>HTML不区分大小写</strong></li><li>HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统)</li><li>HTML的结构：<ul><li>声明部分：主要作用是用来告诉浏览器这个页面使用的是哪个标准。<!doctype html>是HTML5标准。</li><li>head部分：将页面的一些额外信息告诉服务器。不会显示在页面上。</li><li>body部分：我们所写的代码必须放在此标签內。</li></ul></li></ul><h2 id="编写XHTML的规范："><a href="#编写XHTML的规范：" class="headerlink" title="编写XHTML的规范："></a>编写XHTML的规范：</h2><p>（1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：<code>&lt;h1&gt;&lt;font&gt;&lt;/font&gt;&lt;/h1&gt;</code></p><p>（2）<strong>所有的标记都必须小写</strong>。</p><p>（3）<strong>所有的标记都必须关闭</strong>。</p><ul><li>双边标记：<code>&lt;span&gt;&lt;/span&gt;</code></li><li><strong>单边标记：<code>&lt;br&gt;</code> 转成 <code>&lt;br /&gt;</code>   <code>&lt;hr&gt;</code> 转成 <code>&lt;hr /&gt;</code>，还有<code>&lt;img src=“URL” /&gt;</code></strong></li></ul><p>（4）所有的属性值必须加引号。<code>&lt;font  color=&quot;red&quot;&gt;&lt;/font&gt;</code></p><p>（5）所有的属性必须有值。<code>&lt;hr noshade=&quot;noshade&quot;&gt;</code>、<code>&lt;input  type=&quot;radio&quot; checked=&quot;checked&quot; /&gt;</code></p><p>（6）XHTML文档开头必须要有DTD文档类型定义</p><h3 id="HTML的基本语法特性"><a href="#HTML的基本语法特性" class="headerlink" title="HTML的基本语法特性"></a>HTML的基本语法特性</h3><h3 id="（1）HTML对换行不敏感，对tab不敏感"><a href="#（1）HTML对换行不敏感，对tab不敏感" class="headerlink" title="（1）HTML对换行不敏感，对tab不敏感"></a>（1）HTML对换行不敏感，对tab不敏感</h3><blockquote><p>HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。</p></blockquote><p>也就是说，HTML不是依靠缩进来表示嵌套的，就是看标签的包裹关系。但是，我们发现有良好的缩进，代码更易读。要求大家都正确缩进标签。</p><p>百度为了追求极致的显示速度，所以HTML标签都没有换行、都没有缩进（tab），HTML和换不换行无关，标签的层次依然清晰，只不过程序员不可读了。</p><h3 id="（2）空白折叠现象"><a href="#（2）空白折叠现象" class="headerlink" title="（2）空白折叠现象"></a>（2）空白折叠现象</h3><p>HTML中所有的<strong>文字之间</strong>，如果有空格、换行、tab都将被折叠为一个空格显示。</p><h3 id="（3）标签要严格封闭"><a href="#（3）标签要严格封闭" class="headerlink" title="（3）标签要严格封闭"></a>（3）标签要严格封闭</h3><p>标签不封闭是灾难性的。</p><h1 id="HTML结构详解"><a href="#HTML结构详解" class="headerlink" title="HTML结构详解"></a>HTML结构详解</h1><blockquote><p>备注：</p><ul><li>所有的浏览器默认情况下都会忽略空格和空行</li><li><strong>每个标签都有私有属性。也都有公有属性。</strong></li><li>html中表示长度的单位都是<strong>像素</strong>。<strong>HTML只有一种单位就是像素</strong>。</li></ul></blockquote><p>HTML标签通常是成对出现的（<font color="blue"><strong>双边标记</strong></font>），比如 <code>&lt;div&gt;</code> 和 <code>&lt;/div&gt;</code>，也有单独呈现的标签（<font color="blue"><strong>单边标记</strong></font>），如：<code>&lt;br /&gt;</code>、<code>&lt;hr /&gt;</code>和<code>&lt;img src=&quot;images/1.jpg&quot; /&gt;</code>等。</p><p>属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。</p><p>一个基本骨架</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html;charset<span class="token punctuation">=</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1、文档声明头"><a href="#1、文档声明头" class="headerlink" title="1、文档声明头"></a>1、文档声明头</h2><p>任何一个标准的HTML页面，第一行一定是一个以<code>&lt;!DOCTYPE ……&gt;</code>开头的语句。</p><p>这一行，就是文档声明头，DocType Declaration，简称DTD。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</p><h3 id="HTML4-01有哪些规范呢？"><a href="#HTML4-01有哪些规范呢？" class="headerlink" title="HTML4.01有哪些规范呢？"></a>HTML4.01有哪些规范呢？</h3><p><strong>HTML4.01</strong>这个版本是IE6开始兼容的。<strong>HTML5是IE9开开始兼容的</strong>。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。</p><p>HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。</p><p>HTML4.01里面规定了<strong>普通</strong>和<strong>XHTML</strong>两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？<code>&lt;H1&gt;&lt;/H1&gt;</code>所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。</p><p>总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况</p><p><img src="http://img.smyhvae.com/20170629_1600.png" alt></p><p>下面对上图中的三种小规范进行解释：</p><ul><li><strong>strict</strong>：表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。<br><strong>比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML只能负责语义，不能负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。</strong><br>那怎么给文本增加下划线呢？今后的css将使用css属性来解决。<br>那么，XHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。</li><li><strong>Transitional</strong>：表示“普通的”，这种模式就是没有一些别的规范。</li><li><strong>Frameset</strong>：表示“框架”，在框架的页面使用。</li></ul><p>在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了:</p><pre><code>&lt;!DOCTYPE html&gt;</code></pre><h2 id="2、头标签"><a href="#2、头标签" class="headerlink" title="2、头标签"></a>2、头标签</h2><p>头部比较完善的例子</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html;charset<span class="token punctuation">=</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>牛逼，很牛逼，特别牛逼<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>面试题：</p><ul><li>问：网页的head标签里面，表示的是页面的配置，有什么配置？</li><li>答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。</li></ul><p>头标签都放在<head><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>头部分之间。包括：<code>&lt;title&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;link&gt;</code></p><ul><li><code>&lt;title&gt;</code>：指定整个网页的标题，在浏览器最上方显示。</li><li><code>&lt;base&gt;</code>：<strong>为页面上的所有链接规标题栏显示的内容定默认地址或默认目标</strong>。——开发项目的时候经常用</li><li><code>&lt;meta&gt;</code>：提供有关页面的基本信息</li><li><code>&lt;link&gt;</code>：定义文档与外部资源的关系。</li></ul><p><strong>meta 标签</strong>：</p><p>上面的<code>&lt;meta&gt;</code>标签都不用记，但是另外还有一个<code>&lt;meta&gt;</code>标签是需要记住的：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>refresh<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3;http://www.baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>上面这个标签的意思是说，3秒之后，自动跳转到百度页面。</strong></p><p>常见的几种 meta 标签如下：</p><h3 id="（1）字符集-charset："><a href="#（1）字符集-charset：" class="headerlink" title="（1）字符集 charset："></a>（1）字符集 charset：</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html;charset<span class="token punctuation">=</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字符集用meta标签中的<code>charset</code>定义，meta表示“元”。“元”配置，就是表示基本的配置项目。</p><p>charset就是charactor set（即“字符集”）。</p><p>浏览器就是通过meta来看网页是什么字符集的。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。</p><h3 id="（2）视口-viewport："><a href="#（2）视口-viewport：" class="headerlink" title="（2）视口 viewport："></a>（2）视口 viewport：</h3><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>width=device-width</code> ：表示视口宽度等于屏幕宽度。</p><p>viewport 这个知识点，初学者还比较难理解，主要是在 Web 移动端的时候会用到。</p><h3 id="（3）定义“关键词”："><a href="#（3）定义“关键词”：" class="headerlink" title="（3）定义“关键词”："></a>（3）定义“关键词”：</h3><p>举例如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。</p><h3 id="（4）定义“页面描述”："><a href="#（4）定义“页面描述”：" class="headerlink" title="（4）定义“页面描述”："></a>（4）定义“页面描述”：</h3><p>meta除了可以设置字符集，还可以设置关键字和页面描述。</p><p>只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做<strong>SEO</strong>（search engine optimization，搜索引擎优化）。</p><p>设置页面描述的举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果如下：</p><p><img src="http://img.smyhvae.com/20170629_1743.png" alt></p><h3 id="（5）title标签"><a href="#（5）title标签" class="headerlink" title="（5）title标签:"></a><strong>（5）title标签</strong>:</h3><p>用于设置网页标题：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>网页的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>title也是有助于SEO搜索引擎优化的。</p><h3 id="（6）base标签："><a href="#（6）base标签：" class="headerlink" title="（6）base标签："></a>（6）<strong>base标签</strong>：</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。</p><h3 id="3、-lt-body-gt-标签的属性"><a href="#3、-lt-body-gt-标签的属性" class="headerlink" title="3、&lt;body&gt;标签的属性"></a>3、<code>&lt;body&gt;</code>标签的属性</h3><p>其属性有：</p><ul><li><code>bgcolor</code>：设置整个网页的背景颜色。</li><li><code>background</code>：<strong>设置整个网页的背景图片</strong>。——注意和bgcolor的区别</li><li><code>text</code>：设置网页中的文本颜色。</li><li><code>leftmargin</code>：网页的左边距。IE浏览器默认是8个像素。</li><li><code>topmargin</code>：网页的上边距。</li><li><code>rightmargin</code>：网页的右边距。</li><li><code>bottommargin</code>：网页的下边距。</li></ul><p><code>&lt;body&gt;</code>标签另外还有一些属性，这里用个例子来解释：</p><p><img src="http://img.smyhvae.com/2015-10-02-cnblogs_html_39.png" alt></p><p>上方代码中，当我们对<code>点我点我</code>这几个字使用超链时，<code>link</code>属性表示默认显示的颜色、<code>alink</code>属性表示鼠标点击但是还没有松开时的颜色、<code>vlink</code>属性表示点击完成之后显示的颜色。</p><p>接下来，我们讲一下<code>&lt;body&gt;</code>里的各种标签的属性。</p><h1 id="一、排版标签"><a href="#一、排版标签" class="headerlink" title="一、排版标签"></a>一、排版标签</h1><h2 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 注释  --></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="段落标签-lt-p-gt"><a href="#段落标签-lt-p-gt" class="headerlink" title="段落标签&lt;p&gt;"></a>段落标签<code>&lt;p&gt;</code></h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is a paragraph<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is another paragraph<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>属性：</p><ul><li><code>align=&quot;属性值&quot;</code>：对齐方式。属性值包括left center right。</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>This is a paragraph<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>段落，是英语paragraph“段落”缩写。</p><p>HTML标签是分等级的，HTML将所有的标签分为两种：</p><ul><li><strong>文本级标签</strong>：p、span、a、b、i、u、em。文本级标签里只能放<strong>文字、图片、表单元素</strong>。（a标签里不能放a和input）</li><li><strong>容器级标签</strong>：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。</li></ul><p>死死记住：<strong>p标签是一个文本级标签，p里面只能放文字、图片、表单元素</strong>。其他的一律不能放。</p><p>错误写法：（尝试把 h 放到 p 里）</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        我是一个小段落        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>我是一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="块级标签-lt-div-gt-和-lt-span-gt"><a href="#块级标签-lt-div-gt-和-lt-span-gt" class="headerlink" title="块级标签 &lt;div&gt;和&lt;span&gt;"></a>块级标签 <code>&lt;div&gt;</code>和<code>&lt;span&gt;</code></h2><blockquote><p>div和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。</p></blockquote><blockquote><p>CSS课程中你将知道，这两个东西，都是最最重要的“盒子”。</p></blockquote><p>div：把标签中的内容作为一个块儿来对待(division)。必须单独占据一行。</p><p>div标签的属性：</p><ul><li><code>align=&quot;属性值&quot;</code>：设置块儿的位置。属性值可选择：left、right、 center。</li></ul><blockquote><p><strong><code>&lt;span&gt;</code>和<code>&lt;div&gt;</code>唯一的区别在于</strong>：<code>&lt;span&gt;</code>是不换行的，而<code>&lt;div&gt;</code>是换行的。</p></blockquote><p>如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。</p><ol><li>div在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。</li><li>div标签是一个<strong>容器级</strong>标签，里面什么都能放，甚至可以放div自己。</li><li>span也是表达“<strong>小区域、小跨度</strong>”的标签，但是是一个<strong>文本级</strong>的标签。就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。</li></ol><blockquote><p>span里面是放置小元素的，div里面放置大东西的。举例如下：</p></blockquote><p>span举例：</p><pre class="line-numbers language-html"><code class="language-html">            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>                简介简介简介简介简介简介简介简介                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>详细信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>购买<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>div举例：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>guanggao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dongxi<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，我们亲切的称呼这种模式叫做“<strong>div+css</strong>”。<strong>div标签负责布局，负责结构，负责分块。css负责样式</strong>。</p><h2 id="内容居中标签-lt-center-gt"><a href="#内容居中标签-lt-center-gt" class="headerlink" title="内容居中标签 &lt;center&gt;"></a>内容居中标签 <code>&lt;center&gt;</code></h2><p>此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。<br>效果演示</p><p>到了H5里面，center标签不建议使用。</p><h2 id="预定义（预格式化）标签：-lt-pre-gt"><a href="#预定义（预格式化）标签：-lt-pre-gt" class="headerlink" title="预定义（预格式化）标签：&lt;pre&gt;"></a>预定义（预格式化）标签：<code>&lt;pre&gt;</code></h2><p>含义：将保留其中的所有的空白字符(空格、换行符)，原封不动的输出结果（告诉浏览器不要忽略空格和空行）<br>说明：真正排网页过程中，<code>&lt;pre&gt;</code>标签几乎用不着。</p><blockquote><p>所有的浏览器默认情况下都会忽略空格和空行。</p></blockquote><h1 id="二、字体标签"><a href="#二、字体标签" class="headerlink" title="二、字体标签"></a>二、字体标签</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题使用<code>&lt;h1&gt;</code>至<code>&lt;h6&gt;</code>标签进行定义。<code>&lt;h1&gt;</code>定义最大的标题，<code>&lt;h6&gt;</code>定义最小的标题。<strong>具有align属性</strong>，属性值可以是：left、center、right。</p><h2 id="字体标签-lt-font-gt-（已废弃）"><a href="#字体标签-lt-font-gt-（已废弃）" class="headerlink" title="字体标签&lt;font&gt;（已废弃）"></a>字体标签<code>&lt;font&gt;</code>（已废弃）</h2><p>属性：</p><ul><li><code>color=&quot;红色&quot;</code>或<code>color=&quot;#ff00cc&quot;</code>或<code>color=&quot;new rgb(0,0,255)&quot;</code>：设置字体颜色。<br>设置方式：单词 \  #ff00cc \   rgb(0,0,255)</li><li><code>size</code>：设置字体大小。 取值范围只能是：1至7。取值时，如果取值大于7那就按照7来算，如果取值小于1那就按照1来算。如果想要更大的字体，那就只能通过css样式来解决。<br>设置：用’+2’代表值是5 或直接给值</li><li><code>face=&quot;微软雅黑&quot;</code>：设置字体类型。注意在写字体时，“微软雅黑”这个字不能写错。<br>举例：</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">face</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>微软雅黑<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FF0000<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>vae<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="特殊字符（转义字符）"><a href="#特殊字符（转义字符）" class="headerlink" title="特殊字符（转义字符）"></a>特殊字符（转义字符）</h2><ul><li><code>&amp;nbsp;</code>：空格    （non-breaking spacing，不断打空格）</li><li><code>&amp;lt;</code>：小于号（less than）</li><li><code>&amp;gt;</code>：大于号（greater than）</li><li><code>&amp;amp;</code>：符号<code>&amp;</code></li><li><code>&amp;quot;</code>：双引号</li><li><code>&amp;apos;</code>：单引号</li><li><code>&amp;copy;</code>：版权<code>©</code></li><li><code>&amp;trade;</code>：商标<code>™</code></li><li><code>&amp;#32464;</code>：文字<code>绐</code>。其实，<code>#32464</code>是汉字<code>绐</code>的unicode编码。</li></ul><blockquote><p>要求背诵的特殊字符有：<code>&amp;nbsp;</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>、<code>&amp;copy;</code>。</p></blockquote><p>比如说，你想把<code>&lt;p&gt;</code>作为一个文本在页面上显示，直接写<code>&lt;p&gt;</code>是肯定不行的，因为这代表的是一个段落标签，所以这里需要用到<strong>转义字符</strong>。应该这么写：</p><pre class="line-numbers language-html"><code class="language-html">这是一个HTML语言的<span class="token entity" title="&lt;">&amp;lt;</span>p<span class="token entity" title="&gt;">&amp;gt;</span>标签<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来一张表格，方便需要的时候查询：</p><table><thead><tr><th align="left">特殊字符</th><th align="left">描述</th><th align="left">字符的代码</th></tr></thead><tbody><tr><td align="left"></td><td align="left">空格符</td><td align="left"><code>&amp;nbsp;</code></td></tr><tr><td align="left">&lt;</td><td align="left">小于号</td><td align="left"><code>&amp;lt;</code></td></tr><tr><td align="left">&gt;</td><td align="left">大于号</td><td align="left"><code>&amp;gt;</code></td></tr><tr><td align="left">&amp;</td><td align="left">和号</td><td align="left"><code>&amp;amp;</code></td></tr><tr><td align="left">￥</td><td align="left">人民币</td><td align="left"><code>&amp;yen;</code></td></tr><tr><td align="left">©</td><td align="left">版权</td><td align="left"><code>&amp;copy;</code></td></tr><tr><td align="left">®</td><td align="left">注册商标</td><td align="left"><code>&amp;reg;</code></td></tr><tr><td align="left">°</td><td align="left">摄氏度</td><td align="left"><code>&amp;deg;</code></td></tr><tr><td align="left">±</td><td align="left">正负号</td><td align="left"><code>&amp;plusmn;</code></td></tr><tr><td align="left">×</td><td align="left">乘号</td><td align="left"><code>&amp;times;</code></td></tr><tr><td align="left">÷</td><td align="left">除号</td><td align="left"><code>&amp;divide;</code></td></tr><tr><td align="left">²</td><td align="left">平方2（上标2）</td><td align="left"><code>&amp;sup2;</code></td></tr><tr><td align="left">³</td><td align="left">立方3（上标3）</td><td align="left"><code>&amp;sup3;</code></td></tr></tbody></table><h2 id="一些小标签-小标记"><a href="#一些小标签-小标记" class="headerlink" title="一些小标签/小标记"></a>一些小标签/小标记</h2><ul><li><code>&lt;u&gt;</code>：下划线标记</li><li><code>&lt;s&gt;</code>或<code>&lt;del&gt;</code>：中划线标记（删除线）</li><li><code>&lt;i&gt;</code>或<code>&lt;em&gt;</code>：斜体标记</li></ul><h2 id="粗体标签-lt-b-gt-或-lt-strong-gt-（已废弃）"><a href="#粗体标签-lt-b-gt-或-lt-strong-gt-（已废弃）" class="headerlink" title="粗体标签&lt;b&gt;或&lt;strong&gt;（已废弃）"></a>粗体标签<code>&lt;b&gt;</code>或<code>&lt;strong&gt;</code>（已废弃）</h2><h2 id="上标-lt-sup-gt-下标-lt-sub-gt"><a href="#上标-lt-sup-gt-下标-lt-sub-gt" class="headerlink" title="上标&lt;sup&gt;   下标&lt;sub&gt;"></a>上标<code>&lt;sup&gt;</code>   下标<code>&lt;sub&gt;</code></h2><p>上小标这两个标签容易混淆，怎么记呢？这样记：<code>b</code>的意思是<code>bottom：底部</code><br>举例：</p><pre class="line-numbers language-html"><code class="language-html">O<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sup</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sup</span><span class="token punctuation">></span></span>    5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="三、超链接"><a href="#三、超链接" class="headerlink" title="三、超链接"></a>三、超链接</h1><p>超链接有三种形式：</p><p><strong>1、外部链接</strong>——href：链接到外部文件。举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>02页面.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击进入另外一个文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>a是英语<code>anchor</code>“锚”的意思，就好像这个页面往另一个页面扔出了一个锚。是一个文本级的标签。</p><p>href是英语<code>hypertext reference</code>超文本地址的缩写。读作“喝瑞夫”，不要读作“喝夫”。</p><p>当然，我们也可以直接点进链接，访问一个网址。举例如下；</p><pre><code>    &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点我点我&lt;/a&gt;</code></pre><p><strong>2、锚链接</strong>——name：<br>指给超链接起一个名字，作用是<strong>在本页面或者其他页面的的不同位置进行跳转</strong>。比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就是利用到了锚链接。</p><blockquote><p>首先我们要创建一个<strong>锚点</strong>，也就是说，使用<code>name</code>属性或者<code>id</code>属性给那个特定的位置起个名字。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#name1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>回到顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>#</code>号不要忘记了，表示跳到名为name1的特定位置，这是规定。如果少了<code>#</code>号，点击之后，就会跳到name1这个文件或者name1这个文件夹中去。</p><p>如果我们将代码写成：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a.html#name1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>回到顶部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那就表示，点击之后，跳转到<code>a.html</code>页面的<code>name1锚点</code>中去。</p><blockquote><p>说明：name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的。</p></blockquote><p><strong>3、邮件链接</strong>：<br>代码举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mailto:xxxxx@xxx.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击进入我的邮箱<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果：点击之后，如果安装了邮箱客户端则会弹出邮箱客户端，作用不大。</p><h2 id="超链接的属性"><a href="#超链接的属性" class="headerlink" title="超链接的属性"></a>超链接的属性</h2><ul><li><code>href</code>：目标URL</li><li><code>title</code>：悬停文本。</li><li><code>name</code>：主要用于设置一个锚点的名称。</li><li><code>target</code>：告诉浏览器用什么方式来打开目标页面。<code>target</code>属性有以下几个值：<ul><li><code>_self</code>：在同一个网页中显示（默认值）</li><li><code>_blank</code>：<strong>在新的窗口中打开</strong>。</li><li><code>_parent</code>：在父窗口中显示</li><li><code>_top</code>：在顶级窗口中显示</li></ul></li></ul><blockquote><p> 特别注意这里的<code>target</code></p></blockquote><p><code>title</code>属性举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>09_img.html<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>很好看哦<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>结婚照<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>target</code>属性举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.html<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>悬停文本<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>链接的内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>blank就是“空白”的意思，就表示新建一个空白窗口。为啥有一个_ ，就是规定，没啥好解释的。<br>也就是说，如果不写<code>target=”_blank”</code>那么就是在相同的标签页打开，如果写了<code>target=”_blank”</code>，就是在新的空白标签页中打开。</p></blockquote><h3 id="备注1：分清楚img和a标签的各自的属性"><a href="#备注1：分清楚img和a标签的各自的属性" class="headerlink" title="备注1：分清楚img和a标签的各自的属性"></a>备注1：分清楚img和a标签的各自的属性</h3><p>区别如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.jpg<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="备注2：a是一个文本级的标签"><a href="#备注2：a是一个文本级的标签" class="headerlink" title="备注2：a是一个文本级的标签"></a>备注2：a是一个文本级的标签</h3><p>比如一个段落中的所有文字都能够被点击，那么应该是p包裹a：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>段落段落段落段落段落段落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而不是a包裹p：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        段落段落段落段落段落段落    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>a的语义要小于p，a就是可以当做文本来处理，所以p里面相当于放的就是纯文字。</p><h1 id="四、图片标签"><a href="#四、图片标签" class="headerlink" title="四、图片标签"></a>四、图片标签</h1><p>img: 代表的就是一张图片。<strong>是单边标记</strong>。</p><p>img是自封闭标签，也称为单标签。</p><p>能插入的图片类型：</p><ul><li>能够插入的图片类型是：jpg(jpeg)、gif、png、bmp。类型和类型之间有什么区别，css课上讲。</li><li>不能往网页中插入的图片格式是：psd、ai</li></ul><blockquote><p>HTML页面不是直接插入图片，而是插入图片的引用地址，所以也要把图片上传到服务器上。</p></blockquote><h2 id="src属性：图片的相对路径和绝对路径"><a href="#src属性：图片的相对路径和绝对路径" class="headerlink" title="src属性：图片的相对路径和绝对路径"></a><code>src</code>属性：图片的相对路径和绝对路径</h2><p>这里涉及到图片的一个属性：</p><ul><li><code>src</code>属性：指图片的路径。</li></ul><p>在写<strong>图片的路径</strong>时，有两种写法：相对路径、绝对路径</p><h3 id="1、写法一：相对路径"><a href="#1、写法一：相对路径" class="headerlink" title="1、写法一：相对路径"></a>1、<strong>写法一：相对路径</strong></h3><p>相对当前页面所在的路径。两个标记 <code>.</code> 和 <code>..</code> 分表代表当前目录和父路径。</p><p>举例1：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 当前目录中的图片 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.\2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 上一级目录中的图片 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>..\2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>img 是image“图片”的简写，src 是英语source“资源”的缩写。</p><p>相对路径不会出现这种情况：</p><pre class="line-numbers language-html"><code class="language-html">aaa/../bbb/1.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>../</code>要么不写，要么就写在开头。</p><p>举例2：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>images/1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上方代码的意思是说，当前页面有一个并列的文件夹<code>images</code>，在文件夹<code>images</code>中存放了一张图片<code>1.jpg</code></p><h4 id="2、写法二：绝对路径"><a href="#2、写法二：绝对路径" class="headerlink" title="2、写法二：绝对路径"></a>2、写法二：<strong>绝对路径</strong></h4><p>绝对路径包括以下两种：</p><p>（1）以盘符开始的绝对路径。举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>C:\Users\xxxx\Desktop\html\images\1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）网络路径。举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://img.xxx.com/xxx.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="相对路径和绝对路径的总结"><a href="#相对路径和绝对路径的总结" class="headerlink" title="相对路径和绝对路径的总结"></a>相对路径和绝对路径的总结</h2><p>相对路径的好处：站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的。<br>相对路径使用有一个前提，就是网页文件和你的图片，必须在一个服务器上。</p><p>问题：我的网页在C盘，图片却在D盘，能不能插入呢？</p><p>答案： 用相对路径不能，用绝对路径也不能。</p><blockquote><p>注意：可以使用file://来插入，但是这种方法，没有任何意义！因为服务器上没有所谓c盘、d盘。</p></blockquote><p>下面的方法是行的，<strong>但是没有任何工程上的意义，这是因为服务器没有盘符，linux系统没有盘符</strong>：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file://C:\Users\Danny\Pictures\明星\1.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总结一下：</p><ul><li>我们现在无论是在a标签、img标签，如果要用路径。只有两种路径能用，就是相对路径和绝对路径。</li><li>相对路径，就是../   image/ 这种路径。从自己出发，找到别人；</li><li>绝对路径，就是http://开头的路径。</li><li>绝对不允许使用file://开头的东西，这个是完全错误的！</li></ul><h2 id="img标签的其他属性"><a href="#img标签的其他属性" class="headerlink" title="img标签的其他属性"></a>img标签的其他属性</h2><ul><li><code>width</code>：宽度</li><li><code>height</code>：高度</li><li><code>Align</code>：指图片的水平对齐方式，属性值可以是：left、center、right</li><li><code>title</code>：<strong>提示性文本</strong>。公有属性。也就是鼠标悬停时出现的文本。</li><li><code>border</code>：给图片加边框（描边），单位是像素，边框的颜色是黑色</li><li><code>Hspace</code>：指图片左右的边距</li><li><code>Vspace</code>：指图片上下的边距</li><li><code>alt</code>：当图片不可用（无法显示）的时候，代替图片显示的内容。alt是英语 alternate “替代”的意思，代表替换资源。（有的浏览器不支持）</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>images/1.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>`188<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>这是美女<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="五、列表标签"><a href="#五、列表标签" class="headerlink" title="五、列表标签"></a>五、列表标签</h1><p>列表标签分为三种。</p><h2 id="1、无序列表-lt-ul-gt-，无序列表中的每一项是-lt-li-gt"><a href="#1、无序列表-lt-ul-gt-，无序列表中的每一项是-lt-li-gt" class="headerlink" title="1、无序列表&lt;ul&gt;，无序列表中的每一项是&lt;li&gt;"></a>1、无序列表<code>&lt;ul&gt;</code>，无序列表中的每一项是<code>&lt;li&gt;</code></h2><p>英文单词解释如下：</p><ul><li>ul：unordered list，“无序列表”的意思。</li><li>li：list item，“列表项”的意思。</li></ul><p>例如：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>默认1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>默认2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>默认3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>li不能单独存在，必须包裹在ul里面；反过来说，ul的“儿子”不能是别的东西，只能有li。</li><li>我们这里再次强调，ul的作用，并不是给文字增加小圆点的，而是增加无序列表的“语义”的。</li></ul><p><strong>属性：</strong></p><ul><li><code>type=&quot;属性值&quot;</code>。属性值可以选： <code>disc</code>(实心原点，默认)，<code>square</code>(实心方点)，<code>circle</code>(空心圆)。</li></ul><p>注意：项目符号可以是图片，需要通过CSS设置<code>&lt;li&gt;</code>标记的背景图片来实现(CSS中讲)。</p><p>当然了，列表之间是可以<strong>嵌套</strong>的。我们来举个例子。代码：</p><pre class="line-numbers language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>北京市<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>海淀区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>朝阳区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>东城区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>广州市<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>天河区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>越秀区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>css 属性</strong>：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">list-style-position</span><span class="token punctuation">:</span> inside   <span class="token comment" spellcheck="true">/* 给 ul 设置这个属性后，将小圆点包含在 li 元素的内部 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="ul标签实际应用场景："><a href="#ul标签实际应用场景：" class="headerlink" title="ul标签实际应用场景："></a>ul标签实际应用场景：</h4><p>场景1、导航条：</p><p><img src="http://img.smyhvae.com/20170704_1717.png" alt></p><p>场景2、li 里面放置的内容可能很多：</p><p><img src="http://img.smyhvae.com/20170704_1719.png" alt></p><p>声明：ul的儿子，只能是li。但是li是一个容器级标签，<strong>li里面什么都能放，甚至可以再放一个ul</strong>。</p><h2 id="2、有序列表-lt-OL-gt-，里面的每一项是-lt-li-gt"><a href="#2、有序列表-lt-OL-gt-，里面的每一项是-lt-li-gt" class="headerlink" title="2、有序列表&lt;OL&gt;，里面的每一项是&lt;li&gt;"></a>2、有序列表<code>&lt;OL&gt;</code>，里面的每一项是<code>&lt;li&gt;</code></h2><p>英文单词：Ordered List。</p><p>例如：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵哒1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵哒2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵哒3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果：</p><p><img src="http://img.smyhvae.com/2015-10-02-cnblogs_html_04.png" alt></p><p><strong>属性：</strong></p><ul><li><code>type=&quot;属性值&quot;</code>。属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。结合<code>start</code>属性表示<code>从几开始</code>。</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>嘿嘿<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>嘿嘿<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>呵呵<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i<span class="token punctuation">"</span></span> <span class="token attr-name">start</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>I<span class="token punctuation">"</span></span> <span class="token attr-name">start</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>么么<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>么么<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>么么<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下</p><p>和无序列表一样，有序列表也是可以嵌套的哦，这里就不举类似的例子了。</p><p>ol和ul就是语义不一样，怎么使用都是一样的。<br>ol里面只能有li，li必须被ol包裹。li是容器级。</p><p>ol这个东西用的不多，如果想表达顺序，大家一般也用ul。举例如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>1. 小苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>2. 月亮之上<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>3. 最炫民族风<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、定义列表-lt-dl-gt"><a href="#3、定义列表-lt-dl-gt" class="headerlink" title="3、定义列表&lt;dl&gt;"></a>3、定义列表<code>&lt;dl&gt;</code></h2><blockquote><p>定义列表的作用非常大。</p></blockquote><p><code>&lt;dl&gt;</code>英文单词：definition list，没有属性。dl的子元素只能是dt和dd。</p><ul><li><code>&lt;dt&gt;</code>：definition title 列表的标题，这个标签是必须的</li><li><code>&lt;dd&gt;</code>：definition description 列表的列表项，如果不需要它，可以不加</li></ul><p>备注：dt、dd只能在dl里面；dl里面只能有dt、dd。</p><p>举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>第一条<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>你若是觉得你有实力和我玩，良辰不介意奉陪到底<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>我会让你明白，我从不说空话<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>我是本地的，我有一百种方式让你呆不下去；而你，无可奈何<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>第二条<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>良辰最喜欢对那些自认能力出众的人出手<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>你可以继续我行我素，不过，你的日子不会很舒心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>你只要记住，我叫叶良辰<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>不介意陪你玩玩<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>良辰必有重谢<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义列表表达的语义是两层：</p><ul><li>（1）是一个列表，列出了几个dd项目</li><li>（2）每一个词儿都有自己的描述项。</li></ul><p>备注：dd是描述dt的</p><p>定义列表用法非常灵活，可以一个dt配很多dd：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>国家首都，政治文化中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>污染很严重，PM2.0天天报表<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>上海<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>魔都，有外滩、东方明珠塔、黄浦江<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>广州<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>中国南大门，有珠江、小蛮腰<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以拆开，让每一个dl里面只有一个dt和dd，这样子感觉清晰一些：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>北京<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>国家首都，政治文化中心<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>污染很严重，PM2.0天天报表<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>上海<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>魔都，有外滩、东方明珠塔、黄浦江<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>广州<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>中国南大门，有珠江、小蛮腰<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真实案例：（京东最下方）</p><p><img src="http://img.smyhvae.com/20170704_1727.png" alt></p><p>上图中的结构如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>购物指南<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>购物流程<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>会员介绍<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>生活旅行/团购<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>常见问题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>大家电<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>联系客服<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>配送方式<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>上门自提<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>211限时达<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>配送服务查询<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>配送费收取标准<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>海外配送<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>京东商品分类如下：</p><p><img src="http://img.smyhvae.com/20170704_1729.png" alt></p><blockquote><p>dt、dd都是容器级标签，想放什么都可以。所以，现在就应该更加清晰的知道：用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。</p></blockquote><h1 id="六、表格标签"><a href="#六、表格标签" class="headerlink" title="六、表格标签"></a>六、表格标签</h1><p>表格标签用<code>&lt;table&gt;</code>表示。<br>一个表格<code>&lt;table&gt;</code>是由每行<code>&lt;tr&gt;</code>组成的，每行是由每个单元格<code>&lt;td&gt;</code>组成的。<br>所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。<br>在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。</p><p>例如，一行的单元格：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的表格中没有加文字，所以在生成的网页中什么都看不到。<br>例如，3行4列的单元格：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>许嵩<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>29<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>安徽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>邓紫棋<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>香港<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>&lt;table&gt;</code>的属性：</strong></p><ul><li><p><code>border</code>：边框。像素为单位。</p></li><li><p><code>style=&quot;border-collapse:collapse;&quot;</code>：单元格的线和表格的边框线合并（表格的两边框合并为一条）</p></li><li><p><code>width</code>：宽度。像素为单位。</p></li><li><p><code>height</code>：高度。像素为单位。</p></li><li><p><code>bordercolor</code>：表格的边框颜色。</p></li><li><p><code>align</code>：<strong>表格</strong>的水平对齐方式。属性值可以填：left right center。<br>注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签<code>&lt;td&gt;</code>进行设置）</p></li><li><p><code>cellpadding</code>：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。<br>注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性<code>dir=&quot;rtl&quot;</code>，那就指的是内容到右边那条线的距离。</p></li><li><p><code>cellspacing</code>：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0</p></li><li><p><code>bgcolor=&quot;#99cc66&quot;</code>：表格的背景颜色。</p></li><li><p><code>background=&quot;路径src/...&quot;</code>：背景图片。<br>背景图片的优先级大于背景颜色。</p></li><li><p><code>bordercolorlight</code>：表格的上、左边框，以及单元格的右、下边框的颜色</p></li><li><p><code>bordercolordark</code>：表格的右、下边框，以及单元格的上、左的边框的颜色<br>这两个属性的目的是为了设置3D的效果。</p></li><li><p><code>dir</code>：公有属性，单元格内容的排列方式(direction)。 可以 取值：<code>ltr</code>：从左到右（left to right，默认），<code>rtl</code>：从右到左（right to left）<br>既然说<code>dir</code>是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。备注：表格中很细表格边线的制作，CSS的写法：</p><pre class="line-numbers language-css"><code class="language-css">style=<span class="token string">"border-collapse:collapse;"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="lt-tr-gt-：行"><a href="#lt-tr-gt-：行" class="headerlink" title="&lt;tr&gt;：行"></a><code>&lt;tr&gt;</code>：行</h3><p>一个表格就是一行一行组成的。</p><p><strong>属性：</strong></p><ul><li><code>dir</code>：公有属性，设置这一行单元格内容的排列方式。可以取值：</li><li><code>ltr</code>：从左到右（left to right，默认）<ul><li><code>rtl</code>：从右到左（right to left）</li></ul></li><li><code>bgcolor</code>：设置这一行的单元格的背景色。<br>注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。</li><li><code>height</code>：一行的高度</li><li><code>align=&quot;center&quot;</code>：一行的内容水平居中显示，取值：left、center、right</li><li><code>valign=&quot;center&quot;</code>：一行的内容垂直居中，取值：top、middle、bottom</li></ul><h3 id="lt-td-gt-：单元格"><a href="#lt-td-gt-：单元格" class="headerlink" title="&lt;td&gt;：单元格"></a><code>&lt;td&gt;</code>：单元格</h3><p><strong>属性：</strong></p><ul><li><code>align</code>：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。</li><li><code>valign</code>：内容的纵向对齐方式。属性值可以填：top middle bottom</li><li><code>width</code>：绝对值或者相对值(%)</li><li><code>height</code>：单元格的高度</li><li><code>bgcolor</code>：设置这个单元格的背景色。</li><li><code>background</code>：设置这个单元格的背景图片。</li></ul><h3 id="单元格的合并"><a href="#单元格的合并" class="headerlink" title="单元格的合并"></a>单元格的合并</h3><p>单元格的属性：</p><ul><li><code>colspan</code>：横向合并。例如<code>colspan=&quot;2&quot;</code>表示当前单元格在水平方向上要占据两个单元格的位置。</li><li><code>rowspan</code>：纵向合并。例如<code>rowspan=&quot;2&quot;</code>表示当前单元格在垂直方向上要占据两个单元格的位置。</li></ul></li></ul><h2 id="lt-th-gt-：加粗的单元格。相当于-lt-td-gt-lt-b-gt"><a href="#lt-th-gt-：加粗的单元格。相当于-lt-td-gt-lt-b-gt" class="headerlink" title="&lt;th&gt;：加粗的单元格。相当于&lt;td&gt; + &lt;b&gt;"></a><code>&lt;th&gt;</code>：加粗的单元格。相当于<code>&lt;td&gt;</code> + <code>&lt;b&gt;</code></h2><ul><li>属性同<code>&lt;td&gt;</code>标签。</li></ul><h2 id="lt-caption-gt-：表格的标题。使用时和tr标签并列"><a href="#lt-caption-gt-：表格的标题。使用时和tr标签并列" class="headerlink" title="&lt;caption&gt;：表格的标题。使用时和tr标签并列"></a><code>&lt;caption&gt;</code>：表格的标题。使用时和<code>tr</code>标签并列</h2><ul><li>属性：<code>align</code>，表示标题相对于表格的位置。属性取值可以是：left、center、right、top、bottom</li></ul><h2 id="表格的-lt-thead-gt-标签、-lt-tbody-gt-标签、-lt-tfoot-gt-标签"><a href="#表格的-lt-thead-gt-标签、-lt-tbody-gt-标签、-lt-tfoot-gt-标签" class="headerlink" title="表格的&lt;thead&gt;标签、&lt;tbody&gt;标签、&lt;tfoot&gt;标签"></a>表格的<code>&lt;thead&gt;</code>标签、<code>&lt;tbody&gt;</code>标签、<code>&lt;tfoot&gt;</code>标签</h2><p>这三个标签有与没有的区别：</p><ul><li>1、如果写了，那么这三个部分的<strong>代码顺序可以任意</strong>，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。</li><li>2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么<strong>数据可以边获取边显示</strong>。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。</li></ul><h1 id="七、-框架标签"><a href="#七、-框架标签" class="headerlink" title="七、 框架标签"></a>七、 框架标签</h1><p>如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。</p><blockquote><ul><li>注意，框架标签不能放在<code>&lt;body&gt;</code>标签里面，因为<code>&lt;body&gt;</code><strong>标签代表的只是一个页面，而框架标签代表的是多个页面。于是：<code>&lt;frameset&gt;</code>和<code>&lt;body&gt;</code>只能二选一</strong>。</li><li>框架的集合用<code>&lt;frameset&gt;</code>表示，然后在<code>&lt;frameset&gt;</code>集合里放入一个一个的框架<code>&lt;frame&gt;</code></li></ul></blockquote><h2 id="lt-frameset-gt-：框架的集合"><a href="#lt-frameset-gt-：框架的集合" class="headerlink" title="&lt;frameset&gt;：框架的集合"></a><code>&lt;frameset&gt;</code>：框架的集合</h2><p>一个框架的集合可以包含多个框架或框架的集合。<strong>属性：</strong></p><ul><li><code>rows</code>：水平分割，将框架分为上下部分。写法有两种：</li></ul><p>1、绝对值写法：<code>rows=&quot;200,*&quot;</code>  其中<code>*</code>代表剩余的。这里其实包含了两个框架：上面的框架占200个像素，下面的框架占剩下的部分。</p><p>2、相对值写法：<code>rows=&quot;30%,*&quot;</code>  其中<code>*</code>代表剩余的。这里其实包含了两个框架：上面的框架占30%，下面的框架占70%。</p><p>注：如果你想将框架分成很多行，在属性值里用逗号隔开就行了。</p><ul><li><code>cols</code>：垂直分割，将框架分为左右部分。写法有两种：</li></ul><p>1、绝对值写法：<code>cols=&quot;200,*&quot;</code>  其中<code>*</code>代表剩余的。这里其实包含了两个框架：左边的框架占200个像素，右边的框架占剩下的部分。</p><p>2、相对值写法：<code>cols=&quot;30%,*&quot;</code>  其中<code>*</code>代表剩余的。这里其实包含了两个框架：左边的框架占30%，右边的框架占70%。</p><p>注：如果你想将框架分成很多列，在属性值里用逗号隔开就行了。</p><h2 id="lt-frame-gt-：框架"><a href="#lt-frame-gt-：框架" class="headerlink" title="&lt;frame&gt;：框架"></a><code>&lt;frame&gt;</code>：框架</h2><p>一个框架显示一个页面。</p><p><strong>属性：</strong></p><ul><li><code>scrolling=&quot;no&quot;</code>：是否需要滚动条。默认值是true。</li><li><code>noresize</code>：不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的，这样的话，框架大小就不固定了。如果用了这个属性值，框架大小将固定。</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>frame</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.html<span class="token punctuation">"</span></span> <span class="token attr-name">noresize</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>frame</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>bordercolor=&quot;#00FF00&quot;</code>：给框架的边框定义颜色。这个属性在框架集合<code>&lt;frameset&gt;</code>中同样适用。<br>颜色这个属性在IE浏览器中生效，但是在google浏览器中无效，不知道为啥。</li><li><code>frameborder=&quot;0&quot;</code>或<code>frameborder=&quot;1&quot;</code>：隐藏或显示边框（框架线）。</li><li><code>name</code>：给框架起一个名字。</li></ul><p>利用<code>name</code>这个属性，我们可以在框架里进行超链。</p><h2 id="lt-iframe-gt-：内嵌框架"><a href="#lt-iframe-gt-：内嵌框架" class="headerlink" title="&lt;iframe&gt;：内嵌框架"></a><code>&lt;iframe&gt;：</code>内嵌框架</h2><p>内嵌框架用<code>&lt;iframe&gt;</code>表示。<code>&lt;iframe&gt;</code>是<code>&lt;body&gt;</code>的子标记。</p><p>内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。</p><p><strong>属性：</strong></p><ul><li><code>src=&quot;subframe/the_second.html&quot;</code>：内嵌的那个页面</li><li><code>width=800</code>：宽度</li><li><code>height=“150</code>：高度</li><li><code>scrolling=&quot;no&quot;</code>：是否需要滚动条。默认值是true。</li><li><code>name=&quot;mainFrame&quot;</code>：窗口名称。公有属性。</li></ul><h1 id="八、表单标签"><a href="#八、表单标签" class="headerlink" title="八、表单标签"></a>八、表单标签</h1><p>表单标签用<code>&lt;form&gt;</code>表示，用于与服务器的交互。表单就是收集用户信息的，就是让用户填写的、选择的。</p><p><strong>属性：</strong></p><ul><li><code>name</code>：表单的名称，用于JS来操作或控制表单时使用；</li><li><code>id</code>：表单的名称，用于JS来操作或控制表单时使用；</li><li><code>action</code>：指定表单数据的处理程序，一般是PHP，如：action=“login.php”</li><li><code>method</code>：表单数据的提交方式，一般取值：get(默认)和post</li></ul><p>注意：表单和表格嵌套时，是在<form>标记中套<table>标记。</table></form></p><p>form标签里面的action属性和method属性，在《Ajax》课程上给大家讲解。稍微说一下：action属性就是表示，表单将提交到哪里。 method属性表示用什么HTTP方法提交，有get、post两种。</p><p><strong>get提交和post提交的区别：</strong></p><p>GET方式：<br>将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。<br>特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。</p><p>POST方式：<br>将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。<br>特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。</p><p><strong>Enctype：</strong><br>表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。</p><ul><li>Application/x-www-form-urlencoded：<strong>默认</strong>加密方式，除了上传文件之外的数据都可以</li><li>Multipart/form-data：<strong>上传附件时，必须使用这种编码方式</strong>。</li></ul><h2 id="lt-input-gt-：输入标签（文本框）"><a href="#lt-input-gt-：输入标签（文本框）" class="headerlink" title="&lt;input&gt;：输入标签（文本框）"></a><code>&lt;input&gt;</code>：输入标签（文本框）</h2><p>用于接收用户输入。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>属性：</strong></p><ul><li><strong><code>type=&quot;属性值&quot;</code></strong>：文本类型。属性值可以是：<ul><li><code>text</code>（默认）</li><li><code>password</code>：密码类型</li><li><code>radio</code>：单选按钮，名字相同的按钮作为一组进行单选（单选按钮，天生是不能互斥的，如果想互斥，必须要有相同的name属性。name就是“名字”。<br>）。非常像以前的收音机，按下去一个按钮，其他的就抬起来了。所以叫做radio。</li><li><code>checkbox</code>：多选按钮，<strong>name 属性值相同的按钮</strong>作为一组进行选择。</li><li><code>checked</code>：将单选按钮或多选按钮默认处于选中状态。当<code>&lt;input&gt;</code>标签的<code>type=&quot;radio&quot;</code>时，可以用这个属性。属性值也是checked，可以省略。</li><li><code>hidden</code>：隐藏框，在表单中包含不希望用户看见的信息</li><li><code>button</code>：普通按钮，结合js代码进行使用。</li><li><code>submit</code>：提交按钮，传送当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字。这个按钮真的有提交功能。点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。</li><li><code>reset</code>：重置按钮，清空当前表单的内容，并设置为最初的默认值</li><li><code>image</code>：图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。</li><li><code>file</code>：文件选择框。<br>提示：如果要限制上传文件的类型，需要配合JS来实现验证。对上传文件的安全检查：一是扩展名的检查，二是文件数据内容的检查。</li></ul></li><li><strong><code>value=&quot;内容&quot;</code></strong>：文本框里的默认内容（已经被填好了的）</li><li><code>size=&quot;50&quot;</code>：表示文本框内可以显示<strong>五十个字符</strong>。一个英文或一个中文都算一个字符。<br>注意<strong>size属性值的单位不是像素哦</strong>。</li><li><code>readonly</code>：文本框只读，不能编辑。因为它的属性值也是readonly，所以属性值可以不写。<br>用了这个属性之后，在google浏览器中，光标点不进去；在IE浏览器中，光标可以点进去，但是文字不能编辑。</li><li><code>disabled</code>：文本框只读，不能编辑，光标点不进去。属性值可以不写。</li></ul><blockquote><p>备注：HTML5中，input的类型又增加了很多（比如date、color，我们会在 html5 中讲到）。</p></blockquote><p><strong>举例</strong>：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        姓名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>呵呵<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>逗比<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        昵称：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>哈哈<span class="token punctuation">"</span></span> <span class="token attr-name">readonly</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        名字：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        性别：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>male<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gender<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio2<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>female<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        爱好：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>love<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>eat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>吃饭              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>love<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sleep<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>睡觉              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>love<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>打豆豆    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意，多个个单选框的input标签中，name 的属性值可以相同，但是 <strong>id 的属性值必须是唯一的</strong>。我们知道，html的标签中，id的属性值是唯一的。</p></blockquote><p><strong>四种按钮的举例</strong>：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>普通按钮<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交按钮<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>重置按钮<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>图片按钮1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>image<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>800<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>图片按钮2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>文件选择框<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lt-select-gt-：下拉列表标签"><a href="#lt-select-gt-：下拉列表标签" class="headerlink" title="&lt;select&gt;：下拉列表标签"></a><code>&lt;select&gt;</code>：下拉列表标签</h2><p><code>&lt;select&gt;</code>标签里面的每一项用<code>&lt;option&gt;</code>表示。select就是“选择”，option“选项”。</p><p>select标签和ul、ol、dl一样，<strong>都是组标签</strong>。</p><p><strong><code>&lt;select&gt;</code>标签的属性：</strong></p><ul><li><code>multiple</code>：可以对下拉列表中的选项进行多选。没有属性值。</li><li><code>size=&quot;3&quot;</code>：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。</li></ul><p><strong><code>&lt;option&gt;</code>标签的属性：</strong></p><ul><li><code>selected</code>：预选中。没有属性值。</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>小学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>初中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>高中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>大学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>研究生<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>小学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>初中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>高中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>大学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>研究生<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">multiple</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>小学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>初中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>高中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>大学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>研究生<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lt-textare-gt-标签：多行文本输入框"><a href="#lt-textare-gt-标签：多行文本输入框" class="headerlink" title="&lt;textare&gt;标签：多行文本输入框"></a><code>&lt;textare&gt;</code>标签：多行文本输入框</h2><p>text就是“文本”，area就是“区域”。</p><p><strong>属性：</strong></p><ul><li><code>value</code>：提交给服务器的值。</li><li><code>rows=&quot;4&quot;</code>：指定文本区域的行数。</li><li><code>cols=&quot;20&quot;</code>：指定文本区域的列数。</li><li><code>readonly</code>：只读。</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>txtInfo<span class="token punctuation">"</span></span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1、不爱摄影不懂设计的程序猿不是一个好的产品经理。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上方代码解释：textarea这个标签，是个标签对儿。对儿里面不用写东西。如果写的话，就是这个框的默认文字。</p><h2 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt;标签"></a><code>&lt;label&gt;</code>标签</h2><p>我们先来看下面一段代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> 男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> 女<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于上面这样的单选框，我们只有点击那个单选框（小圆圈）才可以选中，点击“男”、“女”这两个文字时是无法选中的；于是，label标签派上了用场。</p><p>本质上来讲，“男”、“女”这两个文字和input标签时没有关系的，而label就是解决这个问题的。我们可以通过label把input和汉字包裹起来作为整体。</p><p>解决方法如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nan<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nv<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上方代码中，让label标签的<strong>for 属性值</strong>，和 input 标签的 <strong>id 属性值相同</strong>，那么这个label和input就有绑定关系了。</p><p>当然了，复选框也有label：（<strong>任何表单元素都有label</strong>）</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kk<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kk<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>10天内免登陆<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="九、多媒体标签"><a href="#九、多媒体标签" class="headerlink" title="九、多媒体标签"></a>九、多媒体标签</h1><p><strong>声明：</strong><br>多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。<br>.wmv、.dat、.mob、.rmvb等视频格式，在网页上不能直接播放，需要安装第三方的插件，才可以播放。不同的浏览器，播客上述视频格式，所使用插件参数又不一样。<br>上述格式视频一般文件较大，不利于网络下载播放。<br>一般情况下，是将其它的视频格式，转成Flash来在网页上播放。转换软件：格式工厂等。<br>Flash格式的视频兼容性非常好，Flash格式的文件很小。</p><h2 id="lt-bgsound-gt-标签：播放背景音乐"><a href="#lt-bgsound-gt-标签：播放背景音乐" class="headerlink" title="&lt;bgsound&gt;标签：播放背景音乐"></a><code>&lt;bgsound&gt;</code>标签：播放背景音乐</h2><p><strong>属性：</strong></p><ul><li><code>src=&quot;音乐文件的路径&quot;</code></li><li><code>loop=&quot;-1&quot;</code>：属性值代表播放次数，-1代表循环播放。</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bgsound</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>王菲 - 清风徐来.mp3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bgsound</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行效果：<br>打开网页后，在IE 8中播放正常，播放时网页上显示一片空白。在google浏览器中无法播放。</p><h2 id="lt-embed-gt-标签：播放多媒体文件（音频、视频等）"><a href="#lt-embed-gt-标签：播放多媒体文件（音频、视频等）" class="headerlink" title="&lt;embed&gt;标签：播放多媒体文件（音频、视频等）"></a><code>&lt;embed&gt;</code>标签：<strong>播放多媒体文件（音频、视频等）</strong></h2><p>主要应用Netscape浏览器，它不是W3C规范。</p><blockquote><p>备注：视频格式可以支持 mp4、wav等，但不是所有视频格式都支持。</p></blockquote><p><strong>属性：</strong></p><ul><li><code>src=&quot;多媒体文件的路径&quot;</code></li><li><code>loop=&quot;-1&quot;</code>：属性值代表播放次数，-1代表循环播放。</li><li><code>autostart=&quot;false&quot;</code>：打开网页时，禁止自动播放。默认值是true。</li><li><code>volume=&quot;100&quot;</code>：设置默认的音量大小，测试发现这个值好像不起作用哦。</li><li><code>width</code>：指Flash文件的宽度</li><li><code>height</code>：指Flash文件的高度</li><li><code>quality</code>：指Flash的播放质量，质量有高有低 hight  low</li><li><code>pluginspage</code>：如果指定的Flash插件不存在，则从pluginspage指定的地方进行下载。</li><li><code>type</code>：指定Flash的文件格式类型</li><li><code>wmode</code>：指Flash的背景是否可以透明，取值：transparent是透明的</li></ul><p><code>&lt;embed&gt;</code>标签播放音频举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>embed</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>王菲 - 清风徐来.mp3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>embed</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="lt-object-gt-标签：播放多媒体文件（音频、视频等）"><a href="#lt-object-gt-标签：播放多媒体文件（音频、视频等）" class="headerlink" title="&lt;object&gt;标签：播放多媒体文件（音频、视频等）"></a><code>&lt;object&gt;</code>标签：播放多媒体文件（音频、视频等）</h2><p>主要应用IE浏览器，它是W3C规范。</p><p><strong>属性：</strong></p><ul><li><code>classid</code>：指定Flash插件的ID号，一般存在于注册表中。</li><li><code>codebase</code>：如果Flash插件不存在，则从codebase指定的地址下载。</li><li><code>&lt;param&gt;</code>标签的主要作用：设置具体的详细参数。</li></ul><p><strong>总结：在网页中插入Flash时，为了同时兼容多种浏览器，需要将<code>&lt;object&gt;</code>标签和<code>&lt;embed&gt;</code>标签标记一起使用，但使用的顺序是：<code>&lt;object&gt;</code>中嵌套<code>&lt;embed&gt;</code>标记。</strong><br>举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">classid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clsid:D27CDB6E-AE6D-11cf-96B8-444553540000<span class="token punctuation">"</span></span> <span class="token attr-name">codebase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version<span class="token punctuation">=</span>6,0,29,0<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>778<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>202<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movie<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>images/banner.swf<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>quality<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>high<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wmode<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transparent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>embed</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>images/banner.swf<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>778<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>202<span class="token punctuation">"</span></span> <span class="token attr-name">quality</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>high<span class="token punctuation">"</span></span> <span class="token attr-name">pluginspage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.macromedia.com/go/getflashplayer<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>application/x-shockwave-flash<span class="token punctuation">"</span></span> <span class="token attr-name">wmode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>transparent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>embed</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lt-marquee-gt-：滚动字幕标签"><a href="#lt-marquee-gt-：滚动字幕标签" class="headerlink" title="&lt;marquee&gt;：滚动字幕标签"></a><code>&lt;marquee&gt;</code>：滚动字幕标签</h2><p>如果在这个标签里设置了内容，那么，打开网页时，内容会像弹幕一样自动移动。<br><strong>属性：</strong></p><ul><li><code>direction=&quot;right&quot;</code>：移动的目标方向。属性值可以是：<code>left</code>（从右向左移动，默认值）、<code>right</code>（从左向右移动）、<code>up</code>（从下向上移动）、<code>down</code>（从上向下移动）。</li><li><code>behavior=&quot;slide&quot;</code>：行为方式。属性值可以是：<code>slide</code>（只移动一次）、<code>scroll</code>（循环移动，默认值）、<code>alternate</code>（循环移动）、。<br><code>alternate</code>和<code>scroll</code>属性值都是循环移动，区别在于：假设在<code>direction=&quot;right&quot;</code>的情况下，<code>behavior=&quot;scroll&quot;</code>表示从左到右、从左到右、从左到右···<code>behavior=&quot;alternate&quot;</code>表示从左到右、从右到左、从左到右···</li><li><code>scrollamount=&quot;30&quot;</code>：移动的速度</li><li><code>loop=&quot;3&quot;</code>: 循环多少圈。负值表示无限循环</li><li><code>scrolldelay=&quot;1000&quot;</code>：移动一次休息多长时间。单位是毫秒。</li></ul><p>举例：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>marquee</span> <span class="token attr-name">behavior</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alternate<span class="token punctuation">"</span></span> <span class="token attr-name">direction</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>down<span class="token punctuation">"</span></span>  <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#8c5dc1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我来了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>marquee</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="html废弃标签介绍"><a href="#html废弃标签介绍" class="headerlink" title="html废弃标签介绍"></a>html废弃标签介绍</h1><blockquote><p>HTML现在只负责语义，而不负责样式。但是HTML一开始，连样式也包办了。这些样式的标签，都已经被废弃。</p></blockquote><p>2004年之前的东西：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>9<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面这些标签都是css钩子，而不是原意：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>加粗<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">></span></span>下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>倾斜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>强调<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>强调<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这些标签，是有着浓厚的样式的作用，干涉了css的作用，所以HTML抛弃了他们。</strong></p><p>类似的还有水平线标签：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>换行标签：</p><pre><code>&lt;br /&gt;</code></pre><p>但是，网页中99.9999%需要换行的时候，<strong>是因为另起了一个段落，所以要用p，而不要用<code>&lt;br /&gt;</code>。不到万不得已，不要用br标签</strong>。</p><blockquote><p>标准的div+css页面，只会用到种类很少的标签：</p><pre><code>div  p  h1  span   a   img   ul   ol    dl    input</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 性能调试 Instrument只有地址显示，关联不了源代码？</title>
      <link href="/2017/10/15/2017/10/Xcode%20%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%20Instrument%E5%8F%AA%E6%9C%89%E5%9C%B0%E5%9D%80%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%85%B3%E8%81%94%E4%B8%8D%E4%BA%86%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9F/"/>
      <url>/2017/10/15/2017/10/Xcode%20%E6%80%A7%E8%83%BD%E8%B0%83%E8%AF%95%20Instrument%E5%8F%AA%E6%9C%89%E5%9C%B0%E5%9D%80%E6%98%BE%E7%A4%BA%EF%BC%8C%E5%85%B3%E8%81%94%E4%B8%8D%E4%BA%86%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在做iOS性能调优的时候，肯定会用到Instrument。之前都用得好好的，可以定位到具体的代码段执行了多长时间。但这次抽风似的，无论如何都不能再Xcode看到源码。网上也没找到很好的解决方法。</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>只有知道了原理我们才可能找到解决办法。为什么在Instrument能够统计代码执行的时间，消耗的资源等等。根本原因在于DSYM文件。</p><blockquote><p>dSYM 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件。简单来讲dSYM是我们打的包和源代码之间的桥梁，通过dSYM我们能够查到崩溃日志对应哪几行，执行对应是哪段代码。</p></blockquote><p>顺便说说Xcode中的Organize。如果设备打开了日志收集功能，我们可以看到里面的崩溃信息，点击右边的Open in Project，可以直接定位到崩溃代码位置。<br><img src="http://upload-images.jianshu.io/upload_images/664334-78b5cd3203168d18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里的原理同样是DSYM文件起的作用，每次发布release包，都会生成一个dsym文件。路径是：<code>~/Library/Developer/Xcode/Archives</code></p><p><img src="http://upload-images.jianshu.io/upload_images/664334-8ddedf900cc4dc5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>显示<code>*.xarchive</code>包内容就能看到如下内容。<br><img src="http://upload-images.jianshu.io/upload_images/664334-6af8a055234ac12c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>知道了原理就容易找到解决问题的办法。</p><h2 id="一、确保生成了dsym文件"><a href="#一、确保生成了dsym文件" class="headerlink" title="一、确保生成了dsym文件"></a>一、确保生成了dsym文件</h2><p>在buildsetting 里面找到<code>Debug Information Format</code>，看看是否是如下设置</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-9c2901c77ecd05ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="二、自定义dsym文件、二进制文件搜索路径"><a href="#二、自定义dsym文件、二进制文件搜索路径" class="headerlink" title="二、自定义dsym文件、二进制文件搜索路径"></a>二、自定义dsym文件、二进制文件搜索路径</h2><p>如果上面的方法还是不能解决，那就得用这种方法。</p><blockquote><p>这个问题也是很奇葩，我是在Xcode9中发现这个问题，猜测跟自己之前改变了Derived Data的路径，导致Xcode找不到对应的路径有关。现在只需要设置好路径即可，不过这步骤也是有点麻烦。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/664334-ef5b3c1f044817f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>点击Record</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/664334-8f0be5c27de3e2c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>关闭Record、打开File、选择Symbol</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/664334-bcd33cdc124db877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>查看路径</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/664334-6c09ce3b298933e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>很明显可以看到这里的路径不对，是红色的，也就是没找到。</p><ul><li>设置好对应的路径</li></ul><p>这里举个例子。找到<code>*.app</code>对应二进制文件路径，<code>*.app.dsym</code>对应dsym路径</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-2f3ecdb0658cb1b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>然后在重新Record。之后就能看到了人头像了</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/664334-5beaf2f6a375fec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://www.cocoachina.com/ios/20141219/10694.html" target="_blank" rel="noopener">dSYM 文件分析工具</a><br><a href="http://www.cocoachina.com/ios/20160805/17300.html" target="_blank" rel="noopener">instrument Time Profiler总结</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次引入第三方库的坑</title>
      <link href="/2017/09/03/2017/9/iOS%E9%9B%86%E6%88%90%E4%B8%89%E6%96%B9SDK%E7%9A%84%E5%9D%91/"/>
      <url>/2017/09/03/2017/9/iOS%E9%9B%86%E6%88%90%E4%B8%89%E6%96%B9SDK%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>最近这段时间，一直在研究webrtc，写iOS的时间很少，但是项目催得急，所以今天做了点iOS的工作。集成SDK本应该是很简单的一件事情，但当集成到一个维护长达五年的项目中，问题就多得一批。这里就顺便把常见的坑总结下。</p><a id="more"></a><h2 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h2><p>笔者这里的小坑大都是指不需要我们改很多东西的情况，比如价格flag，或者设置一下search path之类的。</p><h3 id="NSAppTransportSecurity"><a href="#NSAppTransportSecurity" class="headerlink" title="NSAppTransportSecurity"></a>NSAppTransportSecurity</h3><p>如果需要集成的SDK做得并不是那么好，很有可能在请求http的时候不成功。这个时候需要在plists文件设置一下，暂时退回到http协议。</p><ol><li>在项目的info.plist中添加一个Key：NSAppTransportSecurity，类型为字典类型。</li><li>然后给它添加一个Key：NSAllowsArbitraryLoads，类型为Boolean类型，值为YES</li></ol><h3 id="pod-本地仓库太旧了或者pod-search-搜索不到相关库"><a href="#pod-本地仓库太旧了或者pod-search-搜索不到相关库" class="headerlink" title="pod 本地仓库太旧了或者pod search 搜索不到相关库"></a>pod 本地仓库太旧了或者pod search 搜索不到相关库</h3><p>比如在执行pod install的时候出现找不到，比如什么头文件找不到之类的。解决办法就是升级下pod库</p><h3 id="unrecognized-selector-sent-to-instance"><a href="#unrecognized-selector-sent-to-instance" class="headerlink" title="unrecognized selector sent to instance"></a>unrecognized selector sent to instance</h3><p>很多时候这个问题是因为分类的问题。解决办法：<br>工程—&gt;Building Setting ——》Linking———&gt;other linker flags 添加 -ObjC 或者-all_load</p><h3 id="文件件-h找不到"><a href="#文件件-h找不到" class="headerlink" title="文件件.h找不到"></a>文件件.h找不到</h3><p>直接在Building Setting里面设置搜索路径。比如在有同学在集成支付宝的时候就经常遇到：<br><img src="http://upload-images.jianshu.io/upload_images/664334-47d807dcf434737f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>解决办法：<br><img src="http://upload-images.jianshu.io/upload_images/664334-0e3ab806ef2446e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="大坑"><a href="#大坑" class="headerlink" title="大坑"></a>大坑</h2><p>这里的大坑就是并不那么简单的就可以解决的，至少需要你去了解下一些基本原理才能搞定的。</p><h3 id="Undefined-symbols-for-architecture-xxx"><a href="#Undefined-symbols-for-architecture-xxx" class="headerlink" title="Undefined symbols for architecture xxx"></a>Undefined symbols for architecture xxx</h3><p>这个问题大部分情况下还是比较好解决的，解决思路大致分为如下几个：</p><ol><li><p>大部分情况下是忘记添加了某个系统framework或dylib，比如你在项目中使用了sqlite3，但是没有添加libsqlite3.dylib，就会出现这个问题。解决办法是增加对应的framework或dylib。</p></li><li><p>如果是在C++里调用C函数，检查是否有添加extern “C”，这可以通过观察错误提示中的函数名形式来决定，如果是C函数而以C ++的方式调用就需要添加extern “C”。</p></li><li><p>如果是把其它工程的xcodeproj文件加入到当前项目中，检查Build Phases中的Target Dependencies有没有添加依赖，以及General中的Linked Frameworks and Libraries有没有添加相关的.a文件。 </p></li><li><p>如果添加.a文件编译无错而添加xcodeproj文件编译出错可参考3</p></li><li><p>如果添加.a文件编译出错，首先检查其对应的头文件是否添加正确，或者在Build Setting中有没有添加对应的Header Search Path路径；其次检查.a文件的c++编译选项与当前项目的c++编译选项是否一致；最后检查.a文件与当前项目的CPU架构信息是否一致</p></li><li><p>如果是使用了静态库，真机Debug测试时正常，而在执行for iOS Device测试时报这个错误，很可能是因为静态库支持的架构不全。出现这种情况是Build Setting中的Build Active Architecture Only在Debug下设为Yes，从而使得真机Debug测试正常。</p><h3 id="符号文件冲突🎯"><a href="#符号文件冲突🎯" class="headerlink" title="符号文件冲突🎯"></a>符号文件冲突🎯</h3><p>特征就是出现duplicate symbol这种标志。解决方法由易到难有如下几个：</p></li><li><p>对项目buildsetting里的other linker flags进行修改。详细的方法可以看看这里<a href="http://www.cnblogs.com/rayshen/p/5160218.html" target="_blank" rel="noopener">iOS 解决一个因三方静态库冲突产生的duplicate symbol的问题</a></p></li><li><p>这个方法就是从.a中把冲突的.o删去。详细步骤如下。</p></li></ol><ul><li>查看库所包含的CPU架构<br>打开终端输入如下命令： <pre><code>cd /Users/fww/Desktop/temp lipo -info temp.a </code></pre></li></ul><p>输出结果： </p><pre><code>Architectures in the fat file: temp.a are: i386 x86_64 armv7 arm64</code></pre><ul><li>分离不同架构的静态库<br>也就是说这里将会从xxx.a中分离出i386 、x86_64、 armv7 、arm64 四个架构下的静态库，分别取名temp_i386.a,temp_x86_64.a,temp_armv7.a,temp_arm64.a: 在终端中继续输入如下命令： <pre><code>lipo -extract_family i386 -output temp_i386.a temp.a lipo -extract_family x86_64 -output temp_x86_64.a temp.a lipo -extract_family armv7 -output temp_armv7.a temp.a lipo -extract_family arm64 -output temp_arm64.a temp.a</code></pre></li></ul><p>验证：</p><pre><code>lipo -info temp_i386.a input file temp_i386.a is not a fat file Non-fat file: temp_i386.a is architecture: i386lipo -info temp_x86_64.a input file temp_x86_64.a is not a fat file Non-fat file:temp_x86_64.a is architecture: x86_64lipo -info temp_armv7.a input file temp_armv7.a is not a fat file Non-fat file: temp_armv7.a is architecture: armv7</code></pre><ul><li>删除冲突的xxx.o</li></ul><pre><code>ar -d temp_i386.a GDataXMLNode.o ar -d temp_x86_64.a GDataXMLNode.o ar -d temp_armv7.a GDataXMLNode.o ar -d temp_arm64.a GDataXMLNode.o </code></pre><ul><li>合并为新的库<br>删除冲突的库之后，将不同架构下的静态库再重新合并起来,取名：temp_new.a <pre><code>lipo -create -output temp_new.a temp_i386.a temp_x86_64.a temp_armv7.a temp_arm64.a </code></pre><h3 id="底层库比如openssl之类的冲突"><a href="#底层库比如openssl之类的冲突" class="headerlink" title="底层库比如openssl之类的冲突"></a>底层库比如openssl之类的冲突</h3>如果遇到这种问题就不能用上面讲的删除冲突的.o文件了。笔者亲自用如下方法解决了前公司一个非常大的问题。也就是在集成网易云信的时候，grpc中的boringssl和云信sdk中用到的openssl冲突了。刚开始网易云信的哥们直接说搞不定，后来在笔者亲自试验下，给网易云信的哥们说了方法，结果成功了。后来他们把这个步骤写在了官方网站上。</li></ul><p>链接[ 解决 openSSL 和 boringSSL 冲突的问题 <a href="http://bbs.netease.im/read-tid-480" target="_blank" rel="noopener"></a></p><p>当时的思路出发点是来自于动态库和静态库加载机制的不同，静态库是一开始就加载了，而动态库是在运行的时候才加载。从而错开了两者符号加载的时机。</p><p>打包动态库脚本如下：</p><pre><code>#change your project name hereproject_name=&quot;targetName&quot;#archs,include iphone (armv7, arm64) and iphone simulator (i386, x86_64)archs=&quot;armv7 armv7s arm64&quot;for arch in $archsdo    echo &quot;building $arch...&quot;    if [ &quot;$arch&quot; = &quot;i386&quot; -o &quot;$arch&quot; = &quot;x86_64&quot; ]    then    xcrun_sdk=&quot;iphonesimulator&quot;    export cflags_config=&quot;-fembed-bitcode-marker&quot;    else    xcrun_sdk=&quot;iphoneos&quot;    export cflags_config=&quot;-fembed-bitcode -Qunused-arguments&quot;    fi    xcodebuild clean build ARCHS=$arch -sdk $xcrun_sdk TARGET_BUILD_DIR=&quot;./build-$arch&quot; BUILT_PRODUCTS_DIR=&quot;./build-$arch&quot; OTHER_CFLAGS=&quot;$OTHER_CFLAGS $cflags_config&quot;donecp -rf ./build-arm64/$project_name.framework $project_name.frameworkecho &quot;generate product...&quot;lipo -create `find ./build-* -name $project_name` -output $project_name.framework/$project_nameecho &quot;clean cache...&quot;#rm -rf ./build ./build-*echo &quot;done!&quot;</code></pre><h3 id="一个库必须使用动态库use-frameworks-，另一个不能使用动态库"><a href="#一个库必须使用动态库use-frameworks-，另一个不能使用动态库" class="headerlink" title="一个库必须使用动态库use_frameworks!，另一个不能使用动态库"></a>一个库必须使用动态库use_frameworks!，另一个不能使用动态库</h3><p>今天遇到了这个蛋疼的问题。著名的加密库libsodium和集成的另一个sdk出现了这种问题。而且这个sdk依赖了一大堆其他库，比如AF，SD。</p><p><strong>由于这个SDK必须是动态库，那么最终他依赖的第三方库也必须用动态库的方式引入。</strong>这点自己弄了好了才得出这个结论。</p><p>并且有项目之前用过老版本的AF，并且还改了一大堆代码，这个库又用的新版AF。真实蛋疼。</p><p>解决办法：</p><ol><li>解决掉老版本AF和新版AF：通过重命名老版本AF所有文件，这样就彻底把老版本和新版本区分开。<strong>得出的经验是，如果你决定改第三方库源码，那就马上全部重命名，因为对你而言这个库已经不是第三方库了。</strong>。重命名的过程当然是痛苦的，因为用到的地方太多，这就是前人挖坑后人踩坑。</li><li>将libsodium打包成动态库：因为libsodium使用c语言写的，这里读者需要懂点linux/unix下的交叉编译知识。用automake来实现跨平台编译<strong>。幸好这个库已经把相关的config文件以及生成iOS平台的shell脚本写好了。**</strong>但这中间有一个严重的坑，坑，坑！**<ul><li>那就是不要去github项目主页上下载源码。因为下下来没有config文件。</li><li>应该去下打包好的项目。也就是xx.tag.xxx这种格式的。</li><li>然后下载下来，把iOS.sh从dist_build目录放到项目根目录下。</li><li>然后执行<code>sh iOS.sh</code>。过一段时间，.a库就生成好了。</li></ul></li><li>生成的.a库打包成动态库，大致步骤就是建一个动态库工程，把生成的静态库项目拖到动态库项目中。设置好需要暴露的头文件，然后用上面的脚步跑一遍。</li><li>把生成的动态库用到项目中。</li></ol><p>之所有没有把源码直接拖到项目中，尝试过但是一拖进去就一直保持。后来用这种方法简单粗暴！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归复习一</title>
      <link href="/2017/08/27/2017/8/%E9%80%92%E5%BD%92%E5%A4%8D%E4%B9%A0%E4%B8%80/"/>
      <url>/2017/08/27/2017/8/%E9%80%92%E5%BD%92%E5%A4%8D%E4%B9%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>程序 = 算法 + 数据结构 +  编程语言。回味一下这些经典的思路就当做一做思维体操！</p><a id="more"></a><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>学习递归就像是熬汤，需要慢慢来，切忌烦躁。</p><h2 id="一：什么是递归"><a href="#一：什么是递归" class="headerlink" title="一：什么是递归"></a>一：什么是递归</h2><p>所谓递归，简单点来说，就是一个函数直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p><p>我们可以把”递归“比喻成“查字典“，当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。（摘自<a href="https://www.zhihu.com/question/20507130" target="_blank" rel="noopener">知乎</a>的一个回答）</p><p>我们以阶乘作为例子（$0!=1, 1!=1, 3!=6$ ,…）：</p><pre class="line-numbers language-c++"><code class="language-c++">int Factorial(int n){    if (n == 0)        return 1;    return n * Factorial(n - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二：递归与栈的关系"><a href="#二：递归与栈的关系" class="headerlink" title="二：递归与栈的关系"></a>二：递归与栈的关系</h2><p>常常听到“递归的过程就是出入栈的过程”，这句话怎么理解？我们以上述代码为例，取$n=3$，则过程如下：</p><p><img src="http://oi0fekpsr.bkt.clouddn.com/%E9%80%92%E5%BD%92_2.png" alt></p><ul><li>第1~4步，都是入栈过程，<code>Factorial(3)</code>调用了<code>Factorial(2)</code>，<code>Factorial(2)</code>又接着调用<code>Factorial(1)</code>，直到<code>Factorial(0)</code>；</li><li>第5步，因0是递归结束条件，故不再入栈，此时栈高度为4，即为我们平时所说的递归深度；</li><li>第6~9步，<code>Factorial(0)</code>做完，出栈，而<code>Factorial(0)</code>做完意味着<code>Factorial(1)</code>也做完，同样进行出栈，重复下去，直到所有的都出栈完毕，递归结束。</li></ul><p><strong>每一个递归程序都可以把它改写为非递归版本。</strong>我们只需利用栈，通过入栈和出栈两个操作就可以模拟递归的过程，二叉树的遍历无疑是这方面的代表。</p><p><strong>但是并不是每个递归程序都是那么容易被改写为非递归的。</strong>某些递归程序比较复杂，其入栈和出栈非常繁琐，给编码带来了很大难度，而且易读性极差，所以条件允许的情况下，推荐使用递归。</p><h2 id="三：如何思考递归"><a href="#三：如何思考递归" class="headerlink" title="三：如何思考递归"></a>三：如何思考递归</h2><p>在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的验证之中，比如上面提及的阶乘，求解<code>Factorial(n)</code>时，我们总会情不自禁的发问，<code>Factorial(n-1)</code>可以求出正确的答案么？接着我们就会再用<code>Factorial(n-2)</code>去验证，，，不停地往下验证直到<code>Factorial(0)</code>。</p><p>对递归这样的不适应，和我们平时习惯的思维方式有关。我们习惯的思维是：已知<code>Factorial(0)</code>，乘上1就等于<code>Factorial(1)</code>，再乘以2就等于<code>Factorial(2)</code>，，，直到乘到n。</p><p><strong>而递归和我们的思维方式正好相反。</strong></p><p>那我们怎么判断这个递归计算是否是正确的呢？<a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%BD%97%C2%B7%E6%A0%BC%E9%9B%B7%E5%8E%84%E5%A7%86" target="_blank" rel="noopener">Paul Graham</a>提到一种方法，如下：</p><blockquote><p>如果下面这两点是成立的，我们就知道这个函数对于所有的n都是正确的。</p><ol><li>当$n=0,1​$时，结果正确；</li><li>假设递归对于$n$是正确的，同时对于$n+1$也正确。</li></ol></blockquote><p>这种方法很像数学归纳法，也是递归正确的思考方式，上述的第1点称为基本情况，第2点称为通用情况。</p><p>但是在递归中，我们通常把第1点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。</p><p>下面我们用两个例子来具体说明这种数学归纳法：</p><h5 id="例1-汉诺塔"><a href="#例1-汉诺塔" class="headerlink" title="例1 汉诺塔"></a>例1 汉诺塔</h5><p><img src="http://oi0fekpsr.bkt.clouddn.com/%E9%80%92%E5%BD%92_3.png" alt></p><p>问题描述为：有三根杆子A，B，C。A杆上有N个穿孔圆盘，盘的尺寸由上到下依次变大，B，C杆为空。要求按下列规则将所有圆盘移至C杆：</p><ol><li>每次只能移动一个圆盘；</li><li>大盘不能叠在小盘上面。</li></ol><p>问：如何移？最少要移动多少次？</p><p>首先看下基本情况，即终止条件：N=1时，直接从A移到C。</p><p>再来看下通用情况：当有N个圆盘在A上，我们已经找到办法将其移到C杠上了，我们怎么移动N+1个圆盘到C杠上呢？很简单，<strong>我们首先用将N个圆盘移动到C上的方法将N个圆盘都移动到B上</strong>，然后再把第N+1个圆盘（最后一个）移动到C上，<strong>再用同样的方法将在B杠上的N个圆盘移动到C上</strong>，问题解决。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">void Hanoi(int n, char a, char b, char c){    //终止条件    if (n == 1)    {        cout << a << "-->" << c << endl;        return;    }    //通用情况    Hanoi(n - 1, a, c, b);    Hanoi(1, a, b, c);    Hanoi(n - 1, b, a, c);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="例2-求二叉树节点个数"><a href="#例2-求二叉树节点个数" class="headerlink" title="例2 求二叉树节点个数"></a>例2 求二叉树节点个数</h5><p><img src="http://oi0fekpsr.bkt.clouddn.com/%E9%80%92%E5%BD%92_4.png" alt></p><p>首先看下基本情况，即终止条件：当为空树时，节点数为0；</p><p>再来看下通用情况：当一个节点的左，右子树节点数都被求出，则整棵树的节点数就是“左子树+右子树+1”。</p><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">int GetNodes(Node * node){    //终止条件    if (node == nullptr)        return 0;    //通用情况    return GetNodes(node->left) + GetNode(node->right) + 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四：什么时候该用递归"><a href="#四：什么时候该用递归" class="headerlink" title="四：什么时候该用递归"></a>四：什么时候该用递归</h2><p><strong>当我们遇到一个问题时，我们是怎么判断该题用递归来解决的？</strong></p><blockquote><p>问题可用递归来解决需具备的条件：</p><ol><li>子问题需与原问题为同样的事，且规模更小；</li><li>程序停止条件。</li></ol></blockquote><p>概念说的很容易，但往往事情难做，所以接下里我更想给初学者一些学习的建议。</p><p>递归这个东西，没别的办法，要想搞定它，就三个字：敲代码！</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebRtc学习资料整理</title>
      <link href="/2017/08/13/2017/8/WebRTC%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2017/08/13/2017/8/WebRTC%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>很久没有写了，尤其是技术文章，总感觉很难受。这里总结一下最近的学习内容。</p><a id="more"></a><blockquote><p>官网永远是最重要，但同时也是最容易忽略的学习途径。<strong><a href="https://webrtc.org/" target="_blank" rel="noopener">So you should look official websites firtsly.</a></strong>。</p></blockquote><p>先看一看基础概念的解释<br><a href="https://blog.mozilla.com.tw/posts/3261/webrtc-%E7%9B%B8%E9%97%9C%E7%B8%AE%E5%AF%AB%E5%90%8D%E8%A9%9E%E7%B0%A1%E4%BB%8B" target="_blank" rel="noopener">WebRTC 相關縮寫名詞簡介</a></p><p>推荐一种方式，打开官方给的例子，然后通过浏览器调试，定位到控制到就能够看到这个流程了。<a href="https://webrtc.github.io/samples/" target="_blank" rel="noopener">WebRTC samples</a><br>如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-cfd5bce5233e9cc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>Offer/Answer 與 Signal Channel 是什麼？</li></ul><p>WebRTC 必須透過某種中介伺服器才能建立連線，而我們稱這種媒介為「訊號通道 (Signal Channel)」。也就是說，在建立連線之前，會先透過訊號通道交換建立連線所需的資訊。</p><p><strong>我們所要交換的資訊就是「Offer」與「Answer」，而其內容就是上述的 SDP。</strong></p><p>當 Peer A 設立連線時，就會建立 Offer。接著會透過選定的訊號通道將此 Offer 傳送給 Peer B。在 Peer B 收到訊號通道傳來的 Offer 之後，就會建立 Answer，並透過同樣的訊號通道將 Answer 回傳給 Peer A。</p><ul><li>ICE Candidate 是什麼？</li></ul><p>如上所述，<strong>Offer/Answer 與 SDP 用以交換多媒體的格式內容；ICE candidate 則用以交換網路連線的建立方式，並可說明端點溝通的方法 (直接通訊，或透過 TURN 伺服器通訊)。</strong></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="一、WebRTC-直播时代"><a href="#一、WebRTC-直播时代" class="headerlink" title="一、WebRTC 直播时代"></a>一、<a href="https://www.villainhr.com/page/2017/02/20/WebRTC%20%E7%9B%B4%E6%92%AD%E6%97%B6%E4%BB%A3" target="_blank" rel="noopener">WebRTC 直播时代</a></h3><p><img src="http://upload-images.jianshu.io/upload_images/664334-592392ffc7d975ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="二、A-Closer-Look-Into-WebRTCwebkit添加新内容"><a href="#二、A-Closer-Look-Into-WebRTCwebkit添加新内容" class="headerlink" title="二、A Closer Look Into WebRTCwebkit添加新内容"></a>二、<a href="https://webkit.org/blog/7763/a-closer-look-into-webrtc/" target="_blank" rel="noopener">A Closer Look Into WebRTC</a>webkit添加新内容</h3><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><h3 id="一、音视频云声网Agora：从demo到实用，中间还差1万个WebRTC"><a href="#一、音视频云声网Agora：从demo到实用，中间还差1万个WebRTC" class="headerlink" title="一、音视频云声网Agora：从demo到实用，中间还差1万个WebRTC"></a>一、<a href="http://www.52im.net/article-119-1.html" target="_blank" rel="noopener">音视频云声网Agora：从demo到实用，中间还差1万个WebRTC</a></h3><p>WebRtc协议栈<br><img src="http://upload-images.jianshu.io/upload_images/664334-841ed82ea581d3c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>在这个例子中，我们将使用SIP-over-WebSocket（SIPoWS）作为信令栈。HTTP协议用于浏览器下载HTML5/JavaScript程序内容；NAT栈解决P2P连接问题；媒体栈用于发送和接收RTC的音频和视频。</p><h3 id="二、为什么要有打洞服务"><a href="#二、为什么要有打洞服务" class="headerlink" title="二、为什么要有打洞服务"></a>二、为什么要有打洞服务</h3><ul><li>IPv4用完</li><li>私有地址一致，用了同一网段，不能用内网地址，需要用外网地址。</li><li>在有防火墙和地址转换时P2P需要UDP打洞：NAT后不能直接向广域网那样IP直接连接</li><li>不是所有 NAT 网络都能打洞成功，连接就会建立失败，只能服务器中转。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="一、Webrtc服务器搭建"><a href="#一、Webrtc服务器搭建" class="headerlink" title="一、Webrtc服务器搭建"></a>一、<a href="http://www.mamicode.com/info-detail-513556.html" target="_blank" rel="noopener">Webrtc服务器搭建</a></h3><ul><li>通话的房间服务器(Room Server)</li><li>通话的信令服务器(Signaling Server)</li><li>防火墙打洞服务器(STUN/TURN/ICE Server)</li></ul><h3 id="二、iOS下音视频通信-基于WebRTC非常全面的介绍，并且有Demo。大爱，跟着demo走一遍就熟了"><a href="#二、iOS下音视频通信-基于WebRTC非常全面的介绍，并且有Demo。大爱，跟着demo走一遍就熟了" class="headerlink" title="二、iOS下音视频通信-基于WebRTC非常全面的介绍，并且有Demo。大爱，跟着demo走一遍就熟了"></a>二、<a href="http://www.jianshu.com/p/c49da1d93df4" target="_blank" rel="noopener">iOS下音视频通信-基于WebRTC</a>非常全面的介绍，并且有Demo。大爱，跟着demo走一遍就熟了</h3><p><strong>严格来说它仅仅是不需要服务端来进行数据中转而已。</strong></p><p>WebRTC至少有两件事必须要用到服务器：</p><ul><li><p>浏览器之间交换建立通信的元数据（信令）必须通过服务器。</p><ul><li>我们在A和B需要建立P2P连接的时候，至少要服务器来协调，来控制连接开始建立。而连接断开的时候，也需要服务器来告知另一端P2P连接已断开。这些我们用来控制连接的状态的数据称之为信令，而这个与服务端连接的通道，对于WebRTC而言就是信令通道。</li><li>在建立连接之前，客户端之间显然没有办法传递数据。所以我们需要通过服务器的中转，在客户端之间传递这些数据，然后建立客户端之间的点对点连接。但是WebRTC API中并没有实现这些，这些就需要我们来实现了。</li></ul></li><li><p>为了穿越NAT和防火墙。</p></li><li><p>WebRTC主要实现了三个API</p></li></ul><ol><li>MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流</li><li>RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件</li><li>RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据。<br>其中RTCPeerConnection是我们WebRTC的核心组件。</li></ol><ul><li>P2P连接的过程</li></ul><ol><li>A和B连接上服务端，建立一个TCP长连接（任意协议都可以，WebSocket/MQTT/Socket原生/XMPP），我们这里为了省事，直接采用WebSocket，这样一个信令通道就有了。</li><li>A从ice server（STUN Server）获取ice candidate并发送给Socket服务端，并生成包含session description（SDP）的offer，发送给Socket服务端。</li><li>Socket服务端把A的offer和ice candidate转发给B，<strong>B会保存下A这些信息</strong>。</li><li>然后B发送包含自己session description的answer(<strong>因为它收到的是offer，所以返回的是answer，但是内容都是SDP)和ice candidate给Socket服务端</strong>。</li><li>Socket服务端把B的answer和ice candidate给A，A保存下B的这些信息。</li></ol><h3 id="三、WebRTC-iOS-下载编译-下载指定版本"><a href="#三、WebRTC-iOS-下载编译-下载指定版本" class="headerlink" title="三、WebRTC(iOS)下载编译(下载指定版本)"></a>三、<a href="http://www.cnblogs.com/fulianga/p/5868823.html" target="_blank" rel="noopener">WebRTC(iOS)下载编译(下载指定版本)</a></h3><h4 id="点对点连接下，会导致这样一个问题："><a href="#点对点连接下，会导致这样一个问题：" class="headerlink" title="点对点连接下，会导致这样一个问题："></a>点对点连接下，会导致这样一个问题：</h4><p>如果客户端A想给客户端B发送数据，则数据来到客户端B所在的路由器下，会被NAT阻拦，这样B就无法收到A的数据了。<br>但是A的NAT此时已经知道了B这个地址，所以当B给A发送数据的时候，NAT不会阻拦，这样A就可以收到B的数据了。这就是我们进行NAT穿越的核心思路。</p><p>思路：<br>我们借助一个公网IP服务器。a、b都往公网IP/PORT发包,公网服务器就可以获知a,b的IP/PORT，又由于a,b主动给公网IP服务器发包，所以公网服务器可以穿透NAT A,NAT B送包给a,b。<br><strong>所以只要公网IP将b的IP/PORT发给a,a的IP/PORT发给b。这样下次a和b互相消息，就不会被NAT阻拦了。</strong></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="一、WebRTC入门教程-md"><a href="#一、WebRTC入门教程-md" class="headerlink" title="一、WebRTC入门教程.md"></a>一、<a href="https://github.com/ChenYilong/WebRTC/blob/master/WebRTC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/WebRTC%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.md" target="_blank" rel="noopener">WebRTC入门教程.md</a></h3><ul><li>STUN (Session Traversal Utilities for NAT) 只能UDP，告诉我暴露在广域网的地址IP port ，我通过映射的广域网地址进行P2P数据通信。</li><li>TURN( Traversal Using Relays around for NAT)UDP或TCP， 打洞失败后，提供服务器中转数据，通话双方数据都通过服务器，占服务器带宽较大 - 为了确保通话在绝大多数环境下可以正常工作。跨网只能用服务器中转（测试发现的） ，使用TURN这种情况在视频通话中占10%</li><li>ICE 网络连接服务<h3 id="二、WebRtc建立P2P链接的总体流程UML类图非常不错。"><a href="#二、WebRtc建立P2P链接的总体流程UML类图非常不错。" class="headerlink" title="二、WebRtc建立P2P链接的总体流程UML类图非常不错。"></a>二、<a href="http://blog.csdn.net/u010657219/article/details/54930821" target="_blank" rel="noopener">WebRtc建立P2P链接的总体流程</a>UML类图非常不错。</h3></li><li>链接总体流程<br><img src="http://upload-images.jianshu.io/upload_images/664334-6548972d316e790e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>时序图<br><img src="http://upload-images.jianshu.io/upload_images/664334-e99218c64e1fa731?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><ul><li>类图<br><img src="http://upload-images.jianshu.io/upload_images/664334-9be39ea2ec403d5a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="一、NAT"><a href="#一、NAT" class="headerlink" title="一、NAT"></a>一、<a href="https://baike.baidu.com/item/nat/320024?fr=aladdin" target="_blank" rel="noopener">NAT</a></h3><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。<strong>这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。</strong></p><ul><li>NAT实现方式：即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad</li><li>NAT穿透方法：目前常用的针对UDP的NAT 穿透（NAT Traversal）方法主要有：STUN、TURN、ICE、uPnP等。<strong>其中ICE方式由于其结合了STUN和TURN的特点，所以使用最为广泛。</strong>针对TCP的NAT穿透技术目前仍为难点。实用的技术仍然不多。</li><li>NAT工作原理：<strong>NAT将自动修改IP报文的源IP地址和目的IP地址</strong>，Ip地址校验则在NAT处理过程中自动完成。有些应用程序将源IP地址嵌入到IP报文的数据部分中，所以还需要同时对报文的数据部分进行修改，以匹配IP头中已经修改过的源IP地址。否则，在报文数据部分嵌入IP地址的应用程序就不能正常工作。<strong>简单来讲就是通过一个转换头，将内网地址变为公网地址，接收的时候根据记录将公网地址变成内网，完成传输。</strong></li></ul><h3 id="二、STUN"><a href="#二、STUN" class="headerlink" title="二、STUN"></a>二、<a href="https://baike.baidu.com/item/stun/3131387?fr=aladdin" target="_blank" rel="noopener">STUN</a></h3><p>是一种网络协议，<strong>它一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT 路由器之后的主机之间建立UDP通信。</strong>。目的就是找到外界连接内部地址的所需信息。</p><p>STUN是一个客户机－服务器协议。一个VoIP电话或软件包可能会包括一个STUN客户端。这个客户端会向STUN服务器发送请求，之后，<strong>服务器就会向STUN客户端报告NAT路由器的公网IP地址以及NAT为允许传入流量传回内网而开 通的端口。</strong></p><p>以上的响应同时还使得STUN客户端能够确定正在使用的NAT类型——因为不同的NAT类型处理传入的UDP分组的方式是不同的。四种主要类型中有三种是可以使用的：完全圆锥型NAT、受限圆锥型NAT和端口受限圆锥型NAT——但大型公司网络中经常采用的对称型 NAT（又称为双向NAT）则不能使用。</p><h3 id="三、STUN和TURN技术浅析-比较全面的分析"><a href="#三、STUN和TURN技术浅析-比较全面的分析" class="headerlink" title="三、STUN和TURN技术浅析  比较全面的分析"></a>三、<a href="http://www.h3c.com.cn/MiniSite/Technology_Circle/Net_Reptile/The_Five/Home/Catalog/201206/747038_97665_0.htm" target="_blank" rel="noopener">STUN和TURN技术浅析</a>  比较全面的分析</h3><blockquote><p>STUN（Simple Traversal of User Datagram Protocol Through Network Address Translators），即简单的用UDP穿透NAT，是个轻量级的协议，<strong>是基于UDP的完整的穿透NAT的解决方案。</strong>它允许应用程序发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它也可以让应用程序确定NAT分配给它们的公网IP地址和端口号。STUN是一种Client/Server的协议，也是一种Request/Response的协议，默认端口号是3478。</p></blockquote><p>在现实Internet网络环境中，大多数计算机主机都位于防火墙或NAT之后，只有少部分主机能够直接接入Internet。很多时候，<strong>我们希望网络中的两台主机能够直接进行通信，即所谓的P2P通信</strong>，而不需要其他公共服务器的中转。由于主机可能位于防火墙或NAT之后，在进行P2P通信之前，我们需要进行检测以确认它们之间能否进行P2P通信以及如何通信。这种技术通常称为NAT穿透（NAT Traversal）。最常见的NAT穿透是基于UDP的技术，如RFC3489中定义的STUN协议。</p><p>NAT对待UDP的实现方式有4种方式、简单可以理解为：</p><ol><li>随便搞，没搞过的也可以搞</li><li>只有搞过的才能搞</li><li>之前带过套的才能搞</li><li>只有搞得爽的才能搞</li></ol><p>TURN，首先在RFC5766中定义，英文全称是Traversal Using Relays around NAT:Relay Extensions to Session Traversal Utilities for NAT，<strong>即使用中继穿透NAT:STUN的扩展。</strong>简单的说，TURN与STURN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是<strong>TURN是通过两方通讯的“中间人”方式实现穿透</strong>。</p><p>如果一个主机位于NAT的后面，在某些情况下它不能够与其他主机点对点直接连接。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN协议就是用来允许主机控制中继的操作并且使用中继与对端交换数据。TURN与其他中继控制协议不同的是它能够允许一个客户端使用一个中继地址与多个对端连接。</p><h3 id="四、WebRTC-protocols"><a href="#四、WebRTC-protocols" class="headerlink" title="四、WebRTC protocols"></a>四、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Protocols" target="_blank" rel="noopener">WebRTC protocols</a></h3><h3 id="五、SDP-协议分析"><a href="#五、SDP-协议分析" class="headerlink" title="五、SDP 协议分析"></a>五、<a href="http://www.cnblogs.com/qingquan/archive/2011/08/02/2125585.html" target="_blank" rel="noopener">SDP 协议分析</a></h3><p>SDP 完全是一种会话描述格式 ― 它不属于传输协议 ― 它只使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、实时流协议（RTSP）、MIME 扩展协议的电子邮件以及超文本传输协议（HTTP）。SDP协议是也是基于文本的协议，这样就能保证协议的可扩展性比较强，这样就使其具有广泛的应用范围。SDP 不支持会话内容或媒体编码的协商，所以在流媒体中只用来描述媒体信息。</p><h3 id="六、试验UDP打洞穿透NAT"><a href="#六、试验UDP打洞穿透NAT" class="headerlink" title="六、试验UDP打洞穿透NAT"></a>六、<a href="http://www.hankcs.com/program/network/test-udp-holes-penetrating-nat.html" target="_blank" rel="noopener">试验UDP打洞穿透NAT</a></h3><p>比较全面的介绍了。备有例子</p><h3 id="七、tun-turn-ice等穿越NAT方法大部分理论介绍"><a href="#七、tun-turn-ice等穿越NAT方法大部分理论介绍" class="headerlink" title="七、tun turn ice等穿越NAT方法大部分理论介绍"></a>七、<a href="https://my.oschina.net/mye/blog/129921" target="_blank" rel="noopener">tun turn ice等穿越NAT方法</a>大部分理论介绍</h3><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="一、WebRtc重要概念"><a href="#一、WebRtc重要概念" class="headerlink" title="一、WebRtc重要概念"></a>一、<a href="http://blog.csdn.net/u010657219/article/details/54930705" target="_blank" rel="noopener">WebRtc重要概念</a></h3><h3 id="二、WebRtc-之P2C的建立"><a href="#二、WebRtc-之P2C的建立" class="headerlink" title="二、WebRtc 之P2C的建立"></a>二、<a href="http://blog.csdn.net/u010657219/article/details/54930948" target="_blank" rel="noopener">WebRtc 之P2C的建立</a></h3><h3 id="三、WebRtc语音整体框架"><a href="#三、WebRtc语音整体框架" class="headerlink" title="三、WebRtc语音整体框架"></a>三、<a href="http://blog.csdn.net/u010657219/article/details/54931154" target="_blank" rel="noopener">WebRtc语音整体框架</a></h3><h3 id="四、-webrtc-android-ios系列教程，五十多节，内容有点多。可以慢慢看"><a href="#四、-webrtc-android-ios系列教程，五十多节，内容有点多。可以慢慢看" class="headerlink" title="四、 webrtc android ios系列教程，五十多节，内容有点多。可以慢慢看"></a>四、<a href="http://www.cnblogs.com/lingyunhu/tag/webrtc%20android%20ios/" target="_blank" rel="noopener"> webrtc android ios</a>系列教程，五十多节，内容有点多。可以慢慢看</h3><p>##</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>So Terrible</title>
      <link href="/2017/08/01/2017/8/%E7%9E%8E%E6%90%9E/"/>
      <url>/2017/08/01/2017/8/%E7%9E%8E%E6%90%9E/</url>
      
        <content type="html"><![CDATA[<p>很久没有写了。尤其是技术文章，一个多月没写了。本来这篇文章应该早一个月前写出来的。一直想把这篇我文章写好点，所以一直在看，在研究相关的问题。但是迟迟拖到现在也没完成。非常的遗憾，平时琐碎的时间太多。有时候觉得自己弄懂了就行了何必再去写东西呢！写一篇高质量的文章非常耗时，从写Demo到一步一步分析。😔还是没能完成最终的想法。就当给自己一个教训！</p><a id="more"></a><h1 id="瞎倒腾"><a href="#瞎倒腾" class="headerlink" title="瞎倒腾"></a>瞎倒腾</h1><p>几大核心对象（Util）如下：</p><ol><li>GCDAsyncSocketPreBuffer：用于当socket有更多可用的数据请求的时候而不是被当前读请求使用。在这种情况下将会从socket中剔除所有数据来最小化系统调用。并且将其他尚未被读取的数据放如preBuffer中。再次从socket读取之前，会填满preBuffer，换句话说也就是大量的数据会被写入preBuffer。接下来通过一系列的一次或多次读取(后续的读取请求)排除preBuffer。之前为了实现这个目的，使用了ring Buffer，但是一个ringBuffer占用的存储是需要的两倍，实际上通常是需要两倍以上的大小，因为所有内容必须四舍五入到vm_page_size。因为preBuffer在写入之后总是完全耗尽，所以不需要完整ringBuffer。目前通过链表实现的</li><li>GCDAsyncReadPacket：用于对可读数据包装，可读包可以确定是否读到了某个长度、短刀了么讴歌分隔符，捉着读到了第一个可用的chunk数据</li><li>GCDAsyncWritePacket：用于对可写数据包装</li><li>GCDAsyncSpecialPacket：对在读写队列中终端的特殊指令包装</li><li>GCDAsyncSocket：最终向外部暴露的类，使用标准的代理模式。在所给的代理队列里面回调。允许设置最大并发，提供了简单的线程安全。</li><li>Class Utilities：常用工具方法<ul><li>根据域名得到ip地址数组：lookupHost:(NSString *)host port:(uint16_t)port error:</li><li>是否为ipv4、ipv6</li></ul></li></ol><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接最终调用如下方法：</p><pre><code>- (BOOL)connectToHost:(NSString *)inHost               onPort:(uint16_t)port         viaInterface:(NSString *)inInterface          withTimeout:(NSTimeInterval)timeout                error:(NSError **)errPtr</code></pre><p>各个参数的意思很清楚，这里说一下参数inInterface。代表的是网卡接口。常见的如下：</p><ul><li><p>en1（Wireless NIC）无线网卡</p></li><li><p>lo0（本机环路），</p></li><li><p>en0有线网卡 （Wired NIC）。</p></li><li><p>注意：<strong>MBP 上没有有线网卡，en0 即为无线网卡</strong> ，可通过 ifconfig 命令自行识别。</p><p>它的值可以是”en1” or “lo0”也可以是ip地址。并且可以包含一个端口，用冒号分开。如果interface有值，则后面会将本机的IPV4 IPV6的 address设置上。</p><p>将参数传递进来之后立即将参数copy了一份保证不被外部修改。然后发起同步的链接。</p></li></ul><h3 id="dispatch-queue-set-specific"><a href="#dispatch-queue-set-specific" class="headerlink" title="dispatch_queue_set_specific"></a>dispatch_queue_set_specific</h3><p> 因为连接过程是在特定的socket队列中完成，所以用了dispatch_queue_set_specific来实现。</p><p> dispatch_queue_set_specific的使用方法比较简单，只要理解它就是为某个队列打个标记，然后通过这个标记取出来。可以简单的把他理解为一个字典。</p><ul><li>打标记：<code>dispatch_queue_set_specific(socketQueue, IsOnSocketQueueOrTargetQueueKey, nonNullUnusedPointer, NULL);</code></li><li>根据标记取：<code>dispatch_get_specific(IsOnSocketQueueOrTargetQueueKey)</code></li></ul><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><p>连接过程的非常多。这里把整个过程简化了一下。</p><p><strong>从开始连接到最终连接，最终调用走到<code>int result = connect(socketFD, (const struct sockaddr *)[address bytes], (socklen_t)[address length]);</code></strong></p><p>注意一点连接的过程全部放在了自动释放池@autoreleasepool中。目的也是为了优化性能。</p><p>在开始连接之前做了一个预处理。里面做了几个重要的事情：</p><ol><li>参数检验：代理是否为空、当前队列是否为socket队列、当前状态是否已经连接、清空读写队列</li><li>状态更新：用flags |= kSocketStarted;方式更新状态标识为开始Socket连接</li><li>域名解析(ipv4、ipv6)：返回的是一个数组</li><li>开始去连接：在全局队列里面调用[strongSelf lookup:aStateIndex didSucceedWithAddress4:address4 address6:address6];</li></ol><p>开始连接的过程有如下几个函数：</p><ul><li><code>- (void)lookup:(int)aStateIndex didSucceedWithAddress4:(NSData *)address4 address6:(NSData *)address6</code><ul><li>根据ip配置过滤，是否禁用ip4/6，报错则关闭连接。</li></ul></li><li><code>- (BOOL)connectWithAddress4:(NSData *)address4 address6:(NSData *)address6 error:(NSError **)errPtr</code><ul><li>获取具体的ipv4、ipv6地址。根据配置确定socketFD的值，socketFD为最终连接数据。</li></ul></li><li><code>- (void)connectSocket:(int)socketFD address:(NSData *)address stateIndex:(int)aStateIndex</code><ul><li>最终调用connect方法，将上面得到socketFD进行连接。注意这个方法是个同步的，会阻塞线程。<h2 id="Source-Timer"><a href="#Source-Timer" class="headerlink" title="Source/Timer"></a>Source/Timer</h2>如果了解过runloop底层的同学就知道source这个东西。项目中一共定义了如下几种source</li></ul></li></ul><pre><code>dispatch_source_t accept4Source;    dispatch_source_t accept6Source;    dispatch_source_t acceptUNSource;    //连接timer,GCD定时器    dispatch_source_t connectTimer;    dispatch_source_t readSource;    dispatch_source_t writeSource;    dispatch_source_t readTimer;    dispatch_source_t writeTimer;</code></pre><p>基本上分为三种，一种是用于监听连接的accept类型，一种是读写read、write，一种是定时器source。通过这几种source，达到监听网络连接、读写进度、定时器计时。</p><h3 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h3><p>通过代理来看看</p><pre><code>       // 连接            accept4Source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socket4FD, 0, socketQueue);            int socketFD = socket4FD;            dispatch_source_t acceptSource = accept4Source;            __weak GCDAsyncSocket *weakSelf = self;            //事件句柄            dispatch_source_set_event_handler(accept4Source, ^{ @autoreleasepool {            #pragma clang diagnostic push            #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;                __strong GCDAsyncSocket *strongSelf = weakSelf;                if (strongSelf == nil) return_from_block;                LogVerbose(@&quot;event4Block&quot;);                unsigned long i = 0;                //拿到数据，连接数                unsigned long numPendingConnections = dispatch_source_get_data(acceptSource);                LogVerbose(@&quot;numPendingConnections: %lu&quot;, numPendingConnections);                //循环去接受这些socket的事件                while ([strongSelf doAccept:socketFD] &amp;&amp; (++i &lt; numPendingConnections));            #pragma clang diagnostic pop            }});            //取消句柄            dispatch_source_set_cancel_handler(accept4Source, ^{            #pragma clang diagnostic push            #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;                #if !OS_OBJECT_USE_OBJC                LogVerbose(@&quot;dispatch_release(accept4Source)&quot;);                dispatch_release(acceptSource);                #endif                LogVerbose(@&quot;close(socket4FD)&quot;);                //关闭socket                close(socketFD);            #pragma clang diagnostic pop            });            LogVerbose(@&quot;dispatch_resume(accept4Source)&quot;);            //开启source            dispatch_resume(accept4Source);</code></pre><p>一旦有网络连接连上就会调用dispatch_source_set_event_handler设置的block。当取消连接的时候就会走dispatch_source_set_cancel_handler的block。注意source不会自己启动，需要手动启动。一切的开始都是从这一步开始的。</p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>读和写逻辑上基本一样，同样是开始创建事件源，设置监听回调、设置取消回调，手动启动几个步骤。具体步骤可以看看下面的注释。</p><pre><code>//GCD source DISPATCH_SOURCE_TYPE_READ 会一直监视着 socketFD，直到有数据可读    readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, socketFD, 0, socketQueue);    //_dispatch_source_type_write ：监视着 socketFD，直到写数据了    writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, socketFD, 0, socketQueue);    // Setup event handlers    __weak GCDAsyncSocket *weakSelf = self;#pragma mark readSource的回调    //GCD事件句柄  读，当socket中有数据流出现，就会触发这个句柄，全自动，不需要手动触发    dispatch_source_set_event_handler(readSource, ^{ @autoreleasepool {    #pragma clang diagnostic push    #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;        __strong GCDAsyncSocket *strongSelf = weakSelf;        if (strongSelf == nil) return_from_block;        LogVerbose(@&quot;readEventBlock&quot;);        //从readSource中，获取到数据长度，        strongSelf-&gt;socketFDBytesAvailable = dispatch_source_get_data(strongSelf-&gt;readSource);        LogVerbose(@&quot;socketFDBytesAvailable: %lu&quot;, strongSelf-&gt;socketFDBytesAvailable);        //如果长度大于0，开始读数据        if (strongSelf-&gt;socketFDBytesAvailable &gt; 0)            [strongSelf doReadData];        else            //因为触发了，但是却没有可读数据，说明读到当前包边界了。做边界处理            [strongSelf doReadEOF];    #pragma clang diagnostic pop    }});    //写事件句柄    dispatch_source_set_event_handler(writeSource, ^{ @autoreleasepool {    #pragma clang diagnostic push    #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;        __strong GCDAsyncSocket *strongSelf = weakSelf;        if (strongSelf == nil) return_from_block;        LogVerbose(@&quot;writeEventBlock&quot;);        //标记为可接受数据        strongSelf-&gt;flags |= kSocketCanAcceptBytes;        //开始写        [strongSelf doWriteData];    #pragma clang diagnostic pop    }});    // Setup cancel handlers    __block int socketFDRefCount = 2;    #if !OS_OBJECT_USE_OBJC    dispatch_source_t theReadSource = readSource;    dispatch_source_t theWriteSource = writeSource;    #endif    //读写取消的句柄    dispatch_source_set_cancel_handler(readSource, ^{    #pragma clang diagnostic push    #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;        LogVerbose(@&quot;readCancelBlock&quot;);        #if !OS_OBJECT_USE_OBJC        LogVerbose(@&quot;dispatch_release(readSource)&quot;);        dispatch_release(theReadSource);        #endif        if (--socketFDRefCount == 0)        {            LogVerbose(@&quot;close(socketFD)&quot;);            //关闭socket            close(socketFD);        }    #pragma clang diagnostic pop    });    dispatch_source_set_cancel_handler(writeSource, ^{    #pragma clang diagnostic push    #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;        LogVerbose(@&quot;writeCancelBlock&quot;);        #if !OS_OBJECT_USE_OBJC        LogVerbose(@&quot;dispatch_release(writeSource)&quot;);        dispatch_release(theWriteSource);        #endif        if (--socketFDRefCount == 0)        {            LogVerbose(@&quot;close(socketFD)&quot;);            //关闭socket            close(socketFD);        }    #pragma clang diagnostic pop    });</code></pre><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>计时器可以用NSTimer但是精度上没有source那么精确<br>这里以一个读超时计时器为例：</p><pre><code>//生成一个定时器source        readTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, socketQueue);        __weak GCDAsyncSocket *weakSelf = self;        //句柄        dispatch_source_set_event_handler(readTimer, ^{ @autoreleasepool {        #pragma clang diagnostic push        #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;            __strong GCDAsyncSocket *strongSelf = weakSelf;            if (strongSelf == nil) return_from_block;            //执行超时操作            [strongSelf doReadTimeout];        #pragma clang diagnostic pop        }});        #if !OS_OBJECT_USE_OBJC        dispatch_source_t theReadTimer = readTimer;        //取消的句柄        dispatch_source_set_cancel_handler(readTimer, ^{        #pragma clang diagnostic push        #pragma clang diagnostic warning &quot;-Wimplicit-retain-self&quot;            LogVerbose(@&quot;dispatch_release(readTimer)&quot;);            dispatch_release(theReadTimer);        #pragma clang diagnostic pop        });        #endif        //定时器延时 timeout时间执行        dispatch_time_t tt = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC));        //间隔为永远，即只执行一次        dispatch_source_set_timer(readTimer, tt, DISPATCH_TIME_FOREVER, 0);        dispatch_resume(readTimer);</code></pre><h3 id="source总结"><a href="#source总结" class="headerlink" title="source总结"></a>source总结</h3><p>通过上面的代码可以得出source的使用方式，而且整个GCDAsyncSocket都是建立在这个基础之上。设置各个source的回调处理方法。在事件到来的时候调用。如果手动取消则会调用cancle回调。基本上是照着葫芦画瓢的过程。</p><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>读和写的过程和逻辑判断步骤基本相似的。</p><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>往socket里面写数据调用<code>writeData: withTimeout: tag:</code></p><p>发送之前先将数据包装成GCDAsyncWritePacket对象。将packet加入到writeQueue当中，然后调用doWriteData方法。最终调用<code>ssize_t result = write(socketFD, buffer, (size_t)bytesToWrite);</code>中间经过一系列的条件判断。</p><ol><li><code>- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</code></li><li><code>[self maybeDequeueWrite];</code> 一系列条件判断，比如TLS,SSL。超时设置</li><li><code>[self doWriteData];</code></li><li>Writing data directly over raw socket。</li></ol><p>注意ssize_t write(int fd, const void*buf,size_t nbytes);write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数.失败时返回-1. 并设置errno变量。</p><p>在写的时候可能一次写不完全，所以需要GCDAsyncWritePacket记录当前的已经上传多少。</p><blockquote><p>给自己截止的日期已经到了，但是还是没有整理出来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列一</title>
      <link href="/2017/07/22/2017/7/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%80/"/>
      <url>/2017/07/22/2017/7/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>给定{ 1, 2, 3, , , n }，其全排列为$n!$个，这是最基础的高中组合数学知识。我们以n=4为例，其全部排列如下图（以字典序树形式来呈现）：</p><a id="more"></a><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><img src="http://oi0fekpsr.bkt.clouddn.com/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98_1.jpg#mirages-width=990&mirages-height=490&mirages-cdn-type=1" alt></p><p>我们很容易想到用递归来解决这个问题。</p><p>仔细观察上图，</p><ul><li>以1开头，下面跟着{ 2, 3, 4 }的全排列；</li><li>以2开头，下面跟着{ 1, 3, 4 }的全排列；</li><li>以3开头，下面跟着{ 1, 2, 4 }的全排列；</li><li>以4开头，下面跟着{ 1, 2, 3 }的全排列。</li></ul><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">/**** date   2017-07-22* mode   C++*/#include<iostream>  #include<algorithm>  using namespace std;void FullPermutation(int array[], int left, int right){    if (left == right)    {        for (int i = 0; i < 4; i++)            cout << array[i] << " ";        cout << endl;    }    else    {        for (int i = left; i <= right; i++)        {            swap(array[i], array[left]);            FullPermutation(array, left + 1, right);            swap(array[i], array[left]);        }    }}int main(){    int array[4] = { 1,2,3,4 };    FullPermutation(array, 0, 3);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行如下：</p><p><img src="http://oi0fekpsr.bkt.clouddn.com/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98_2.png" alt></p><p>咦~递归写出的全排列有点不完美，它并不严格遵循字典序。但是熟悉C++的朋友肯定知道另一种更简单，更完美的全排列方法。</p><p>定义于头文件&lt; algorithm &gt;内的两个算法函数：</p><ul><li>next_permutation，对于当前的排列，如果在字典序中还存在下一个排列，返回真，并且把当前排列调整为下一个排列；如果不存在，就把当前排列调整为字典序中的第一个排列（即递增排列），返回假。</li><li>prev_permutation，对于当前的排列，如果在字典序中还存在上一个排列，返回真，并且把当前排列调整为上一个排列；如果不存在，就把当前排列调整为字典序中的最后一个排列（即递减排列），返回假。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">/**** date   2017-07-22* mode   C++*/#include<iostream>  #include<algorithm>  using namespace std;void FullPermutation(int array[]){    do    {        for (int i = 0; i < 4; i++)            cout << array[i] << " ";        cout << endl;    } while (next_permutation(array, array + 4));}int main(){    int array[4] = { 1,2,3,4 };    FullPermutation(array);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行截图省略。输出结果正好符合字典序。</p><p>那这个“轮子”是怎么做的呢？（摘自侯捷的《STL源码剖析》）</p><ul><li>next_permutation，首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<code>*i</code>，第二元素为<code>*ii</code>，且满足<code>*i&lt;*ii</code>，找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于<code>*i</code>的元素，令为<code>*j</code>，将i，j元素对调，再将ii之后的所有元素颠倒排列，此即所求之“下一个”排列组合。</li><li>prev_permutation，首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<code>*i</code>，第二元素为<code>*ii</code>，且满足<code>*i&gt;*ii</code>，找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于<code>*i</code>的元素，令为<code>*j</code>，将i，j元素对调，再将ii之后的所有元素颠倒排列，此即所求之“上一个”排列组合。</li></ul><p>代码如下：</p><pre class="line-numbers language-c++"><code class="language-c++">bool next_permutation(int * first, int * last){    if (first == last) return false;  //空区间    int * i = first;    ++i;    if (i == last) return false;  //只有一个元素    i = last;    --i;    for (;;)    {        int * ii = i;        --i;        if (*i < *ii)        {            int * j = last;            while (!(*i < *--j))  //由尾端往前找，直到遇上比*i大的元素                ;            swap(*i, *j);            reverse(ii, last);            return true;        }    }    if (i == first)  //当前排列为字典序的最后一个排列    {        reverse(first, last);  //全部逆向排列，即为升序        return false;    }}bool prev_premutation(int * first, int * last){    if (first == last) return false;  //空区间    int * i = first;    ++i;    if (i == last) return false;  //只有一个元素    i = last;    --i;    for (;;)    {        int * ii = i;        --i;        if (*i > *ii)        {            int * j = last;            while (!(*i > *--j))  //由尾端往前找，直到遇上比*i大的元素                ;            swap(*i, *j);            reverse(ii, last);            return true;        }    }    if (i == first)  //当前排列为字典序的第一个排列    {        reverse(first, last);  //全部逆向排列，即为降序        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结后语"><a href="#结后语" class="headerlink" title="结后语"></a>结后语</h2><p>这篇文章主要介绍了解决不重复序列的全排列问题的两个方法：递归和字典序法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何阅读开源项目</title>
      <link href="/2017/06/07/2017/6/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/06/07/2017/6/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>最近这段时间一直比较忙，相对于之前少了很多的学习时间。抽空看几篇源码分析的文章，大多数都是大同小异的思路，把英文翻译为中文而已。鉴于关于介绍如何阅读开源项目的文章比较稀少，常言道<strong>授人予鱼不如授人予渔</strong>。希望这篇文章能够给准备阅读三方源码的同学一些启示。</p><a id="more"></a><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-cd5448573458a33f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><strong>在阅读源码之前最好明确一下阅读的目的，这样有助于阅读的深度和时间的控制。</strong>比如如果是为了解决项目中的bug，则可以阅读bug所涉及的部分；如果是为了提高自己的编码能力，学习设计技巧，则就需要更为深入的阅读。</p><p>因为阅读源码其实是一件非常辛苦的事情，尤其是分析一些大型开源项目的源码，如果毫无目的的阅读会浪费大量的时间。<strong>而且阅读源码也是一个长期的过程，不可能一天分析完Spring源码的分析</strong>，所以在分析源码之前一定要有一个明确的认识，不仅仅只是翻译英文注释，花大量的时间是在所难免的。</p><p>对笔者而言阅读源码的目的基本上可以分为如下几种：</p><ol><li>提高自己的编码能力，学习设计思想。</li><li>解决工作中所用第三方库遇到的bug。</li><li>借鉴开源代码，私有化别人的代码，完成工作需求。</li></ol><p>当然不排除某些大神，读源码纯粹是了找开源代码漏洞或者想改进该项目。毕竟这种牛逼的人是少数。当我们明确了阅读的目的就可以大致确定所需要花费的时间及精力了。</p><h1 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-d759e5a41ea7b7ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>获取源码的地方太多了，最负有盛名的就是<a href="https://github.com/search?utf8=%E2%9C%93&q=&type=Repositories&ref=searchresults" target="_blank" rel="noopener">GitHub</a>。除此之外还有<a href="https://sourceforge.net/" target="_blank" rel="noopener">sourceforge</a>，Google和Apple也有其开源项目下载地址，分别是<a href="https://opensource.google.com/" target="_blank" rel="noopener">Google OpenSource</a>、<a href="https://opensource.apple.com/" target="_blank" rel="noopener">Apple OpenSource</a>。国内有比较出名的有<a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a>，<a href="https://git.oschina.net/" target="_blank" rel="noopener">码云(开源中国代码托管平台)）</a>，<a href="https://coding.net/user" target="_blank" rel="noopener">Coding</a>。</p><p>整理一下：</p><ol><li><a href="https://github.com/search?utf8=%E2%9C%93&q=&type=Repositories&ref=searchresults" target="_blank" rel="noopener">GitHub</a></li><li><a href="https://sourceforge.net/" target="_blank" rel="noopener">sourceforge</a></li><li><a href="https://opensource.google.com/" target="_blank" rel="noopener">Google OpenSource</a></li><li><a href="https://opensource.apple.com/" target="_blank" rel="noopener">Apple OpenSource</a></li><li><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a></li><li><a href="https://git.oschina.net/" target="_blank" rel="noopener">码云(开源中国代码托管平台)）</a></li><li><a href="https://coding.net/user" target="_blank" rel="noopener">Coding</a></li></ol><p>在进行搜索的开源项目有很多搜索技巧，就拿GitHub举个例子。想高效的使用GitHub，一定要把<a href="https://github.com/search/advanced" target="_blank" rel="noopener"> advanced search</a>、<a href="https://help.github.com/articles/searching-github/#types-of-searches" target="_blank" rel="noopener">prefixes</a>看一下。</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-60bdc08289a60f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>除了上面提到的开源项目下载地址，还有很多其他的地方可以获取到源码，这里就不多提了。</p><h1 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h1><p><img src="http://upload-images.jianshu.io/upload_images/664334-a4c7e4dca05a7220.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><strong>阅读方法才是今天的重点，笔者一般是按照下面的步骤开始。</strong></p><ol><li>基本思想就是先对项目有个大致的了解。比如关键的类有哪些，各个文件夹之间的关系。</li><li>然后从最核心的API开始，先使用UML里的类图建立静态结构，分析出类与类之间的关系（继承，组合，实现，依赖，关联等等）。<strong>这一步是精读的必经之路，如果想要彻底理解，画UML图无意识最直接的方式。</strong></li><li>配合IDE工具分析核心流程，理解项目是如何工作的。</li><li>着重看项目中添加的注释，因为一般开源项目中的注释都非常重要。</li></ol><p>接下来分下面几个部分详细介绍。</p><ul><li>看：静态对代码进行分析，看相关资料，代码逻辑</li><li>跑：将项目在IDE里面跑起来，通过IDE调试参数，加Log等。</li><li>查：阅读过程中肯定会遇到不懂的，这时候需要通过搜索引擎来解决你的疑惑。</li></ul><h2 id="看"><a href="#看" class="headerlink" title="看"></a>看</h2><p>这个部分是非常基础但是重要的部分，主要完成对代码的基本感知。从静态的角度理解代码。</p><h3 id="现有资料"><a href="#现有资料" class="headerlink" title="现有资料"></a>现有资料</h3><p>在我们准备阅读某个开源项目之前，如果搜集了相关的资料的话，对我理解起来非常有帮助。也就是常说的<strong>站在巨人的肩膀上</strong>。</p><p>主要分为两种：</p><ol><li>项目官方文档比如Wiki</li><li>使用者分析的文档比如项目源码分析。</li></ol><p>GitHub上的开源项目大部分都有文档介绍，好一点的项目都会有对应的Wiki。<strong>除此之外开源项目的Issue也是我们需要关心的。往往这些Isuue对应到项目中都是核心部分，也就是我们非常值得关注的地方。</strong>如下图所示，一定要善用这些选项。因为这些都是前人踩过的坑，对于项目理解非常有用。<br><img src="http://upload-images.jianshu.io/upload_images/664334-573526a334ebaf12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>除了项目本身的文档外，还有一种形式的文档也需要我们注意。这类文档就是别人对这个项目写过的一些源码分析文章。这类文章已经对项目分析过一次了，先阅读完之后，会对我们自己去阅读源码起到一个理清思路，引路的作用。</p><p>但是有些大型的开源项目文档太多了，就官方说明文档就不可能一次看完，比如java中的Spring，看完文档也是不现实的。<strong>这个时候就应该把文档与代码调试结合在一起。效率会高不少。</strong>而且这类型的大型项目至少也得花一年半载才能弄清楚。</p><h3 id="代码内注释"><a href="#代码内注释" class="headerlink" title="代码内注释"></a>代码内注释</h3><p><strong>对于开源项目内注释一定，一定要仔细看看</strong>。在使用第三方库的时候，往往因为没有仔细阅读代码内注释而导致滥用方法。</p><p>如下图是iOS开源项目CocoaAsyncSocket一段代码内注释<br><img src="http://upload-images.jianshu.io/upload_images/664334-0faf30bc20d85d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如果没有仔细看代码内注释，没有注意到必须设置代理和代理队列，遇到报错了根本不知道怎么发生的。</p><p>代码内注释是作者着重想传达给使用者的信息，所以切记切记，一定要仔细看代码内注释。但是好多人都误以为把注释看懂就是源码分析了，而且好多源码分析文章也是这样写的，把注释翻译一下，说明一下用途。</p><h2 id="跑"><a href="#跑" class="headerlink" title="跑"></a>跑</h2><p>这个过程是对代码的深入理解部分，通过改变函数参数，运行环境等。不同的语言用了不同的IDE，大部分IDE的作用都相差不多，都可以追溯堆栈，查看变量信息等。所以思路都是相同的。</p><h3 id="IDE调试"><a href="#IDE调试" class="headerlink" title="IDE调试"></a>IDE调试</h3><p>项目编译出来，运行加log，试着修改一些数据和代码，看看有什么变化。这是最为常用的方法。灵活使用IDE的debugger，而debugger最重要的功能是获取call stack。查看变量的变化情况，在你不知道有什么用的函数里加个断点，显示出来的call stack都能让你对系统有更清晰的认识。</p><p>关于IDE的调试使用常用的断点调试，变量跟中这些，这里就不多讲了。</p><h4 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h4><p>很多时候我们不知道某个变量或者某个变量具体的作用，<strong>那么这个时候就可以用到对CUD（Create,Update,Delete）思想</strong>。</p><p><strong>调试中的CUD具体来讲就是对源代码的类、函数、变量进行增加、修改、删除</strong>。如果一直停留在<code>看</code>源码的基础上很有可能不能透彻的理解，当我们掌握了代码设计规则，使用CUD方式可以加深理解，以及验证我们的猜想是否正确。</p><p><strong>特别注意，在实现项目中一定不要去修改第三方的源码，有时候可以通过修改第三方源码来达到暂时的目的，但是往往在后期维护，升级方面必将付出惨重的代价。这里指的CUD只适合在分析源码的时候。</strong></p><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p><img src="http://upload-images.jianshu.io/upload_images/664334-a6d7c0f50fe4e75a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>在分析源码的过程中，肯定会遇到自己不懂的地方，对于这种问题，大部分靠自己现有的知识很有可能无法理解，这个时候就需要实在不懂就问了。Google、相关社区、GitHub Issue、Stackoverflow多搜多问。</p><p>查这个步骤应该是贯穿整个过程的，但是也得注意不是一遇到问题就上网查，而是应该在自己思考之后，得不到解答才去查。很多同学养成了一遇到问题就Google，百度，其实从长远来看不利于自己的提升。</p><h1 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h1><p>走完上面的步骤之后，基本上对一个项目源码掌握了。但是这个层次还是有点low。仅仅停留在理解的阶段，如果想做得更好就需要对项目的设计进行分析，看看有没有可以改进的地方，甚至完全试一试自己能不能针对某个模块改进一下。</p><p>这个阶段类似于<code>提升、创新</code>的程度，建立在见多识广的基础之上，对于阅读开源项目不多的同学还是非常有难度的。</p><h1 id="整理成文"><a href="#整理成文" class="headerlink" title="整理成文"></a>整理成文</h1><p>最后的阶段就是把自己分析的内容整理成为文档，分享出来。这也是提升自己能力的一个重要渠道，在写文章的时候，会强迫自己对那些不清楚的知识点加深理解。</p><p>文章内容应包括自己整理的UML图，核心类的实现，代码设计技巧，以及告知读者使用该第三方的时候需要注意的问题。</p><p>在写文章的时候需要注意，不要过多的延伸。毕竟一个点所涉及的知识网太大了，选择其中比较核心的几点阐述即可。</p><h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCode多项目(xcodeproj)使用Cocoapod管理</title>
      <link href="/2017/05/13/2017/5/XCode%E5%A4%9A%E9%A1%B9%E7%9B%AE(xcodeproj)%E4%BD%BF%E7%94%A8Cocoapod%E7%AE%A1%E7%90%86/"/>
      <url>/2017/05/13/2017/5/XCode%E5%A4%9A%E9%A1%B9%E7%9B%AE(xcodeproj)%E4%BD%BF%E7%94%A8Cocoapod%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近比较忙，空闲的时候看的是关于算法方面的。关于算法自己的脑子不够用想写点东西，但是感觉还没有很熟练。所以先写点其他的。</p><a id="more"></a><h1 id="XCode多项目-xcodeproj-使用Cocoapod管理"><a href="#XCode多项目-xcodeproj-使用Cocoapod管理" class="headerlink" title="XCode多项目(xcodeproj)使用Cocoapod管理"></a>XCode多项目(xcodeproj)使用Cocoapod管理</h1><blockquote><p>最近在写demo的时候遇到这个问题。平时开发大都是一个workspace下面的一个xcodeproj开发。由于demo中有多个xcodeproj。而且这几个xcodeproj都需要用到cocoapod。这里顺便记录下解决的方法</p></blockquote><h2 id="更改podfile"><a href="#更改podfile" class="headerlink" title="更改podfile"></a>更改podfile</h2><p>首先工程的目录结构如下；<br><img src="http://upload-images.jianshu.io/upload_images/664334-25cd6f9d28ed2e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>之所以会出现这样的问题还是对podfile文件格式不熟悉。</p><p><strong>原来cocoapod允许我们指定workspace以及每个target的xcodeproj文件的路径。原理就是这样，在每个target下面添加对应的路径即可。</strong></p><p>总体来说就是这个样子</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true"># Uncomment the next line to define a global platform for your project</span><span class="token comment" spellcheck="true"># platform :ios, '9.0'</span>workspace <span class="token string">'SocketDemo.xcworkspace'</span>target <span class="token string">'SocketDemo'</span> <span class="token keyword">do</span>  <span class="token comment" spellcheck="true"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span>  <span class="token comment" spellcheck="true"># use_frameworks!</span>  <span class="token comment" spellcheck="true"># Pods for SocketDemo</span>  xcodeproj <span class="token string">'SocketDemo.xcodeproj'</span>  <span class="token comment" spellcheck="true"># 网络库</span>  pod <span class="token string">'CocoaAsyncSocket'</span><span class="token punctuation">,</span> '<span class="token operator">~</span><span class="token operator">></span> <span class="token number">7.4</span><span class="token punctuation">.</span><span class="token number">3</span>’<span class="token keyword">end</span>target <span class="token string">'SocketServe'</span> <span class="token keyword">do</span>    <span class="token comment" spellcheck="true"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span>    <span class="token comment" spellcheck="true"># use_frameworks!</span>    <span class="token comment" spellcheck="true"># Pods for CocoaAstnSocketDemo</span>    xcodeproj <span class="token string">'SocketServe/SocketServe.xcodeproj'</span>    <span class="token comment" spellcheck="true"># 网络库</span>    pod <span class="token string">'CocoaAsyncSocket'</span><span class="token punctuation">,</span> '<span class="token operator">~</span><span class="token operator">></span> <span class="token number">7.4</span><span class="token punctuation">.</span><span class="token number">3</span>’<span class="token keyword">end</span>target <span class="token string">'CocoaAstnSocketDemo'</span> <span class="token keyword">do</span>  <span class="token comment" spellcheck="true"># Uncomment the next line if you're using Swift or would like to use dynamic frameworks</span>  <span class="token comment" spellcheck="true"># use_frameworks!</span>  <span class="token comment" spellcheck="true"># Pods for CocoaAstnSocketDemo</span>  xcodeproj <span class="token string">'CocoaAstnSocketDemo/CocoaAstnSocketDemo.xcodeproj'</span>  <span class="token comment" spellcheck="true"># 网络库</span>  pod <span class="token string">'CocoaAsyncSocket'</span><span class="token punctuation">,</span> '<span class="token operator">~</span><span class="token operator">></span> <span class="token number">7.4</span><span class="token punctuation">.</span><span class="token number">3</span>’<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意有一下几点。</p><ol><li>workspace必须填而且在所有target外面</li><li>每个target对应的xcodeproj写在每个target配置里面</li><li>如果没有指明xcodeproj和workspace的路径默认就会用根目录下面的<code>*.xcodeproj</code>、<code>*.workspace</code>为标</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础回顾之C编译过程及预处理器</title>
      <link href="/2017/05/06/2017/5/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E4%B9%8BC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2017/05/06/2017/5/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E4%B9%8BC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8F%8A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>做技术，越做到后面越觉得基础、底层的才是越难得，也会越有技术含量的。最近做的项目有关音视频、图像处理，涉及到的都死c和c++相关的代码。遇到了问题才发现，c和c++才是通用大法。这两块没学好，那也只有玩一玩应用层、UI这些东西。抽空整理下。</p><a id="more"></a><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>如果需要弄清整个编译过程，那还得好好复习下编译原理。这里只是通过一个小例子讨论大致过程。</p><p>准备好一个helloworld的c文件。内容最好简单如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译命令</strong></p><pre><code>$ gcc helloworld.c // 编译$ ./a.out // 执行Hello World!</code></pre><p>gcc命令其实依次执行了四步操作：</p><ol><li><p>预处理(Preprocessing)</p><ul><li><p>预处理用于将所有的#include头文件以及宏定义替换成其真正的内容，预处理之后得到的仍然是文本文件，但文件体积会大很多。</p></li><li><p>命令: <code>gcc -E -I./ helloworld.c -o helloworld.i</code> 或者直接用<code>cpp helloworld.c -I./ -o helloworld.i</code></p></li><li><p>参数说明：</p><ul><li><code>-E</code>是让编译器在预处理之后就退出，不进行后续编译过程；</li><li><code>-I</code>指定头文件目录，这里指定的是我们自定义的头文件目录；</li><li><code>-o</code>指定输出文件名。</li></ul></li><li><p>经过预处理之后代码体积会大很多。如下是预处理之后的部分内容。</p><pre class="line-numbers language-c"><code class="language-c"># <span class="token number">1</span> <span class="token string">"helloworld.c"</span># <span class="token number">1</span> <span class="token string">"&lt;built-in>"</span> <span class="token number">1</span># <span class="token number">1</span> <span class="token string">"&lt;built-in>"</span> <span class="token number">3</span># <span class="token number">330</span> <span class="token string">"&lt;built-in>"</span> <span class="token number">3</span># <span class="token number">1</span> <span class="token string">"&lt;command line>"</span> <span class="token number">1</span># <span class="token number">1</span> <span class="token string">"&lt;built-in>"</span> <span class="token number">2</span># <span class="token number">1</span> <span class="token string">"helloworld.c"</span> <span class="token number">2</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> __uint8_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> __int16_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> __uint16_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> __int32_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __uint32_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> __int64_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> __uint64_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _opaque_pthread_attr_t __darwin_pthread_attr_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _opaque_pthread_cond_t __darwin_pthread_cond_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _opaque_pthread_condattr_t __darwin_pthread_condattr_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> __darwin_pthread_key_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _opaque_pthread_mutex_t __darwin_pthread_mutex_t<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t<span class="token punctuation">;</span>FILE <span class="token operator">*</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict __filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict __mode<span class="token punctuation">)</span> <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"_"</span> <span class="token string">"fopen"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span> <span class="token punctuation">(</span>__printf__<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> FILE <span class="token operator">*</span> restrict<span class="token punctuation">)</span> <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"_"</span> <span class="token string">"fputs"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>size_t <span class="token function">fread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> restrict __ptr<span class="token punctuation">,</span> size_t __size<span class="token punctuation">,</span> size_t __nitems<span class="token punctuation">,</span> FILE <span class="token operator">*</span> restrict __stream<span class="token punctuation">)</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span>               FILE <span class="token operator">*</span> restrict<span class="token punctuation">)</span> <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"_"</span> <span class="token string">"freopen"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span> <span class="token punctuation">(</span>__scanf__<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fsetpos</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> fpos_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>size_t <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> restrict __ptr<span class="token punctuation">,</span> size_t __size<span class="token punctuation">,</span> size_t __nitems<span class="token punctuation">,</span> FILE <span class="token operator">*</span> restrict __stream<span class="token punctuation">)</span> <span class="token function">__asm</span><span class="token punctuation">(</span><span class="token string">"_"</span> <span class="token string">"fwrite"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">perror</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span> <span class="token punctuation">(</span>__printf__<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">putc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">rename</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>__old<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>__new<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span> <span class="token punctuation">(</span>__scanf__<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setbuf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">setvbuf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span> <span class="token punctuation">(</span>__printf__<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__availability__</span><span class="token punctuation">(</span>swift<span class="token punctuation">,</span> unavailable<span class="token punctuation">,</span> message<span class="token operator">=</span><span class="token string">"Use snprintf instead."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span> <span class="token punctuation">(</span>__scanf__<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span><span class="token function">tmpfile</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__availability__</span><span class="token punctuation">(</span>swift<span class="token punctuation">,</span> unavailable<span class="token punctuation">,</span> message<span class="token operator">=</span><span class="token string">"Use mkstemp(3) instead."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">deprecated</span><span class="token punctuation">(</span><span class="token string">"This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 中间很多内容这里省略<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">__vsnprintf_chk</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span>     <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> restrict<span class="token punctuation">,</span> va_list<span class="token punctuation">)</span><span class="token punctuation">;</span># <span class="token number">499</span> <span class="token string">"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/usr/include/stdio.h"</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span># <span class="token number">2</span> <span class="token string">"helloworld.c"</span> <span class="token number">2</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>编译(Compilation), </p><ul><li><p><strong>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理之后的程序转换成特定汇编代码(assembly code)的过程。</strong></p></li><li><p>命令:gcc -S -I./ helloworld.c -o helloworld.s</p></li><li><p>参数:<code>-S</code>为了编译之后停止。后面的两个参数含义和预处理的时候一样</p></li><li><p>经过编译之后的内容如下。</p><pre><code>  .section    __TEXT,__text,regular,pure_instructions  .macosx_version_min 10, 12  .globl    _main  .p2align    4, 0x90_main:                                  ## @main  .cfi_startproc## BB#0:  pushq    %rbpLtmp0:  .cfi_def_cfa_offset 16Ltmp1:  .cfi_offset %rbp, -16  movq    %rsp, %rbpLtmp2:  .cfi_def_cfa_register %rbp  subq    $16, %rsp  leaq    L_.str(%rip), %rdi  movl    $0, -4(%rbp)  movb    $0, %al  callq    _printf  xorl    %ecx, %ecx  movl    %eax, -8(%rbp)          ## 4-byte Spill  movl    %ecx, %eax  addq    $16, %rsp  popq    %rbp  retq  .cfi_endproc  .section    __TEXT,__cstring,cstring_literalsL_.str:                                 ## @.str  .asciz    &quot;Hello World!\n&quot;</code></pre></li></ul></li></ol><pre><code>.subsections_via_symbols```</code></pre><ol start="3"><li>汇编(Assemble), <ul><li>汇编过程将上一步的汇编代码转换成机器码(machine code)，这一步产生的文件叫做目标文件，是二进制格式。如果有多个文件需要<strong>为每一个源文件产生一个目标文件。</strong></li><li>命令:as helloworld.s -o helloworld.o 或者 gcc -c helloworld.s -o helloworld.o</li></ul></li><li>链接(Linking)。<ul><li>链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)。</li><li>命令:ld -o helloworld.out helloworld.o <code>**.o</code> <code>**.o</code>。格式其实就是 <code>ld(选项)(参数)</code>参数就是需要连接的目标文件。由于这里没有生成其他目标文件，所以这段不会连接成功的。具体的命令可以看这里<a href="http://man.linuxde.net/ld" target="_blank" rel="noopener">ld命令</a></li></ul></li></ol><p>走完上面的步骤可以得到如下几个文件。<br><img src="http://upload-images.jianshu.io/upload_images/664334-efe31056eaf23961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其实我们平时写代码的到得到可执行文件的整个过程可以用下图来概括。<br><img src="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/C_DevelopmentProcesses.png" alt></p><h1 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h1><p>上面把基本的编译过程讲完了，现在就开始进入今天的正题。</p><h2 id="预处理前的操作"><a href="#预处理前的操作" class="headerlink" title="预处理前的操作"></a>预处理前的操作</h2><p>再进行预处理前，编译器会对源代码记性一些翻译过程。其中有几点需要知道:</p><ul><li><p>源代码中的资费映射到元字符集。使得C外观更加国际化</p></li><li><p>预处理表达式的长度为一逻辑行。</p></li><li><p>查找反斜杠后紧跟换行符的实例并删除。也即是预处理会删除反斜杠和换行符的组合。</p><ul><li><p>类似</p><pre class="line-numbers language-c"><code class="language-c">  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, \                 World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  两行物理行变为一行<code>printf(&quot;Hello,World!\n&quot;);</code>经过测试在Xcode中会上面的形式会比项目多很多空格。</p><ul><li><strong>其实这就是为什么我们能够用宏定义定义函数的原理。</strong></li><li>文本划分为预处理语言符号、空白字符及注释序列。<strong>注意编译器会有空格代替注释</strong></li></ul></li></ul></li></ul><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>所有预处理指令都是以<code>#</code>开头。关于<code>#define</code>和<code>const</code>定义常量的区别也是需要值得注意的地方。<code>#define</code>做的是暴力替换，而<code>const</code>是针对性的。</p><h4 id="语言符号及字符型符号"><a href="#语言符号及字符型符号" class="headerlink" title="语言符号及字符型符号"></a>语言符号及字符型符号</h4><ul><li>字符型符号:额外的空格当成替换文本的一部分,空格也是主体的一部分。</li><li>语言符号:空格只是分隔主体的符号。</li></ul><p>例子<code>#define TEST 4  *  8</code></p><ul><li>字符型符号将TEST替换为<code>4  *  8</code></li><li>语言符号将TEST替换为<code>4 * 8</code></li></ul><p><strong>C编译器把宏主体当成的是字符型符号</strong></p><p><strong>判断宏定义想不相同通过语言定义符号来确定。比如#define TEST 4<em>8和上面的就不是相同的宏定义因为它只有一个语言符号4`</em>`8。上面有三个分别是4、空格、8</strong></p><h3 id="define中使用参数"><a href="#define中使用参数" class="headerlink" title="define中使用参数"></a>define中使用参数</h3><p>使用参数很简单，就是<code>#define TEST(X) X*X</code>。规则如下：<br><img src="http://upload-images.jianshu.io/upload_images/664334-61ab9dcfa2b0079a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>特别需要注意的是宏参数和函数参数的区别，宏参数是进行严格的特换。这如果使用不懂就会出现非常严重的错误。</strong></p><h4 id="使用-参数：宏参数创建字符串"><a href="#使用-参数：宏参数创建字符串" class="headerlink" title="使用#参数：宏参数创建字符串"></a>使用<code>#</code>参数：宏参数创建字符串</h4><table><thead><tr><th>宏定义</th><th>调用</th><th>结果</th></tr></thead><tbody><tr><td><code>#define TESTPF(x) printf(&quot;test &quot;#x&quot; * &quot;#x&quot;=%d\n&quot;,(x)*(x));</code></td><td><code>TESTPF(5 + 5)</code></td><td><code>test 5 + 5 * 5 + 5=100</code></td></tr><tr><td><code>#define TESTPF(x) printf(&quot;test x * x=%d\n&quot;,(x)*(x));</code></td><td><code>TESTPF(5 + 5);</code></td><td><code>test x * x=100</code></td></tr></tbody></table><p>可以看到<code>#</code>参数的作用就是把字符串中的x也进行了替换。</p><h4 id="使用-参数：预处理粘合剂"><a href="#使用-参数：预处理粘合剂" class="headerlink" title="使用##参数：预处理粘合剂"></a>使用<code>##</code>参数：预处理粘合剂</h4><p><code>##</code>作用是把两个语言符号组合为单个语言符号。<br>例子：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> XNAME(n) x##n</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINT_XN(n) printf("x"#n" = %d \n");</span><span class="token keyword">int</span> <span class="token function">XNAME</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">XNAME</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">PRINT_XN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">PRINT_XN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>结果：x1 <span class="token operator">=</span> <span class="token number">1606416096</span> x2 <span class="token operator">=</span> <span class="token number">4352</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="和-VA-ARGS-可变宏"><a href="#和-VA-ARGS-可变宏" class="headerlink" title="...和__VA_ARGS__:可变宏"></a><code>...</code>和<code>__VA_ARGS__</code>:可变宏</h4><p>这个其实在iOS开发中还是用得挺多的。</p><p>例子</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> PR(...) printf(__VA_ARGS__)</span><span class="token function">PR</span><span class="token punctuation">(</span><span class="token string">"DD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">PR</span><span class="token punctuation">(</span><span class="token string">"D=%d,F=%d\n"</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>结果：DDD<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span>F<span class="token operator">=</span><span class="token number">22</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>特别注意。省略号必须在最后一个参数位置。根据这个道理，有些同学可能就能联想到某些语言可变参数的位置为什么一定要在最后把。比如python</strong></p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>预处理器发现<code>#include</code>指令后，会寻找跟在后面的文件，把这个文件中的内容包含到当前文件中。<br><img src="http://upload-images.jianshu.io/upload_images/664334-bc5310a01554942b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>OC中有.h和.m文件，这和C里面的.h和.c是同一个道理。所以这里就不多说了。具体看图。<br><img src="http://upload-images.jianshu.io/upload_images/664334-eccfc5b06d18db96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="其他预处理指令"><a href="#其他预处理指令" class="headerlink" title="其他预处理指令"></a>其他预处理指令</h3><ul><li><code>#undef</code>取消已定义的宏</li><li><code>#if</code>如果给定条件为真，则编译下面代码</li><li><code>#elif</code>如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</li><li><code>#endif</code>结束一个<code>#if……#else</code>条件编译块</li><li><code>#ifdef</code>如果宏已经定义，则编译下面代码</li><li><code>#ifndef</code>如果宏没有定义，则编译下面代码</li><li><code>#pragma</code>指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。</li></ul><p>上面这些预处理指令，用得比较频繁。大家应该不陌生。还多一些平时用得不多的。</p><ul><li><code>#line</code>指令可以改变编译器用来指出警告和错误信息的文件号和行号。</li><li><code>#error</code>停止编译并显示错误信息</li></ul><h4 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h4><p>C标准制定的一些预处理宏。<br><img src="http://upload-images.jianshu.io/upload_images/664334-9cfdabf2edcdb231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>额外补充一个<code>__func__</code>预定义标识符。这个是C99标准提供的。用于标识当前函数。</p><p><strong>上面这些预处理宏经常用于打印一些日志信息。</strong></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/c0_Introduction.html" target="_blank" rel="noopener">C programming Tutorial Introduction to C Programming (for Novices &amp; First-Time Programmers)</a><br><a href="http://www.cnblogs.com/zi-xing/p/4550246.html" target="_blank" rel="noopener">C/C++预处理指令#define,#ifdef,#ifndef,#endif…</a></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础回顾之存储类、链接与内存管理</title>
      <link href="/2017/04/30/2017/4/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/04/30/2017/4/%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B1%BB%E3%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>做技术，越做到后面越觉得基础、底层的才是越难得，也会越有技术含量的。最近做的项目有关音视频、图像处理，涉及到的都死c和c++相关的代码。遇到了问题才发现，c和c++才是通用大法。这两块没学好，那也只有玩一玩应用层、UI这些东西。抽空整理下。</p><a id="more"></a><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>四种：</p><ul><li>多个文件共享的变量</li><li>特定文件每个函数共享的变量</li><li>某个函数特有的变量</li><li>某个函数一个代码块的变量</li></ul><p>一个C变量的作用域可以是代码块作用域，函数作用域，文件作用域，基本概念就不说了。</p><p>需要注意的几点：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里<code>i</code>的作用域是整个for循环。</p><p>一个所有函数之外定义的变量就是文件作用域。整个文件可以访问该变量。也叫全局作用域</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"CTest.h"</span></span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>外部链接：多个文件使用</li><li>内部链接：当前文件使用</li><li>空连接：函数代码块使用</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 外部链接</span><span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 内部链接、文件私有</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储时期-变量在内存中生存的时间"><a href="#存储时期-变量在内存中生存的时间" class="headerlink" title="存储时期(变量在内存中生存的时间)"></a>存储时期(变量在内存中生存的时间)</h2><ul><li>静态存储：程序执行期间一直存储，<strong>文件作用域（内部和外部）的变量具有静态存储时期</strong>。文件作用域中特别注意用static表明链接类型而并非存储时期。一个使用了static生命的文件作用域变量表示这个变量具有内部作用域。</li><li>自动存储：代码块作用域的变量。</li></ul><p>5种存储类：自动，寄存器，代码作用域静态，外部静态，内部静态。下面这种表总结了上面的多种情况。</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-a707c14717537c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>重点说明一下寄存器变量：寄存处变量是存储在CPU的寄存器中，比一般的内存要快很多。但是有一个问题就是寄存器变量的地址是无法获取的。</p></blockquote><p>把变量定义下所有函数之外，就创建了一个外部变量，为了使程序清晰，可以在使用使用外部变量的函数中通过extern来再次声明。如果变量在别的文件定义，使用extern来声明就是必须的。<strong>这里想一想OC中的写第三方库的时候，为了让其他模块能够访问某个变量就是通过这种方式来达到目的的。</strong></p><p>比如YYWebImageSetter中。<br>.h</p><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">extern NSString *const _YYWebImageFadeAnimationKey;extern const NSTimeInterval _YYWebImageFadeTime;extern const NSTimeInterval _YYWebImageProgressiveFadeTime;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>.m</p><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">NSString *const _YYWebImageFadeAnimationKey = @"YYWebImageFade";const NSTimeInterval _YYWebImageFadeTime = 0.2;const NSTimeInterval _YYWebImageProgressiveFadeTime = 0.4;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数也是具有存储类。<strong>函数默认是外部的，可以被其他文件中的函数调用，静态函数只可以在定义它的文件中使用（用static）</strong></p><blockquote><p>使用static可以防止名字的冲突，为文件定义一个私有的变量或者函数。<strong>想想平时我们在定义常量的时候，有时候会出现冲突，OC中用static解决的。应该有些同学有印象的。</strong></p></blockquote><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>系统自动分配内存：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> x<span class="token punctuation">;</span><span class="token keyword">char</span> hello <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>系统将会预留出存储float或字符串的足够内存空间。也可以指定预留多少内存空间：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> plates<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>声明了100个内存位置，每个位置可以存储一个int值。这里的plate和上面的x、hello变量可以理解为内存的标识符。所以我们可以用x、hello来标识、获取这些内存数据。</p><h3 id="malloc-amp-amp-free-amp-amp-calloc"><a href="#malloc-amp-amp-free-amp-amp-calloc" class="headerlink" title="malloc&amp;&amp;free&amp;&amp;calloc"></a>malloc&amp;&amp;free&amp;&amp;calloc</h3><p>用于动态开辟内存。函数<code>void* malloc( size_t size );</code></p><p>函数说明</p><pre><code>Allocates size bytes of uninitialized storage.If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to free).malloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.A previous call to free or realloc that deallocates a region of memory synchronizes-with a call to malloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by malloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory.</code></pre><p>传入所需要的内存字节数，然后malloc找到内存中一个大小适合的快，内存是匿名的，<strong>不像上面可以用定义float x;x用于标识。不过返回的是一个开辟内存的第一个字节的地址。虽然没有为它指定名字，但是我们可以通过指针来接受返回的值来访问那块内存。</strong></p><p>因为char代表一个字节，所以经常将malloc定义为指向char的指针类型。但是后来又了新的类型——————通用型指针（void <code>*</code>）。这样就可以返回其他类型的了。特别注意<strong>如果malloc找不到所需的空间，就会返回空指针。比如传入一个负数就会返回NULl</strong></p><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">double *dbl;dbl = malloc(30 * sizeof(double));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请求30个double类型值的空间，并把dbl指向该空间的所在的起始位置。然后就可以使用数组那样使用它。<strong>简单来讲可以dbl[0],dbl[1]访问</strong></p><p>开辟了内存，必定要释放内存。用free释放内存。对应到OC就是那句内存管理的至理名言<strong>谁开辟、谁释放（alloc、release）</strong></p><p>一次malloc，应该调用一次free。free的参数是malloc返回的地址，释放掉先前分配的内存。不能使用free来释放通过其他形式分配的内存，比如声明一个数组。</p><h3 id="例子强调一下free的重要性"><a href="#例子强调一下free的重要性" class="headerlink" title="例子强调一下free的重要性"></a>例子强调一下free的重要性</h3><pre><code>void memoryTest() {    double array[2000];    for (int i = 0; i&lt; 1000; i++) {        testCopy(array, 2000);    }}void testCopy(double arr[], int count) {    double *temp = (double *)malloc(count * sizeof(double));    // No free}</code></pre><p>第一次调用testCopy,创建指针temp,并使用malloc开辟了2000 <em> 16，一个32000个字节。当函数终止，temp作为自动变量被销毁，<em>*但是它指向的32000个字节的内存仍然存在，并且无法访问这些内存，因为地址不见了（temp销毁），由于没有调用free,那么就不可以再次使用这些内存。</em></em></p><p>第二次调用testCopy，又创建一个temp,但是第一次的32000字节的块已经不能再用了。所以malloc不得不再去开辟一块新的内存地址。当函数终止，这块内存同样没有调用free,创建的内存同样不能被访问。</p><blockquote><p>循环1000次，就是32000000个字节。已经有3200万字节在内存中中不能使用。<strong>这就是在做iOS开发中MRC时代经常遇到的内存泄漏。</strong></p></blockquote><p>为了说明问题，这里我用xcode测试了一下，把循环次数改为了100000000。</p><ul><li><p>没有加free之前。<br><img src="http://upload-images.jianshu.io/upload_images/664334-3af8bb29b5425122.gif?imageMogr2/auto-orient/strip" alt></p></li><li><p>加free之后。<br><img src="http://upload-images.jianshu.io/upload_images/664334-04e8d9cb332347d7.gif?imageMogr2/auto-orient/strip" alt></p></li></ul><p>对比上面很明显能看到两者的区别。</p><p>calloc与malloc最大的区别是calloc会把开辟的全部位置为0。使用方式和malloc类似，同样需要用free释放内存。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">long</span> <span class="token operator">*</span>test<span class="token punctuation">;</span>test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开辟了可以容乃100个long类型的内存空间。</p><h2 id="常见的限定词"><a href="#常见的限定词" class="headerlink" title="常见的限定词"></a>常见的限定词</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>普通类型前，标识这个值不可变。而用在指针的时候情况就分多种了</p><p>因为指针存在，指针不可变还是指向的值不可变。</p><ul><li><code>const float *pf</code>（等同于<code>float const * pf</code>）:表示pf指向一个常量浮点型数值。<strong>但是pf本身的值可以改变。比如它可以指向另一个const值</strong></li><li><code>float * const pt</code>:表示pt是一个常量指针，他总是指向同一个地址，但是地址里面的内容可以改变。</li><li><code>const float * const pfc</code>:表示pfc是个常量指针，而且指向的地址内容也不能变。</li></ul><p><strong>记忆方式，const位于<code>*</code>左边代表指向的值不可变，位于<code>*</code>右边指针不可变</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dlib系列之在iOS中提取人脸特征点（第一篇）</title>
      <link href="/2017/04/23/2017/4/Dlib%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9C%A8iOS%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BA%BA%E8%84%B8%E7%89%B9%E5%BE%81%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/"/>
      <url>/2017/04/23/2017/4/Dlib%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9C%A8iOS%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BA%BA%E8%84%B8%E7%89%B9%E5%BE%81%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近因为工作需要，在研究人脸识别，图像处理这块，这里简单记录一下。今天主要讲讲前期的准备工作，比如由C++制作OC的静态库。</p><a id="more"></a><h2 id="什么是dlib"><a href="#什么是dlib" class="headerlink" title="什么是dlib"></a>什么是dlib</h2><p><img src="http://dlib.net/dlib-logo.png" alt><br>摘自官网：</p><blockquote><p>Dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real world problems. It is used in both industry and academia in a wide range of domains including robotics, embedded devices, mobile phones, and large high performance computing environments. Dlib’s open source licensing allows you to use it in any application, free of charge.</p></blockquote><p>简单来讲Dlib是一套包含机器学习算法的C++工具集，用来解决现实生活的问题。最为重要的就是free of charge免费。</p><p>这个C++工具集包含了很多牛逼的特性：</p><ul><li>机器学习算法</li><li>数值算法</li><li>图像模型接口算法</li><li><strong>图片处理</strong><ul><li>高质量的人脸检测。<strong>这个部分是今天我们要用到的</strong></li></ul></li><li>线程操作</li><li>网络操作</li><li>…..</li></ul><p>一句话，反正这个库就是牛逼。</p><p><a href="http://dlib.net/" target="_blank" rel="noopener">官网文档</a><br><a href="https://github.com/davisking/dlib" target="_blank" rel="noopener">GitHub地址</a></p><h2 id="打包成静态库"><a href="#打包成静态库" class="headerlink" title="打包成静态库"></a>打包成静态库</h2><p>由于dlib是用c++写的，虽然xcode知识Swift、OC、C、C++混编，但是对于这种三房库最好打成静态库。</p><p>接下来就大致介绍一下如何完成这个步骤。</p><ul><li><p>前提条件</p><ol><li>X11(这个之前的mac是包含了的，但是现在需要自己下载安装)下载地址<a href="https://www.xquartz.org/" target="_blank" rel="noopener">X11</a>。相关的介绍可以看看这里<a href="https://support.apple.com/en-us/HT201341" target="_blank" rel="noopener">介绍</a></li><li>Xcode</li><li>cmake，如何之前玩过c或者c++这个应该安装过了。如果没安装过可以通过homebrew安装</li></ol></li><li><p>步骤</p><ol><li><p>将项目dlib clone 到本地。项目地址<code>https://github.com/davisking/dlib.git</code></p></li><li><p>在终端里面打开刚才clone下来的项目里面的examples目录。<br> <img src="http://upload-images.jianshu.io/upload_images/664334-aeb8b4d7799825ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>终端执行<code>mkdir build</code></p></li><li><p>终端执行<code>cd build</code></p></li><li><p>终端执行<code>cmake -G Xcode ..</code></p></li><li><p>终端执行<code>cmake --build . --config Release</code> <strong>这一步等的时间比较长，耐心一点</strong></p><p>如果没有出现异常，最后会出现<br><img src="http://upload-images.jianshu.io/upload_images/664334-5c9a313e90678b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>这就说明成功了。</p></li></ol></li></ul><p>这一串命令最终会产生一个<code>dlib_build</code>目录，里面就是编译这个库的xcode项目。在这个项目里面可以根据你的需要设置这个SDK支持的架构和支持的平台（iOS、Mac）。</p><p>特别注意，需要额外添加一些编译标识和dlib依赖的三方库。<strong>可以直接根据examples.xcproject项目来查看具体的设置</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/664334-676f7df31ab560b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>通过上面的方式就制作好了一个包含dlib的静态库。</p><p>下面是生产.a的目录<br><img src="http://upload-images.jianshu.io/upload_images/664334-d06f9ffd05e2368e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>查看.a支持的架构可以通过<code>lipo -info xxx.a</code>查看。比如我这里就是<br><img src="media/14929190666528/14929242438453.jpg" alt></p><h2 id="将静态库添加到项目中去"><a href="#将静态库添加到项目中去" class="headerlink" title="将静态库添加到项目中去"></a>将静态库添加到项目中去</h2><p>刚才制作好了libdlib.a。接下来就是去使用它。</p><ol><li><p>将刚才生产的.a和dlib的库文件拖到同一个文件夹。<br><img src="http://upload-images.jianshu.io/upload_images/664334-05f88ee04ea3e683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>将这两个加到项目实体中。<br><img src="http://upload-images.jianshu.io/upload_images/664334-e921cf07256210d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>然后将libdlib.a拖到项目中，<strong>特别注意不要把库文件dlib目录下的文件拖进去。</strong>在文件中引用一下库文件。</p></li></ol><pre><code>#include &lt;dlib/image_processing.h&gt;#include &lt;dlib/image_io.h&gt;</code></pre><p>之后会报找不到头文件。</p><ol start="4"><li><p>然后设置文件夹搜索<br><img src="http://upload-images.jianshu.io/upload_images/664334-b600e7f7db4987b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>然后编译，不出意外会报如下的错。<br><img src="http://upload-images.jianshu.io/upload_images/664334-2eb732ae1cf25bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>添加需要的framework。非常重要。麻蛋让我踩了好久的坑。<br><img src="http://upload-images.jianshu.io/upload_images/664334-7493b62140bed4da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li><li><p>然后添加<code>Custom Compiler Flags</code>中的<code>Other C Flags</code>。下面这些flag定义了在预处理阶段对libdlib.a的某些特性的宏。</p><ul><li>-DDLIB_JPEG_SUPPORT</li><li>-DDLIB_NO_GUI_SUPPORT</li><li>-DNDEBUG -DDLIB_USE_BLAS</li><li>-DDLIB_USE_LAPACK<br><img src="http://upload-images.jianshu.io/upload_images/664334-e33dc50275c14150.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li><li><p>添加预处理宏Preprocessor Macros。</p><ul><li>DLIB_JPEG_SUPPORT</li><li>DLIB_NO_GUI_SUPPORT</li><li>NDEBUG -DDLIB_USE_BLAS</li><li>DLIB_USE_LAPACK<br><img src="http://upload-images.jianshu.io/upload_images/664334-0e2c2fe9987b10f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li><li><p>现在编译就能够完全通过了。</p></li></ol><p>接下来就是进行代码编写实现人脸特征点提取了。下次再讲吧！</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://stackoverflow.com/questions/39807835/how-to-use-dlib-in-xcode-c-console-application" target="_blank" rel="noopener">How to use dlib in Xcode C++ console application</a><br><a href="http://www.learnopencv.com/facial-landmark-detection/" target="_blank" rel="noopener">Facial Landmark Detection</a><br><a href="http://stackoverflow.com/questions/23634940/opencv2-framework-not-compile-with-linker-flag-objc" target="_blank" rel="noopener">opencv2.framework not compile with linker flag -ObjC</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈位枚举NS_OPTIONS</title>
      <link href="/2017/04/22/2017/4/%E8%B0%88%E8%B0%88%E4%BD%8D%E6%9E%9A%E4%B8%BENS_OPTIONS/"/>
      <url>/2017/04/22/2017/4/%E8%B0%88%E8%B0%88%E4%BD%8D%E6%9E%9A%E4%B8%BENS_OPTIONS/</url>
      
        <content type="html"><![CDATA[<p>给别人讲问题的时候遇到类似的，顺便就复习下。</p><a id="more"></a><h1 id="谈谈位枚举NS-OPTIONS"><a href="#谈谈位枚举NS-OPTIONS" class="headerlink" title="谈谈位枚举NS_OPTIONS"></a>谈谈位枚举NS_OPTIONS</h1><p>在iOS开发中枚举大家用得最多的应该是NS_ENUM。NS_ENUM也没什么好讲的。主要来讲讲位枚举NS_OPTIONS。</p><p>下面是他们在Foundation.framework的NSObjCRuntime.h的定义</p><pre><code>#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type#if (__cplusplus)#define NS_OPTIONS(_type, _name) _type _name; enum : _type#else#define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type#endif#else#define NS_ENUM(_type, _name) _type _name; enum#define NS_OPTIONS(_type, _name) _type _name; enum#endif</code></pre><p>其实从枚举定义来看，NS_ENUM和NS_OPTIONS本质是一样的，仅仅从字面上来区分其用途。NS_ENUM是通用情况，NS_OPTIONS一般用来定义具有位移操作或特点的情况（bitmask掩码)。</p><h2 id="与、或操作"><a href="#与、或操作" class="headerlink" title="与、或操作"></a>与、或操作</h2><p>先讲讲关于二进制的位于操作。可能好多的同学都有些忘了。这里复习下。</p><table><thead><tr><th>位操作</th><th>解释</th><th>例子</th><th>应用</th></tr></thead><tbody><tr><td>按位与（&amp;）</td><td><strong>有0则0</strong>，当俩位同时为1时返回1.</td><td>4=0000 0000 0000 0100 &amp;7 =0000 0000 0000 0111= 0000 0000 0000 0100</td><td>1.清零<br>2.获取一个数据的指定位 <br>3.保留数据区的特定位<br></td></tr><tr><td>按位或（`</td><td>`）</td><td><strong>有1则1</strong>，只要有一位为1则即可返回1.</td><td>5 = 0000 0000 0000 0101`</td></tr></tbody></table><blockquote><p>&lt;&lt;:左移运算符。左移k位 相当于 *2^k<br>＞＞:右移运算符。右移k位 相当于/2^k</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>NS_OPTIONS位枚举的特点是可以使用位运算来处理枚举值，<strong>实际使用中可以用一个变量存储多个枚举值，表示互不影响的多个设置。</strong>比如系统中的UIViewAutoresizing定义如下。</p><pre><code>enum UIViewAutoresizing {    UIViewAutoresizingNone                 = 0, // 000000    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0, // 000001    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,// 000010    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,// 000100    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,// 001000    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,// 010000    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,// 100000}</code></pre><p>为了说明问题这里就用UIViewAutoresizing举个例子。上面把对应的二进制写在了后面。现在要实现视图的宽和高自适应，<code>UIViewAutoResizingFlexibleWidth| UIViewAutoresizingFlexibleHeight。</code>。</p><p>一般会这样写：</p><pre><code>UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;</code></pre><p>转换为二进制计算一下。</p><pre><code>UIViewAutoresizing resizing = 000010 |010000 = 010010</code></pre><p>这样就实现了变量保存多个枚举值。那么如何判断变量是否包含某个枚举值了，这的通过与操作。比如我要判断是否包含了<code>UIViewAutoresizingFlexibleWidth</code></p><pre><code>if (resizing &amp; UIViewAutoresizingFlexibleWidth) {       // UIViewAutoresizingFlexibleWidth is set}</code></pre><p>转换为二进制：</p><pre><code>if (010010 &amp; 000010) {       // UIViewAutoresizingFlexibleWidth is set}</code></pre><p>010010 &amp; 000010 = 000010 很明显不等于0。所以为YES。那么用一个不包含的试一下。</p><pre><code>if (resizing &amp; UIViewAutoresizingFlexibleTopMargin) {       // UIViewAutoresizingFlexibleTopMargin is set}</code></pre><p>转为二进制</p><pre><code>if (010010 &amp; 001000) {       // UIViewAutoresizingFlexibleTopMargin is set}</code></pre><p>很明显010010 &amp; 001000 = 0，所以能够知道resizing不包含UIViewAutoresizingFlexibleTopMargin。</p><p><strong>通过以上的这种方式实现了一个变量保存多个枚举值。也就是NS_OPTIONS的原理。</strong></p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ol><li>枚举命名方式尽量用系统的风格，比如枚举名为UIViewAutoresizing，具体的值为UIViewAutoresizingNone。简单来讲就是（枚举名+状态）</li><li>如果要实现一个变量保存多个枚举值就用NS_OPTIONS。个人觉得用NS_OPTIONS完全可以替代NS_ENUM。只需要在使用的时候不用与、或操作就可以了</li><li>用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li><li>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</li><li><strong>预留一个枚举值，用于扩展或者用于表示没有的情况</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> recover </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base recover </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决mac下Spotlight和Notes(记事本)搜索失效</title>
      <link href="/2017/04/17/2017/4/%E8%A7%A3%E5%86%B3mac%E4%B8%8BSpotlight%E5%92%8CNotes%E6%90%9C%E7%B4%A2%E5%A4%B1%E6%95%88/"/>
      <url>/2017/04/17/2017/4/%E8%A7%A3%E5%86%B3mac%E4%B8%8BSpotlight%E5%92%8CNotes%E6%90%9C%E7%B4%A2%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>由于换了mac，之前的习惯是把一些常用的文字资料放在Notes（记事本）中，这样可以在手机和电脑中实现资料互通。但是最近换了新mac，notes能够从Icloud中拿到同步的资料，但是始终搜索不出来。而且spotlight搜索也不起任何作用。这里记录一下解决的方法。</p><a id="more"></a><blockquote><p><strong>我的是英文环境，对应到中文环境应该一样的操作</strong></p></blockquote><h2 id="解决spotlight不能搜索"><a href="#解决spotlight不能搜索" class="headerlink" title="解决spotlight不能搜索"></a>解决spotlight不能搜索</h2><ol><li>尝试重建索引<code>sudo mdutil -E /</code>默认会建立磁盘下所有索引，如果想指定某个外接磁盘或者其他磁盘可以使用<code>sudo mdutil -E /Volumes/MiniMe/</code>对指定的磁盘建立索引。如果出现<code>invalid destination portSpotlight server is disabled.</code>则进行下面的操作。<br> 1.1 开启Splot服务:<code>sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</code>。顺便提一下关闭的命令<code>sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</code>，然后再建索引。</li><li>如果上面操作还是不行，在执行强制重建索引命令<code>sudo mdutil -a -i on</code>。我就是通过这个命令解决的。</li></ol><h2 id="解决Notes-记事本-不能搜索"><a href="#解决Notes-记事本-不能搜索" class="headerlink" title="解决Notes(记事本)不能搜索"></a>解决Notes(记事本)不能搜索</h2><p>这个问题其实是让人非常痛苦的，因为notes里面保存了自己很多的资料。解决这个问题其实很简单，<strong>将iCloud同步过来的一个文件夹，拖到on my mac下就可以了。具体方法就是，点击文件夹，按住option键，拖到on my mac下就可以了</strong></p><p>猜测通过这种方式，重建了对于icloud的索引，所以能够搜索到了。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://www.cultofmac.com/154458/re-index-spotlight-from-the-terminal-re-gain-valuable-time-for-life-os-x-tips/" target="_blank" rel="noopener">Re-Index Spotlight from the Terminal</a><br><a href="http://www.cultofmac.com/211559/enable-spotlight-indexing-to-re-index-your-mac-hard-drive-os-x-tips/" target="_blank" rel="noopener">Enable Spotlight Indexing To Re-Index Your Mac Hard Drive </a><br><a href="https://apple.stackexchange.com/questions/216462/how-can-i-force-an-index-of-all-the-apple-notes" target="_blank" rel="noopener">How can I force an index of all the Apple notes?</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS音频相关基础整理及参考文章整理</title>
      <link href="/2017/04/16/2017/4/iOS%E9%9F%B3%E9%A2%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E5%8F%8A%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/"/>
      <url>/2017/04/16/2017/4/iOS%E9%9F%B3%E9%A2%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E5%8F%8A%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>来这边第一天就感受到了技术氛围浓厚，音视频方面全是用自己的服务，之前很少自己写底层的顿时，感觉压力山大。接到的第一个任务就是关于iOS音视频处理，这里简单记录下自己看过的一些音频相关知识点，视频相关后续放出。</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>现实生活中，我们听到的声音都是时间连续的，我们称为这种信号叫<code>模拟信号</code>。模拟信号需要进行<code>数字化</code>以后才能在计算机中使用。目前我们在计算机上进行音频播放都需要依赖于音频文件。</p><p><strong>音频文件的生成过程是将<code>声音信息采样</code>、<code>量化</code>和<code>编码</code>产生的<code>数字信号</code>的过程</strong>。人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，因此音频文件格式的最大带宽是20KHZ。根据奈奎斯特的理论，<strong>只有采样频率<code>高于</code>声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在40~50KHZ，比如最常见的CD音质采样率44.1KHZ。</strong></p><p>对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation），<code>简称PCM</code>。<strong>PCM数据是最原始的音频数据完全无损</strong>，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，<strong>其中有无损压缩（ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种</strong>。</p><p>位速/比特率/码率描述的都是一个东西，<strong>是指在一个数据流中每秒钟能通过的信息量</strong>，<code>代表了压缩质量</code>，比如MP3常用码率有128kbit/s、160kbit/s、320kbit/s等等，越高代表着声音音质越好。MP3中的数据有ID3和音频数据组成，ID3用于存储歌名、演唱者、专辑、音轨等我们可以常见的信息。</p><h3 id="简化声音处理流程"><a href="#简化声音处理流程" class="headerlink" title="简化声音处理流程"></a>简化声音处理流程</h3><p>模拟信号 -&gt; 输入设备（传递电压值）-&gt; 声卡(经过采样跟量化（即设置声音大小等各种值）) -&gt; 磁盘（文件） -&gt; 声卡 -&gt; 输出设备 -&gt; 模拟信号</p><p>我们声音在物理上用波形表示，那么我们将这些波形称作为模拟信号。而我们计算机磁盘只能存储（01010101）的格式。我们将模拟信号转换成能够被磁盘存储的格式（010101）称之为数字信号。这个转换的过程我们叫模数转换。</p><p>我们发出来的声音（模拟信号）是连续的，我们如果要一直的对模拟信号进行转化，产生的数字信号会很大。那么我们就要采样，而<strong>采样精度就是每秒计算机对模拟信号进行采样的次数</strong>。最常见的采样精度就是上面提到的44.1khz/s,这个是经过大师们多年研究得出的数据，低于这个数据，效果就会很差，而高于这个数据，效果的差距不是很明显。</p><p>采样后会后是变成了（0101010110100101…），那声音的音量是有大小的，那这串数据，怎样表示声音的大小呢？ 这就涉及到了比特率，它是指在一个数据流中每秒钟能通过的信息量。 比特率就是将声音的大小划分为多少等级。举例下：8比特，在二进制中，表示有8位，表示的十进制的值就是0（00000000）～256（11111111），那每个数值就代表着一个声音大小。</p><blockquote><p>过程可以简化为：波形在经过输入设备的时候，会产生电压值。声卡通过计算采样率、比特率，以每秒几次的频率去获取这些电压值，然后将这些电压值以几bit的形式转换成数字信号。计算机将数据格式存储为文件。</p></blockquote><p><strong>文件是用来装数字信号的</strong>，文件包括了比特率、采样率、声道、编码方式、以及被编码过后的数字信号。</p><p>文件格式就是制造者自己规定的一种名称，在每个文件格式都会特定支持几种编码格式。<strong>打个比方就是文件就是一个容器，里面可以装不同的水，有的可以装一种，有的可以装好几种。</strong></p><p>经过采样后的数字信号很大，有时候我们不需要这么大的，所以我们就要进行编码压缩，当然压缩技术都是有损的。在不大影响音频的效果的情况下，<strong>舍弃掉一些高频或者低频的数据</strong>。</p><h3 id="采样频率-采样精度"><a href="#采样频率-采样精度" class="headerlink" title="采样频率(采样精度)"></a>采样频率(采样精度)</h3><p>采样频率是指单位时间内对声音模拟信号的采样次数。采样率类似于视频的帧数，比如电影的采样率是24Hz。<strong>当我们把采样到的一个个静止画面再以采样率同样的速度回放时，看到的就是连续的画面。</strong>同样的道理，把以44.1kHZ采样率记录的CD以同样的速率播放时，就能听到连续的声音。显然，这个采样率越高，听到的声音和看到的图像就越连贯。</p><h3 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h3><p>采样位数可以理解为采集卡处理声音的解析度。电脑中的声音文件是用数字0和1来表示的。连续的模拟信号按一定的采样频率经数码脉冲取样后，<strong>每一个离散的脉冲信号被以一定的量化精度量化成一串二进制编码流</strong>，<code>这串编码流的位数</code>即为采样位数，也称为量化精度。</p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>可以理解为每种音频格式不同的编解码方式，而iOS下这些编码方式被集中到一个枚举中.</p><pre class="line-numbers language-Objective-c"><code class="language-Objective-c">CF_ENUM(AudioFormatID){    kAudioFormatLinearPCM               = 'lpcm',    kAudioFormatAC3                     = 'ac-3',    kAudioFormat60958AC3                = 'cac3',    kAudioFormatAppleIMA4               = 'ima4',    kAudioFormatMPEG4AAC                = 'aac ',    kAudioFormatMPEG4CELP               = 'celp',    kAudioFormatMPEG4HVXC               = 'hvxc',    kAudioFormatMPEG4TwinVQ             = 'twvq',    kAudioFormatMACE3                   = 'MAC3',    kAudioFormatMACE6                   = 'MAC6',    kAudioFormatULaw                    = 'ulaw',    kAudioFormatALaw                    = 'alaw',    kAudioFormatQDesign                 = 'QDMC',    kAudioFormatQDesign2                = 'QDM2',    kAudioFormatQUALCOMM                = 'Qclp',    kAudioFormatMPEGLayer1              = '.mp1',    kAudioFormatMPEGLayer2              = '.mp2',    kAudioFormatMPEGLayer3              = '.mp3',    kAudioFormatTimeCode                = 'time',    kAudioFormatMIDIStream              = 'midi',    kAudioFormatParameterValueStream    = 'apvs',    kAudioFormatAppleLossless           = 'alac',    kAudioFormatMPEG4AAC_HE             = 'aach',    kAudioFormatMPEG4AAC_LD             = 'aacl',    kAudioFormatMPEG4AAC_ELD            = 'aace',    kAudioFormatMPEG4AAC_ELD_SBR        = 'aacf',    kAudioFormatMPEG4AAC_ELD_V2         = 'aacg',        kAudioFormatMPEG4AAC_HE_V2          = 'aacp',    kAudioFormatMPEG4AAC_Spatial        = 'aacs',    kAudioFormatAMR                     = 'samr',    kAudioFormatAMR_WB                  = 'sawb',    kAudioFormatAudible                 = 'AUDB',    kAudioFormatiLBC                    = 'ilbc',    kAudioFormatDVIIntelIMA             = 0x6D730011,    kAudioFormatMicrosoftGSM            = 0x6D730031,    kAudioFormatAES3                    = 'aes3',    kAudioFormatEnhancedAC3             = 'ec-3'};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较通俗的理解：封装格式和编码的关系，就是和酒瓶与酒的关系差不多，而播放器就是开酒器。为了可以喝更好的酒，最好先了解酒是什么酒，酒瓶是什么酒瓶，怎么使用开酒器开酒瓶，码率或者可以比喻做酒的原料。对于同一个酒瓶和做同一种酒的情况下，如果原料太少，又要要求用酒把酒瓶灌满，此时只好兑水了，酒的品质就会变差了。然而，如果原料太多，又会造成原料浪费。所以要做好酒，我们就需要充足的原料。</p><p><strong>封装格式就是文件格式，编码就是编码格式。</strong></p><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="播放流程简化"><a href="#播放流程简化" class="headerlink" title="播放流程简化"></a>播放流程简化</h3><p>这里以播放MP3文件为例：</p><ol><li>读取MP3文件</li><li>解析采样率、码率、时长等信息，分离MP3中的音频帧</li><li>对分离出来的音频帧解码得到PCM数据</li><li>对PCM数据进行音效处理（均衡器、混响器等，非必须）</li><li>把PCM数据解码成音频信号</li><li>把音频信号交给硬件播放<br>重复1-6步直到播放完成</li></ol><p>采集和量化的过程和上面的过程基本相反。</p><p>iOS对音频处理的封装</p><p><img src="http://msching.github.io/images/iOS-audio/api-architectural-layers.png" alt></p><p>上述模块接口说明：</p><ul><li>Audio File Services：读写音频数据，可以完成播放流程中的第2步；</li><li>Audio File Stream Services：对音频进行解码，可以完成播放流程中的第2步；</li><li>Audio Converter services：音频数据转换，可以完成播放流程中的第3步；</li><li>Audio Processing Graph Services：音效处理模块，可以完成播放流程中的第4步；</li><li>Audio Unit Services：播放音频数据：可以完成播放流程中的第5步、第6步；</li><li>Extended Audio File Services：<strong>Audio File Services和Audio Converter services的结合体；<br>AVAudioPlayer/AVPlayer(AVFoundation)：高级接口，可以完成整个音频播放的过程（包括本地文件和网络流播放，第4步除外）；一般我们都是在这层操作</strong></li><li>Audio Queue Services：高级接口，可以进行录音和播放，可以完成播放流程中的第3、5、6步；</li><li>OpenAL：用于游戏音频播放，基本没用到过</li></ul><h2 id="常用的第三方库"><a href="#常用的第三方库" class="headerlink" title="常用的第三方库"></a>常用的第三方库</h2><p><a href="https://github.com/syedhali/EZAudio#toc24" target="_blank" rel="noopener">EZAudio</a>这是OC版本，目前已经不再维护。作者转向了Swift项目<a href="https://github.com/audiokit/AudioKit" target="_blank" rel="noopener">AudioKit</a>。这个库也很牛逼。</p><h2 id="实时播放"><a href="#实时播放" class="headerlink" title="实时播放"></a>实时播放</h2><p><a href="http://www.jianshu.com/p/feeb107b6657" target="_blank" rel="noopener">AAC 到 PCM 音频解码</a><br><a href="http://www.jianshu.com/p/279a9e5b36b5" target="_blank" rel="noopener">使用AudioToolbox播放AAC</a></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="https://developer.apple.com/library/content/documentation/MusicAudio/Conceptual/CoreAudioOverview/CoreAudioEssentials/CoreAudioEssentials.html#//apple_ref/doc/uid/TP40003577-CH10-SW1" target="_blank" rel="noopener">Core Audio Essentials</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><a href="http://blog.sina.com.cn/s/blog_7a162d000101befe.html" target="_blank" rel="noopener">IOS开发笔记之音频（一）</a><br><a href="https://brownfeng.github.io/2016/07/28/iOS%E9%9F%B3%E9%A2%91%E7%B3%BB%E5%88%97(%E5%9B%9B)/" target="_blank" rel="noopener">iOS音频系列(四)–音频的文件格式和数据格式</a>  基本概念解释<br><a href="https://brownfeng.github.io/2016/07/25/iOS%E9%9F%B3%E9%A2%91%E7%B3%BB%E5%88%97(%E4%B8%80)/" target="_blank" rel="noopener">iOS音频系列(一)–音频基础</a>  对一些基本概念的解释</p><p><a href="http://xuzichao.com/2015/03/15/IOS%20%E9%9F%B3%E9%A2%91%E4%B8%80%E8%A7%88/" target="_blank" rel="noopener">IOS 音频一览</a> 文章后面部分有对特定问题的解决，值得一看</p><h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><p><a href="http://msching.github.io/blog/categories/ios-audio/" target="_blank" rel="noopener">iOS音频播放系列</a> 强力推荐 🎯<br><a href="http://justinyangjing.github.io/2016/07/14/iOS%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">iOS音频编程之实时语音通信</a>用到了一些偏底层的<br><a href="http://chenhu1001.github.io/archives/" target="_blank" rel="noopener">iOS直播系列</a><br><a href="http://www.jianshu.com/p/502a49c8dcd3" target="_blank" rel="noopener">iOS在线音频流播放</a>这个作者也是非常牛逼，关于图像处理和音频处理的都可以看看。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音频处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAShapeLayer大法(未完)</title>
      <link href="/2017/04/06/2017/4/CAShapeLayer%E5%A4%A7%E6%B3%95/"/>
      <url>/2017/04/06/2017/4/CAShapeLayer%E5%A4%A7%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>好久都没有研究iOS动画了，昨天看到了一个不规则view。当时就想应该是用CAShapeLayer做的。于是这里回顾一下CAShapeLayer、CADisplayLink、UIBezierPath，mask。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于iOS动画，已经有许许多多的例子和博客写过。这里也只是复习一下，如果深入了解。可以看一看业界一本公认的动画书籍<a href="http://download.csdn.net/detail/qqyinzhe/7357517" target="_blank" rel="noopener">iOS Core Animation Advanced Techniques</a>。里面的示例代码也有源码地址在<a href="https://github.com/pflnh/CoreAnimationCode" target="_blank" rel="noopener">CoreAnimationCode</a>。</p><h2 id="几个类的说明"><a href="#几个类的说明" class="headerlink" title="几个类的说明"></a>几个类的说明</h2><h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><ul><li><p>A CADisplayLink object is a timer object that allows <strong>your application to synchronize its drawing to the refresh rate of the display</strong></p></li><li><p>大致有以下几点需要注意。</p><ol><li>CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器</li><li>一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到  CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。</li><li>可以通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector</li><li>CADisplayLink 不能被继承。</li></ol></li><li><p>附带提一下和与 NSTimer 有什么不同</p><ol><li>NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。</li><li>CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。</li><li>NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。</li></ol></li></ul><h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><ul><li>The UIBezierPath class lets you define a path consisting of straight and curved line segments and render that path in your custom views. You use this class initially to specify just the geometry for your path. Paths can define simple shapes such as rectangles, ovals, and arcs or they can define complex polygons that incorporate a mixture of straight and curved line segments. After defining the shape, you can use additional methods of this class to render the path in the current drawing context.</li></ul><p>建议先看看<a href="http://blog.csdn.net/crayondeng/article/details/11093689" target="_blank" rel="noopener">iOS UIBezierPath类 介绍</a></p><p> UIBezierPath类可以创建基于矢量的路径，它是Core Graphics框架关于CGPathRef类型数据的封装，利用它创建直线或者曲线来构建我们想要的形状，每一个直线段或者曲线段的结束位置就是下一个线段开始的地方。这些连接的直线或者曲线的集合成为subpath。一个UIBezierPath对象的完整路径包括一个或者多个subpath。</p><p>使用步骤：</p><ol><li>创建一个Bezier Path对象。</li><li>使用方法moveToPoint:去设置初始线段的起点。</li><li>添加line或者curve去定义一个或者多个subpath。</li><li>修改UIBezierPath对象跟绘图相关的属性。</li></ol><h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><ul><li>A layer that draws a cubic Bezier spline in its coordinate space</li></ul><p>建议先看看<a href="http://www.cnblogs.com/YouXianMing/p/3678709.html" target="_blank" rel="noopener">CAShapeLayer</a></p><p>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。CAShapeLayer可以用来绘制所有通过CGPath来表示的形状，上面讲到了可以用UIBezierPath来创建任何你想要的路径，使用CAShapeLayer的属性path配合UIBezierPath创建的路径，就可以呈现出我们想要的形状。</p><p><strong>这个形状不一定要闭合，图层路径也不一定是连续不断的，你可以在CAShapeLayer的图层上绘制好几个不同的形状</strong>，但是你只有一次机会去设置它的path、lineWith、lineCap等属性，如果你想同时设置几个不同颜色的多个形状，你就需要为每个形状准备一个图层。</p><h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><ul><li>An optional layer whose alpha channel is used to mask the layer’s content.</li><li>The layer’s alpha channel determines how much of the layer’s content and background shows through. Fully or partially opaque pixels allow the underlying content to show through but fully transparent pixels block that content.</li></ul><p>建议先看看<a href="https://zsisme.gitbooks.io/ios-/content/chapter4/layer-masking.html" target="_blank" rel="noopener">图层蒙板</a></p><p>CALayer有一个属性叫做mask，通常被称为蒙版图层，这个属性本身也是CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子视图，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子视图。不同于一般的subLayer，mask定义了父图层的可见区域，简单点说就是最终父视图显示的形态是父视图自身和它的属性mask的交集部分。</p><p>mask图层的color属性是无关紧要的，<strong>真正重要的是它的轮廓</strong>，mask属性就像一个切割机，父视图被mask切割，相交的部分会留下，其他的部分则被丢弃。</p><p><strong>CALayer的蒙版图层真正厉害的地方在于蒙版图层不局限于静态图，任何有图层构成的都可以作为mask属性，这意味着蒙版可以通过代码甚至是动画实时生成。</strong></p><h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><p>TODO</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://summertreee.github.io/blog/2016/08/07/dong-hua-huang-jin-da-dang-cadisplaylink-and-cashapelayer/" target="_blank" rel="noopener">动画黄金搭档:CADisplayLink &amp; CAShapeLayer</a><br><a href="http://www.cocoachina.com/ios/20160711/17007.html" target="_blank" rel="noopener">关于CAShapeLayer的一些实用案例和技巧</a><br><a href="http://www.cocoachina.com/ios/20160214/15251.html" target="_blank" rel="noopener">放肆地使用UIBezierPath和CAShapeLayer画各种图形</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己整理iOS 常用第三方（持续更新...）</title>
      <link href="/2017/04/06/2017/4/%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86iOS%20%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9/"/>
      <url>/2017/04/06/2017/4/%E8%87%AA%E5%B7%B1%E6%95%B4%E7%90%86iOS%20%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p>网上有很多整理使用第三方库的文章，毕竟是别人使用的，有一些做iOS家喻户晓的比如AFNetworking、SDWebImage，SpringPop这里就不用罗列了。这里主要总结一下自己平时用到的一些第三方，或者自己觉得很有学习必要的第三方。</p><a id="more"></a><h1 id="自己整理iOS-常用第三方-持续更新…-⭐️💖🏅"><a href="#自己整理iOS-常用第三方-持续更新…-⭐️💖🏅" class="headerlink" title="自己整理iOS 常用第三方(持续更新…)⭐️💖🏅"></a>自己整理iOS 常用第三方(持续更新…)⭐️💖🏅</h1><ul><li><a href="http://alcatraz.io/" target="_blank" rel="noopener">Alcatraz插件管理</a></li><li><a href="https://github.com/alcatraz/Alcatraz/issues/498" target="_blank" rel="noopener">GitHub Alcatraz</a></li></ul><h2 id="一、UI"><a href="#一、UI" class="headerlink" title="一、UI"></a>一、UI</h2><h3 id="广告引导"><a href="#广告引导" class="headerlink" title="广告引导"></a>广告引导</h3><ul><li><a href="https://github.com/CoderZhuXH/XHLaunchAd" target="_blank" rel="noopener">XHLaunchAd</a> github最高star</li><li><a href="https://github.com/AllLuckly/LBLaunchImageAd" target="_blank" rel="noopener">LBLaunchImageAd</a>功能不是很强大的，但是满足需求了</li><li><a href="https://github.com/12207480/TYLaunchAnimation" target="_blank" rel="noopener">TYLaunchAnimation</a>相比上面的，功能更少</li><li><a href="https://github.com/amber01/WSDrawCircleProgress" target="_blank" rel="noopener">WSDrawCircleProgress</a>启动右上角原型</li></ul><h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><ul><li><a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="noopener">SDCycleScrollView</a>传统轮播图</li><li><a href="https://github.com/PageGuo/NewPagedFlowView" target="_blank" rel="noopener">NewPagedFlowView</a>视差轮播图</li></ul><h3 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h3><ul><li><a href="https://github.com/wimagguc/ios-custom-alertview" target="_blank" rel="noopener">ios-custom-alertview</a></li><li><a href="https://github.com/lmcd/LMAlertView" target="_blank" rel="noopener">LMAlertView</a></li></ul><h3 id="下载进度提示"><a href="#下载进度提示" class="headerlink" title="下载进度提示"></a>下载进度提示</h3><ul><li><p><a href="https://github.com/PavelKatunin/DownloadButton" target="_blank" rel="noopener">DownloadButton</a><br>  <img src="https://cloud.githubusercontent.com/assets/1636737/7920830/2c4470da-08aa-11e5-99be-e7e9a04479f8.png" alt></p></li><li><p><a href="https://github.com/Guidebook/gbkui-button-progress-view" target="_blank" rel="noopener">gbkui-button-progress-view</a><br>  <img src="https://camo.githubusercontent.com/c21307792a960e90d630440e09d308d7c854dac3/687474703a2f2f706574656c6164612e636f6d2f696d616765732f706c6164612d6c6f6164696e672d627574746f6e2e676966" alt></p></li><li><p><a href="https://github.com/Josin22/JSDownloadView" target="_blank" rel="noopener">JSDownloadView</a><br>  <img src="https://raw.githubusercontent.com/Josin22/JSDownloadView/master/JSDownloadViewDemo/Source/download.gif" alt></p></li><li><p><a href="https://github.com/daria-kopaliani/DAProgressOverlayView" target="_blank" rel="noopener">DAProgressOverlayView</a><br>  <img src="https://github.com/daria-kopaliani/DAProgressOverlayView/raw/master/DAProgressOverlayView.gif" alt></p></li><li><p><a href="https://github.com/Karthus1110/ZYDownloadProgress" target="_blank" rel="noopener">ZYDownloadProgress</a><br>  <img src="https://camo.githubusercontent.com/f457fa6aeb5b8e67bd3f01bb95d41eb0edbc7aad/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313234393530352d613134336261316535333063653337322e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt></p></li><li><p><a href="https://github.com/sgryschuk/SGNavigationProgress" target="_blank" rel="noopener">SGNavigationProgress</a>:导航栏下面进度条<br><img src="https://camo.githubusercontent.com/8a1b67ef84b0353148e89dcbea6b44b22292ac07/68747470733a2f2f7261772e6769746875622e636f6d2f73677279736368756b2f53474e617669676174696f6e50726f67726573732f6d61737465722f53637265656e53686f744d61736b2e706e67" alt></p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3></li><li><p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="noopener">PNChart</a>：国人写的。目前是GitHub排名第一个iOS图表类三方库<br><img src="https://camo.githubusercontent.com/a0c2be4b0b43f84c920e983009ef4c260e234307/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f666172736869642e67686f64732e6769746875622f706e63686172742d6c696e6563686172742d736d6f6f74682e706e67" alt></p><h3 id="区段滑动"><a href="#区段滑动" class="headerlink" title="区段滑动"></a>区段滑动</h3><p><a href="https://github.com/maxep/MXSegmentedPager" target="_blank" rel="noopener">MXSegmentedPager</a><br><img src="https://github.com/maxep/MXSegmentedPager/blob/master/Example-objc/SimpleView.gif" alt></p></li></ul><h2 id="二、应用设置"><a href="#二、应用设置" class="headerlink" title="二、应用设置"></a>二、应用设置</h2><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ul><li><a href="https://github.com/stefanceriu/SCStringsUtility" target="_blank" rel="noopener">SCStringsUtility</a> 快速国际化，通过导入CSV实现快捷导入。</li></ul><h2 id="三、编程语法"><a href="#三、编程语法" class="headerlink" title="三、编程语法"></a>三、编程语法</h2><ul><li><a href="https://github.com/qddnovo/LinkBlock" target="_blank" rel="noopener">LinkBlock</a>  <strong>这个比较优秀</strong><br>objc链式编程语法糖扩展，旨在将冗余逻辑集中，专注于编码的逻辑，使代码结构清晰。</li><li><a href="https://github.com/Draveness/ChainableKit" target="_blank" rel="noopener">ChainableKit</a><br>ChainableKit is a convience way to set up UIKit component with chainable syntax. This framework is inspired by Masonry and JHChainableAnimations.</li><li><a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="noopener">JHChainableAnimations</a><br>Easy to read and write chainable animations in Objective-C and Swift</li></ul><h2 id="四、网络"><a href="#四、网络" class="headerlink" title="四、网络"></a>四、网络</h2><ul><li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a> 对AF的二次封装，猿题库开源，值得学习</li><li><a href="https://github.com/casatwy/RTNetworking" target="_blank" rel="noopener">RTNetworking</a>在iOS架构系列文章中，作者给出了自己的方案，这个网络库就是他的为网络层解耦所写，和YTKNetwork有些类似，适合一些大型项目。</li><li><a href="https://github.com/ShelinShelin/OffLineCache" target="_blank" rel="noopener">OffLineCache</a>数据库离线缓存思路，以及AFN的再次封装，离线状态时从数据库加载数据</li><li><a href="https://github.com/jkpang/PPNetworkHelper" target="_blank" rel="noopener">PPNetworkHelper</a>AFNetworking 3.x 与YYCache封装,一句代码搞定数据请求与缓存,告别FMDB!控制台直接打印json中文字符。但bug是有点多。</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul><li><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>：对Socket完全封装</li></ul><h2 id="五、分类（Category）"><a href="#五、分类（Category）" class="headerlink" title="五、分类（Category）"></a>五、分类（Category）</h2><ul><li><a href="https://github.com/shaojiankui/JKCategories" target="_blank" rel="noopener">JKCategories</a>包含了”JKUIKit.h”,”JKFoundation.h”,”JKCoreData.h”,”JKCoreLocation.h”,”JKMapKit.h”,”JKQuartzCore.h”，比较强大除此之外还有YYKit里面也有许多类似的</li><li><a href="https://github.com/brentsimmons/QSKit" target="_blank" rel="noopener">QSKit</a>star没有上面这个多，里面也有挺多可以看得</li></ul><h2 id="六、动画"><a href="#六、动画" class="headerlink" title="六、动画"></a>六、动画</h2><ul><li><a href="https://github.com/YouXianMing/Animations" target="_blank" rel="noopener">Animations</a> ⭐️⭐️⭐️基本上涵盖了iOS用到的所有动画效果，而且还有一个开源的天气类型app<a href="https://github.com/YouXianMing/YoCelsius" target="_blank" rel="noopener">YoCelsius</a>。作者的博客里面也有很多关于动画方面的文章写得不错。<a href="http://www.cnblogs.com/YouXianMing/tag/%E5%8A%A8%E7%94%BB/" target="_blank" rel="noopener">动画</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 开源 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最近遇到的问题</title>
      <link href="/2017/04/05/2017/4/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/05/2017/4/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>记录一下最近遇到的问题。</p><a id="more"></a><h1 id="libpng-error-CgBI-unhandled-critical-chunk"><a href="#libpng-error-CgBI-unhandled-critical-chunk" class="headerlink" title="libpng error: CgBI: unhandled critical chunk"></a>libpng error: CgBI: unhandled critical chunk</h1><p>这个错是出现在Xcode7.3之后。解决办法：在buildsetting里面，将<code>Remove Text Metadata From PNG Files</code>的值改为<code>NO</code>。默认值为YES.</p><p>因为Xcode7.3之后，默认会将元数据从png格式的文件中移除。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> png </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof、 __typeof 、及__typeof __的区别</title>
      <link href="/2017/04/05/2017/4/typeof%E5%90%84%E4%B8%AA%E4%B8%8D%E5%90%8C/"/>
      <url>/2017/04/05/2017/4/typeof%E5%90%84%E4%B8%AA%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>这个问题是一个同事在看一些第三方源码的时候产生的疑惑，顺便就问了我。</p><a id="more"></a><h1 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h1><p><code>__typeof__()</code>和<code>__typeof()</code>是对c语言的编译扩展，因为标准的c没有包含这样的操作符。标准c要求会对带有双下划线进行编译器预处理，这也是为什么我们在命名自己的方法和变量的时候不能用双下划线。</p><p><code>typeof()</code>准确来讲是和上面两者相同，只是更加强调了这个特性，而这个特性是几乎每一个现代编译器都支持的。<code>typeof()</code>也是对c的扩展，如果用<code>Objective-c</code>写代码，将会用<code>Clang</code>编译器。</p><p>Clang是不支持<code>typeof()</code>的使用，但是从技术上讲，他是在c语法被设置为<code>gnu</code>类型会起作用。然而<code>__typeof__()</code>是支持<code>c和gnu</code>语法。</p><p>如果用Xcode作为IDE，默认为c语法设置的是<code>GNU99</code>，而且<code>&#39;asm&#39; &#39;inline&#39; &#39;typeof&#39;</code>选项是<code>YES</code>。所以使用<code>typeof()</code>不会有任何问题。</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-f073ff010fb7316e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如果想更为安全的使用<code>Clang</code>编译器，那么就使用<code>__typeof__()</code>。这样的话就不会当你有人关掉<code>typeof</code>选项的时候造成的影响。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术博客阅读笔记iOS篇(一、MRPEAK)</title>
      <link href="/2017/04/05/2017/4/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/04/05/2017/4/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>每天阅读那么多的博客，为什么自己对其中优秀的博客做一个笔记方便自己翻阅呢。而且牛逼的博主，其他文章含量金量也很高。虽然看博客不如看技术书籍来的全面、系统，读完之后也有不少的收获。关于泛读和精读，下面有篇文章有相应的介绍……</p><a id="more"></a><h2 id="博主MRPEAK"><a href="#博主MRPEAK" class="headerlink" title="博主MRPEAK"></a><a href="http://mrpeak.cn/" target="_blank" rel="noopener">博主MRPEAK</a></h2><p>一下内容大部分是摘自博客原文，如需细致阅读，建议看原文。<br><a href="http://mrpeak.cn/Archives/" target="_blank" rel="noopener">历史文章合集</a></p><h3 id="一、-如何设计一个通讯协议"><a href="#一、-如何设计一个通讯协议" class="headerlink" title="一、 如何设计一个通讯协议"></a><a href="http://mrpeak.cn/blog/tcp-rpc-protocol/" target="_blank" rel="noopener">一、 如何设计一个通讯协议</a></h3><p>幸好作者提供了项目源码，可以直接看源码<a href="https://github.com/music4kid/TKeyboard" target="_blank" rel="noopener">TKeyboard</a></p><p>google一搜如何设计一个通讯协议，出现了一大片文章。这里摘取比较有代表性的。<br>找到一个牛逼哄哄的网站<a href="http://www.52im.net/" target="_blank" rel="noopener">即时通信网</a>，做了IM这么久现在才知道有这样好资源。</p><p><a href="http://www.52im.net/thread-283-1-1.html" target="_blank" rel="noopener">理论联系实际：一套典型的IM通信协议设计详解</a><br><a href="http://gcloud.qq.com/forum/topic/56976ee6ceddce8561c9494d" target="_blank" rel="noopener">如何设计一个RPC系统</a></p><p>应用层常见的有三种：文本协议（Http）、二进制协议(ip)、流式XML协议（xmpp）。他们的各自优缺点可以大致总结出来。后文建议<a href="http://www.52im.net/thread-277-1-1.html" target="_blank" rel="noopener">强列建议将Protobuf作为你的即时通讯应用数据传输格式</a></p><p>工作内容主要有：一是数据的序列化，即将我们平时所用的 model 转化为二进制流，其二是定义好包的格式，在通讯框架里做好包的切割，解析，和传递。最后简化调用流程，提供一套简单的类似 http 的双向数据调用 API 即可。</p><ul><li>基本思路<ol><li>第一个序列化的问题好解决，<strong>已有 google 的成熟方案 protobuf 可以使用（感觉业界都推荐用这个，但是之前在iOS端用过，发现了很多坑爹的地方）</strong>，而且还有基于 Objective C 的版本，model 的序列化和反序列化，一个 API 调用即可完成。</li><li>第二个问题是包的格式定义。学习 TCP/IP 的意义在这里就能体现了，无论是 TCP 包还是 IP 包，都有自己的包格式定义，而且往往是一个 header 配合一个 payload（类似于 http 的 body）。之所以要有包，是因为二进制流只完成 stream 的传输，并不知道一次数据请求与相应的起始和结束，我们要预先定义好包结构才能做解析。</li><li>要能实现包的准确切割，我们需要明确包的长度。所以必须在 header 中留一个字段，表达整个包（header + payload）由多少 bytes 构成，两个字节的长度就可以描述 0~65535 个字节数，具体使用多少个字节就看协议的使用场景了。</li><li>因为是 RPC 调用协议，所以包体里必须有调用的名称，即 API name 字段，这个 name 是可变长度，所以也需要将其长度信息加入包体中，原则上，所有可变长度的内容都需记录其精确的长度信息，否则无法做信息的切割。另外，调用方还需要知道包是请求的回应（response）还是另一端的通知（notify），所以我们还需要定义 call type 信息，这种信息一个 8 比特位的枚举量就绰绰有余了，这种固定长度的信息就不需要记录其长度信息了。</li><li>一般固定长度的信息我们放在 header 中，可变长度的信息我们则放入 payload 中，当然，我们 RPC 调用的具体参数（经由 protobuf 序列化之后的 stream）也是放入 payload 中，接收方接收以后，只需读取固定长度的字节，即可通过反序列化，再在接收方还原成具体的应用层数据。</li></ol></li></ul><p>特别注意：<strong>因为我们是在设计应用层协议，所以还需要考虑传输层是可靠还是不可靠，CoreBlueTooth 实际上既提供了类似于 TCP 的可靠传输（CBCharacteristicPropertyIndicate），也有类似于 UDP 的不可靠传输（CBCharacteristicPropertyNotify），不明白这一点，必然会踩坑</strong></p><h3 id="二、TCP-IP-系列之重新认识-IP-地址"><a href="#二、TCP-IP-系列之重新认识-IP-地址" class="headerlink" title="二、TCP/IP 系列之重新认识 IP 地址"></a><a href="http://mrpeak.cn/blog/tcp-ip/" target="_blank" rel="noopener">二、TCP/IP 系列之重新认识 IP 地址</a></h3><p>大学里面网络基础学过，但是基本上都忘记了。看到这篇突然想起了一些<code>远古</code>的记忆。</p><blockquote><p>internet 其实是由无数个子网所构成，是一个二级的结构，第一级是子网，第二级才是子网中的设备。所以 internet 中设备 A 的信息要抵达设备 B，必须先要找到 B 所在的子网，进而再在子网中找到 B。</p></blockquote><p>IP 地址的结构：IP 地址 = 网络地址 + 主机地址。子网掩码（subnet mask） 就是为了分割 Network ID 和 Host ID 的</p><h4 id="第一种切割方式"><a href="#第一种切割方式" class="headerlink" title="第一种切割方式"></a>第一种切割方式</h4><ul><li><p>第一个字节为 Network ID，剩下三个字节为 Host ID</p></li><li><p>第二个字节为 Network ID，剩下两个字节为 Host ID</p></li><li><p>第三个字节为 Network ID，剩下一个字节为 Host ID<br>有问题</p></li><li><p>我们如何确定一个 IP 地址是属于 A B C 的哪一类呢？我们以第一个字节来做一些约定：</p><ol><li>如果第一个字节的起始比特位为 0，则是 A 类地址。</li><li>如果第一个字节的起始比特位为 10，则是 B 类地址。</li><li>如果第一个字节的起始比特位为 110，则是 C 类地址。</li></ol></li></ul><h4 id="第二种切割方式CIDR"><a href="#第二种切割方式CIDR" class="headerlink" title="第二种切割方式CIDR"></a>第二种切割方式CIDR</h4><p>全称为 Classless Inter-Domain Routin。CIDR 是新的子网掩码的表达方式和路由方式。这里注意 CIDR 和 CIDR notation 的区别，CIDR notation 是描述 IP 地址如何切割的方式，而 CIDR 描述的是基于 CIDR notation 的路由方式。</p><p>CIDR notation 其实概念也很直白，它不再粗暴的以字节为粒度来切分 IP 地址，而是精确到 bit 位，我们看一个典型的 CIDR notation：</p><pre><code>123.121.114.144/23</code></pre><p>注意 IP 地址后面的 /23，这就是 CIDR notation，<strong>它表示 IP 地址的前 23 bits 为 Network ID，剩余的 9 bits 为 Host ID。23 并不是 8 的倍数，我们将切分的精读提高到了 bit。</strong>我们可以通过简单的位运算，得到具体的 Network ID 和 Host ID，我们将 IP 地址和 /23 先转为二进制：</p><pre><code>01111011.01111001.01110010.10010000 IP 地址11111111.11111111.11111110.00000000 /23 subnet mask</code></pre><p>得到 Network ID 和 Host ID：</p><pre><code>01111011.01111001.01110010.00000000 Network ID00000000.00000000.00000000.10010000 Host ID</code></pre><blockquote><p>再将二进制转换为十进制，我们就得到了便于理解的 Network ID：123.121.114.0。由于 Host ID 占用 9 个 bits，这个子网里一共可以有 2 的 9 次方个主机数，也就是 512 个主机，这个子网网段的起始地址为 123.121.114.0，结束地址为 123.121.115.255。我们对于某一个网段内的 IP 地址，有个约定，第一个地址为 Network ID，最后一个地址是该子网内的 Broadcast ID，那么剩下的可用于子网内设备的 IP 地址数量就是 510 个了。</p></blockquote><p>IP 地址虽然只是一个二级的结构，但 IP 地址的分配却是一层一层，经历多层往下分发的，由一个国际机构 IANA 统一分配。具体规则可以参考 IANA 官网：<a href="https://www.iana.org/numbers" target="_blank" rel="noopener">https://www.iana.org/numbers</a></p><p>用户拿到 IP 地址后，所发送包要经过一个个的路由器才能抵达正确的地址。</p><h3 id="三、TCP-IP-系列之-Header-篇"><a href="#三、TCP-IP-系列之-Header-篇" class="headerlink" title="三、TCP/IP 系列之 Header 篇"></a><a href="http://mrpeak.cn/blog/tcp-headers/" target="_blank" rel="noopener">三、TCP/IP 系列之 Header 篇</a></h3><p><img src="http://www.mrpeak.cn/images/ws03.png" alt></p><p>如果以一个 HTTP 请求为例，右图中 Application 部分就代表我们用 Charles 抓包时所感知的部分，这一部分要最后转化为光信号，在光纤中传输，还需要经过一层层的转化，这个转化过程说白了，就是在每一层加上一个 header。</p><ul><li>Application 层（HTTP）的数据在经过传输层（TCP Layer）的时候，会加上 TCP 的 header，成为一个 TCP Segment。</li><li>传输层（TCP）的 Segment 在经过网络层（IP Layer）的时候，会加上 IP 的 header，成为一个 IP Packet。</li><li>网络层的 IP Packet 在经过链路层（Link Layer）的时候，会加上Link Layer 的 header，成为一个 Frame。</li><li>最后 Frame 会在物理层，将数字信号转化为物理信号传输。</li></ul><p>看张图片一切就明了了<br><img src="http://www.mrpeak.cn/images/ws05.png" alt></p><p>深入研究可以看<a href="http://www.cnblogs.com/zhuimengle/p/5737848.html" target="_blank" rel="noopener">TCPdump抓包命令详解</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="noopener">Linux tcpdump命令详解</a></p><h3 id="四、TCP-IP-系列之初印象"><a href="#四、TCP-IP-系列之初印象" class="headerlink" title="四、TCP/IP 系列之初印象"></a><a href="http://mrpeak.cn/blog/tcp-preface/" target="_blank" rel="noopener">四、TCP/IP 系列之初印象</a></h3><p>0 和 1 是计算机世界的基础粒子，大量的 0 和 1 组合在一起就形成了一个流（Stream），客户端向服务器发送数据的时候，说白了就是一堆 0 和 1 的组合。一次完整的 http 会话是建立在一个 TCP 连接之上，这个 TCP 连接的生命周期内所有发送的数据最后可以看做是一个流。<strong>而在这个流里，我们可以按照某种规则把它切割成一个个的包（packet）。</strong>比如 TCP 三次握手里就包含了 SYN，SYN+ACK，ACK 三个包，而这三个包，不过是整个 TCP Stream 最开始的部分数据而已。</p><p>所以简单来说，一个 TCP 连接里，是既有流的概念，又有包的存在，有些问题场景下会谈论流，另一些则会说起包，端看具体的场景如何。</p><p>客户端和服务器之间有两根管道，一根上行（从客户端到服务器），一根下行（从服务器到客户端），管道里流动着无数的 0 和 1，有时候管道里是满的，有时候管道里则空空如也，每次发送数据，都会有大量的 0 和 1 从一端涌向另一端。</p><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>由两部分组成的，其一是 Transmission Delay，另一个是 Propagation Delay。</p><p>Transmission Delay。计算机世界里的 0 和 1， 最后要能在光纤中传输，需要在 Physical Layer 将数字信号转化为物理信号，这个转化也是存在速度瓶颈的，我们用 Rate (bits/seconds) 来描述这个转化的速度，Rate 表示每一秒钟里，硬件设备能将多少 bits 转化为光信号放入光纤中。</p><p> Propagation Delay。这才是大部分人所理解的传播延迟，和距离直接相关。</p><h3 id="五、技术文章的阅读姿势🍎"><a href="#五、技术文章的阅读姿势🍎" class="headerlink" title="五、技术文章的阅读姿势🍎"></a><a href="http://mrpeak.cn/blog/ios-tech-article/" target="_blank" rel="noopener">五、技术文章的阅读姿势</a>🍎</h3><p>作者和自己的感想比较相似，关于泛读和精读给出了自己的解释。对于自己而言，确实是这样，总结出来的经验也非常值得自己借鉴。</p><p>由于技术的知识体系往往是个树形的结构，单个术语下都有其相关的知识域，可以一层又一层牵扯出更多的子术语。在阅读文章遭遇这种树形结构的时候，要能抑制住自己不停探索的欲望，<strong>对于技术术语的学习只做适度延伸，最终的目的还是在于完成根部文章的阅读。</strong>尽量只做一到两层的延伸。</p><p>尽量选择没人打扰的时间段来做阅读，可以是早上刚到公司，或者别人午睡时，总之越安静，越没人找越好。</p><blockquote><p><strong>对于基础知识的阅读，要重官方文档，切莫心急动手，看完文档形成知识体系后再写代码不迟。</strong>减少泛读行为，避免漫无目的的随意浏览技术文章。注重精读，一天一篇不算少，一周一篇也正常。<strong>重阅读质量而非数量，挑选每天安静且不易被打断的时间点来阅读，尽量多啃原版书。</strong></p></blockquote><h2 id="今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新"><a href="#今天的阅读就到这里了-2017-4-5-pm5-22-下次继续更新" class="headerlink" title="今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新"></a>今天的阅读就到这里了 2017-4-5  pm5:22  下次继续更新</h2><blockquote><p>时隔一个多月</p></blockquote><h3 id="六、闲聊-Hash-算法"><a href="#六、闲聊-Hash-算法" class="headerlink" title="六、闲聊 Hash 算法"></a><a href="http://mrpeak.cn/blog/hash/" target="_blank" rel="noopener">六、闲聊 Hash 算法</a></h3><blockquote><p>数据结构和算法是相辅相成的，基础的其实就那么些：时间复杂度的概念，List，Array，Stack，Queue，Tree 等。Graph 实际应用中较少遇到，可以不做深入了解，但 BFS，DFS，Dijkstra 还是应该知道。基础的算法需要能达到手写的程度，比如排序至少能写出两种时间复杂度为 N*logN 的算法。理解这些比去 leetcode 刷题重要，学习难度也并不高。学习这些的意义在于掌握解决问题的基础思路，形成计算机思维，比如 divide and conque，recursive 等常规思想。</p></blockquote><h3 id="七、Improving-Immutable-Object-Initialization-in-Objective-C"><a href="#七、Improving-Immutable-Object-Initialization-in-Objective-C" class="headerlink" title="七、Improving Immutable Object Initialization in Objective-C"></a><a href="http://holko.pl/2015/05/12/immutable-object-initialization/" target="_blank" rel="noopener">七、Improving Immutable Object Initialization in Objective-C</a></h3><ol><li>Initializer mapping arguments to properties</li><li>Initializer taking dictionary</li><li>Mutable subclass</li><li>Improving builder pattern</li></ol><h3 id="八、危险的UITableView"><a href="#八、危险的UITableView" class="headerlink" title="八、危险的UITableView"></a><a href="http://mrpeak.cn/blog/tableview-danger/" target="_blank" rel="noopener">八、危险的UITableView</a></h3><p>总体来说就是调用了tableView的reloadData方法之后，代理方法有些不是同步执行的。具体来讲。</p><pre><code>当我们reloadData的时候，我们本意是刷新UITableView，随后会进入一系列UITableViewDataSource和UITableViewDelegate的回调，其中有些是和reloadData同步发生的，有些则是异步发生的。我们熟悉的下面两个回调是同步的：- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{    return 20;}- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{    return _arr.count;}而另一个最常使用的回调则是异步的：- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{   //...   NSNumber* content = _arr[indexPath.row];   //...}经过上面的分析，我们不难UITableView的危险之处在于哪了，在于异步执行cellForRowAtIndexPath的时候，我们所依赖的状态可能会发生变化，上面代码中的_arr如果元素被修改过，极有可能发生数组越界的异常。</code></pre><p>优化方案</p><p>throttle机制，控制刷新事件的产生频率，建立一个Queue以一定的时间间隔来调用reloadData。事实上这是一种很常见的界面优化机制，对于一些刷新频率可能很高的列表界面，比如微信的会话列表界面，如果很长时间没有登录了，打开App时，堆积了很久的离线消息会在短时间内，导致大量的界面刷新请求，频繁的调用reloadData还会造成界面的卡顿，所以此时建立一个FIFO的Queue，以一定的间隔来刷新界面就很有必要了。</p><h3 id="九、iOS当中的Cache设计"><a href="#九、iOS当中的Cache设计" class="headerlink" title="九、iOS当中的Cache设计 "></a><a href="http://mrpeak.cn/blog/ios-cache/" target="_blank" rel="noopener">九、iOS当中的Cache设计 </a></h3><p>需要看看<a href="https://my.oschina.net/huangyong/blog/177559" target="_blank" rel="noopener"> 一个简单的 Cache 淘汰策略</a><br>副作用的理解：</p><blockquote><p>所有对我们整个App有副作用的代码都需要被集中管理，要能从架构的层面去理解和定位。怎么去定义副作用呢？<strong>可以抽象成一种「写操作」，往Cache中添加新的记录就是写操作，这种写操作的副作用是额外的内存开销</strong>，Cache的本质是以空间换时间，这空间损耗就是我们的副作用，一个副作用会引发其他更多的副作用，理清这些副作用往往需要反复查阅大量的代码。更好的办法是，一开始就把有副作用的代码集中管理。</p></blockquote><ul><li><p>cache的另一个重要知识点是cache的淘汰策略，不同的策略表现也不一样，FIFO，LRU，2Queues等等，现在有不少成熟的第三方cache框架可以使用，系统也提供了淘汰策略不明确的NSCache。</p></li><li><p><strong>cache的使用要有收有放，不能只创建不释放，事实上，所有涉及到data的操作都要考虑data的生命周期。我们做业务的时候，多是以Controller为基础单位，有些场景下，一个Controller在退出之后被再次进入的可能性就非常之低了，适时的清理cache会让我们App的整体表现更好。</strong></p></li><li><p>只要保证业务模块从Cache中获取的数据都是独立的copy，就能避免数据共享带来的各种隐患。</p></li></ul><p>最后看一下<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>加深学习</p><h3 id="十、如何用Xcode8解决多线程问题"><a href="#十、如何用Xcode8解决多线程问题" class="headerlink" title="十、如何用Xcode8解决多线程问题"></a><a href="http://mrpeak.cn/blog/thread-sanitizer/" target="_blank" rel="noopener">十、如何用Xcode8解决多线程问题</a></h3><p>data race：当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了data race。</p><p>常见场景</p><ul><li><p>场景一：计算出错</p><pre><code>__block int count = 0;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{  for (int i = 0; i &lt; 10000; i ++) {      count ++;  }});for (int i = 0; i &lt; 10000; i ++) {  count ++;}</code></pre></li><li><p>场景二：Crash！</p><pre><code>NSMutableString* str = [@&quot;&quot; mutableCopy];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{  for (int i = 0; i &lt; 10000; i ++) {      [str setString:@&quot;1234567890&quot;];  }});for (int i = 0; i &lt; 10000; i ++) {  [str setString:@&quot;abcdefghigk&quot;];}</code></pre><p>一般会出现在对于复杂对象（class或者struct）的多线程写操作中，原因是因为写操作本身不是原子的，而且写操作背后会调用更多的内存操作，多线程同时写时，会导致这块内存区间处于中间的不稳定状态，进而crash，这是真正的恶性的data race。</p></li><li><p>场景三：乱序</p><pre><code>//thread 1count = 10;countFinished = true;//thread 2while (countFinished == false) {  usleep(1000);}NSLog(@&quot;count: %d&quot;, count);</code></pre></li></ul><p>公共变量线程同步。error</p><p>编译器并不知道thread 2对count和countFinished这两个变量的赋值顺序有依赖，所以基于优化的目的，有可能会调整thread 1中count = 10;和countFinished = true;生成的最后指令的执行顺序，最后也就导致count值输出的时机不对，虽然最后count的值还是10。这也可以看做是一种benign race，因为也不会crash，而是程序的流程出错。</p><blockquote><p>遇到这种多线程读写状态，而且存在顺序依赖的场景，不能简单依赖代码逻辑。<strong>解决这种data race场景有一个简单办法：加锁</strong>，比如使用NSLock，<strong>将对顺序有依赖的代码块整个原子化</strong>，加锁之所以有用是因为会生成memory barrier，从而避免了编译器优化。</p></blockquote><ul><li><p>场景四：内存泄漏（存在静态变量的时候）</p><pre><code>Singleton *getSingleton() {  static Singleton *sharedInstance = nil;  if (sharedInstance == nil) {      sharedInstance = [[Singleton alloc] init];  }  return sharedInstance;}</code></pre></li></ul><p>多线程环境下，thread A和thread B会同时进入sharedInstance = [[Singleton alloc] init];，Singleton被多创建了一次，MRC环境就产生了内存泄漏。</p><blockquote><p>顶层的还是不够牢固。哎！恶补</p></blockquote><h3 id="十一、iOS多线程到底不安全在哪里？"><a href="#十一、iOS多线程到底不安全在哪里？" class="headerlink" title="十一、iOS多线程到底不安全在哪里？"></a><a href="http://www.mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">十一、iOS多线程到底不安全在哪里？</a></h3><ul><li><code>self.userName = @&quot;123&quot;;</code> 是在对指针本身进行赋值</li><li><code>[self.userName rangeOfString:@&quot;123&quot;];</code>是在访问指针指向的字符串所在的内存区域，这二者并不一样</li></ul><p>属性类型。基本类型、指针类型<br><img src="http://www.mrpeak.cn/images/safe00.png" alt></p><p>至始至终只有三种：<strong>1.值类型Property、2.指针Property、3.指针Property指向的内存区域（这一类多线程的访问场景是我们很容易出错的地方）</strong></p><blockquote><p>atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。</p></blockquote><p>多线程安全的时候，其实是在讨论多个线程同时访问一个内存区域的安全问题。针对同一块区域，我们有两种操作，读（load）和写（store），读和写同时发生在同一块区域的时候，就有可能出现多线程不安全。</p><p>多线程是如何同时访问内存的。不考虑CPU cache对变量的缓存，内存访问可以用下图表示：<br><img src="http://www.mrpeak.cn/images/safe02.png" alt><br>只有一个地址总线，一个内存。<strong>即使是在多线程的环境下，也不可能存在两个线程同时访问同一块内存区域的场景，内存的访问一定是通过一个地址总线串行排队访问的</strong></p><ul><li><p>结论一：内存的访问时串行的，并不会导致内存数据的错乱或者应用的crash。</p></li><li><p>结论二：如果读写（load or store）的内存长度小于等于地址总线的长度，那么读写的操作是原子的，一次完成。比如bool，int，long在64位系统下的单次读写都是原子操作。</p></li></ul><p>atomic作用：</p><ul><li>用处一： 生成原子操作的getter和setter。设置atomic之后，默认生成的getter和setter方法执行是原子的。<strong>也就是说，当我们在线程1执行getter方法的时候（创建调用栈，返回地址，出栈），线程B如果想执行setter方法，必须先等getter方法完成才能执行。</strong>举个例子，在32位系统里，如果通过getter返回64位的double，地址总线宽度为32位，从内存当中读取double的时候无法通过原子操作完成，如果不通过atomic加锁，有可能会在读取的中途在其他线程发生setter操作，从而出现异常值。如果出现这种异常值，就发生了多线程不安全。</li><li>用处二：设置Memory Barrier。对于Objective C的实现来说，几乎所有的加锁操作最后都会设置memory barrier，atomic本质上是对getter，setter加了锁，所以也会设置memory barrier。<strong>memory barrier能够保证内存操作的顺序，按照我们代码的书写顺序来。听起来有点不可思议，事实是编译器会对我们的代码做优化，在它认为合理的场景改变我们代码最终翻译成的机器指令顺序。</strong></li></ul><p>问题代码:值类型Property</p><pre><code>@property (atomic, assign)    int       intA;//thread Afor (int i = 0; i &lt; 10000; i ++) {    self.intA = self.intA + 1;    NSLog(@&quot;Thread A: %d\n&quot;, self.intA);}//thread Bfor (int i = 0; i &lt; 10000; i ++) {    self.intA = self.intA + 1;    NSLog(@&quot;Thread B: %d\n&quot;, self.intA);}</code></pre><p>即使我将intA声明为atomic，最后的结果也不一定会是20000。<strong>原因就是因为self.intA = self.intA + 1;不是原子操作，虽然intA的getter和setter是原子操作，但当我们使用intA的时候，整个语句并不是原子的，这行赋值的代码至少包含读取(load)，+1(add)，赋值(store)三步操作</strong>，当前线程store的时候可能其他线程已经执行了若干次store了，导致最后的值小于预期值。</p><p>问题代码：指针Property</p><pre><code>@property (atomic, strong) NSString*                 userName;- (void)setUserName:(NSString *)userName {    if(_uesrName != userName) {        [userName retain];        [_userName release];        _userName = userName;    }}</code></pre><p>如果property为nonatomic，上述的setter方法就不是原子操作，我们可以假设一种场景，线程1先通过getter获取当前_userName，之后线程2通过setter调用[_userName release];，线程1所持有的_userName就变成无效的地址空间了，如果再给这个地址空间发消息就会导致crash，出现多线程不安全的场景。</p><p>问题代码：指针Property指向的内存区域</p><pre><code>@property (atomic, strong) NSString*                 stringA;//thread Afor (int i = 0; i &lt; 100000; i ++) {    if (i % 2 == 0) {        self.stringA = @&quot;a very long string&quot;;    }    else {        self.stringA = @&quot;string&quot;;    }    NSLog(@&quot;Thread A: %@\n&quot;, self.stringA);}//thread Bfor (int i = 0; i &lt; 100000; i ++) {    if (self.stringA.length &gt;= 10) {        NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];    }    NSLog(@&quot;Thread B: %@\n&quot;, self.stringA);}</code></pre><p>虽然stringA是atomic的property，而且在取substring的时候做了length判断，线程B还是很容易crash，因为在前一刻读length的时候self.stringA = @”a very long string”;，下一刻取substring的时候线程A已经将self.stringA = @”string”;，立即出现out of bounds的Exception，crash，多线程不安全。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReadNotes </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习</title>
      <link href="/2017/04/05/2017/4/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
      <url>/2017/04/05/2017/4/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>网络这块，平时用得比较多，但接触到原理的机会很少，今天在看一篇文章的时候，提到了网络自定义协议地址<a href="http://mrpeak.cn/blog/tcp-rpc-protocol/" target="_blank" rel="noopener">如何设计一个通讯协议</a>，顺便就把网络这块一起复习一下。虽然之前也复习过，知识嘛！温故而知新。</p><a id="more"></a><h2 id="解释图"><a href="#解释图" class="headerlink" title="解释图"></a>解释图</h2><ul><li><p>七层模型（讲得比较详细的一张图）<br><img src="http://img.blog.csdn.net/20140924202143732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFpZ29vY24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p></li><li><p>上图的补充说明<br><img src="http://up.2cto.com/2013/0731/20130731095736383.png" alt></p></li></ul><h3 id="七层形象比喻"><a href="#七层形象比喻" class="headerlink" title="七层形象比喻"></a>七层形象比喻</h3><p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt></p><p><strong>整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</strong></p><ul><li>1、应用层</li></ul><p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p><blockquote><p><strong>实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</strong></p></blockquote><ul><li>2、表示层</li></ul><p>表示层提供各种用于应用层数据的编码和转换功能,<strong>确保一个系统的应用层发送的数据能被另一个系统的应用层识别</strong>。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><blockquote><p><strong>由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</strong></p></blockquote><ul><li>3、会话层</li></ul><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。      </p><blockquote><p><strong>会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</strong></p></blockquote><ul><li>4、传输层</li></ul><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p><blockquote><p><strong>传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</strong></p></blockquote><ul><li>5、网络层</li></ul><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p><blockquote><p><strong>网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</strong></p></blockquote><ul><li>6、数据链路层 </li></ul><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p><p>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p><blockquote><p>MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p></blockquote><ul><li>7、物理层     </li></ul><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><blockquote><p><strong>快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</strong></p></blockquote><h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h3><ul><li>七层与五层的关系</li></ul><p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" alt></p><ul><li>对应协议及硬件<br><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png" alt><br><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234826351-1957282396.png" alt></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="http://upload-images.jianshu.io/upload_images/3346554-0f81660c9f0659c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h3><pre><code>200 OK 客户端请求成功301 Moved Permanently 请求永久重定向302 Moved Temporarily 请求临时重定向304 Not Modified 文件未修改，可以直接使用缓存的文件。400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因404 Not Found 请求的资源不存在，例如，输入了错误的URL500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</code></pre><p>在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。<br><img src="http://images.cnitblog.com/i/116165/201407/111703047392802.png" alt></p><p><strong>HTTP默认的端口号为80，HTTPS的端口号为443。</strong></p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><ul><li><p>无状态：HTTP协议是无状态协议。<strong>无状态是指协议对于事务处理没有记忆能力。</strong>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</p></li><li><p>HTTP协议是无状态的和Connection: keep-alive的区别：</p><ul><li>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，<strong>无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</strong></li><li>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</li><li>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</li></ul></li></ul><h4 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a>请求信息</h4><p>三个部分分别是：<strong>请求行、消息报头（请求头）、请求正文。</strong></p><ul><li>请求行，例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件。</li><li>请求头，例如Accept-Language: en</li><li>空行</li><li>可选的消息体　请求行和标题必须以<cr><lf>作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1协议中，所有的请求头，除post外，都是可选的。</lf></cr></lf></cr></li></ul><p><img src="http://images.cnitblog.com/i/116165/201407/121712545823346.png" alt></p><ul><li>GET和POST的区别：<ul><li>1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li><li>2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li><li>4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul></li></ul><h4 id="响应消息"><a href="#响应消息" class="headerlink" title="响应消息"></a>响应消息</h4><p>三个部分分别是：<strong>状态行、消息报头、响应正文。</strong><br><img src="http://images.cnitblog.com/i/116165/201407/121720098646366.png" alt></p><p><img src="http://images.cnitblog.com/i/116165/201407/111156110203396.png" alt></p><p><img src="http://images.cnitblog.com/i/116165/201407/121724042548791.png" alt></p><h4 id="解决HTTP无状态的问题"><a href="#解决HTTP无状态的问题" class="headerlink" title="解决HTTP无状态的问题"></a>解决HTTP无状态的问题</h4><ul><li><p>通过Cookies保存状态信息</p><p><img src="http://images.cnitblog.com/i/116165/201407/122123269892896.png" alt></p></li><li><p>通过Session保存状态信息</p></li><li><p>URL重写（通过QueryString保持状态）：URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。</p></li><li><p>隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示</p></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>三次握手与四次握手</p><p><img src="http://swiftlet.net/wp-content/themes/swiftlet/page-images/tcp/tcp.jpg" alt></p><p>断开连接端可以是Client端，也可以是Server端。</p><ul><li>1.假设Client端发起中断连接请求，就先发送FIN报文。<ul><li>1.2.Server端接到FIN报文后，但是如果还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以服务器端先发送ACK，告诉Client端：请求已经收到了，但是我还没准备好，请继续等待停止的消息。</li></ul></li><li>2.这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。</li><li>3.当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端：服务器这边数据发完了，准备好关闭连接了。</li><li>4.Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送ACK后进入TIME_WAIT状态， Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，最后，Client端也可以关闭连接了至此，TCP连接就已经完全关闭了！关闭连接的过程如下图所示：</li></ul><p><img src="http://swiftlet.net/wp-content/themes/swiftlet/page-images/tcp/duankai.jpg" alt></p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><ul><li><p>如何防御 SYN 攻击？</p><pre><code>缩短超时（SYN Timeout）时间增加最大半连接数过滤网关防护SYN cookies技术</code></pre></li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP地址分类</p><table><thead><tr><th align="center">IP class</th><th align="center">From</th><th align="center">To</th><th align="center">Subnet Mask</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">1.0.0.0</td><td align="center">126.255.255.255</td><td align="center">255.0.0.0</td></tr><tr><td align="center">B</td><td align="center">128.0.0.0</td><td align="center">191.255.255.255</td><td align="center">255.255.0.0</td></tr><tr><td align="center">C</td><td align="center">192.0.0.0</td><td align="center">223.255.255.255</td><td align="center">255.255.255.0</td></tr></tbody></table><blockquote><p>每个IP地址的32位分为前后两部分，<strong>第一部分用来区分局域网，第二个部分用来区分该局域网的主机。</strong>子网掩码(Subnet Mask)告诉我们这两部分的分界线，比如255.0.0.0(也就是8个1和24个0)表示前8位用于区分局域网，后24位用于区分主机。由于A、B、C分类是已经规定好的，所以当一个IP地址属于B类范围时，我们就知道它的前16位和后16位分别表示局域网和主机。</p></blockquote><p>IP地址实际上识别的是网卡(NIC, Network Interface Card)。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机(处理器/内存)。当计算机需要发送信息的时候，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个WiFi网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。</p><h2 id="Soket"><a href="#Soket" class="headerlink" title="Soket"></a>Soket</h2><blockquote><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p></blockquote><pre><code>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</code></pre><p>之前写过一篇关于Soket相关的文章。这里就不在重复了。<a href="http://www.jianshu.com/p/c7a5fd48dcd6" target="_blank" rel="noopener">Soket复习</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p>七层模型</p><ul><li><p><a href="http://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="noopener">OSI七层模型与TCP/IP五层模型</a></p></li><li><p><a href="http://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解</a></p></li></ul></li><li><p>HTTP</p><ul><li><p><a href="http://www.cnblogs.com/EricaMIN1987_IT/p/3837436.html" target="_blank" rel="noopener">HTTP协议详解</a></p></li><li><p><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">HTTP的特性</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></p></li><li><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386832653051fd44e44e4f9e4ed08f3e5a5ab550358d000" target="_blank" rel="noopener">HTTP协议简介</a></p></li></ul></li><li><p>IP</p><ul><li><a href="http://www.cnblogs.com/vamei/archive/2012/11/30/2794917.html" target="_blank" rel="noopener">IP接力赛 (IP, ARP, RIP和BGP协议)</a></li><li><a href="http://www.cnblogs.com/vamei/archive/2012/12/02/2796988.html" target="_blank" rel="noopener">IP协议详解</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andriod SDK Version及API Level</title>
      <link href="/2017/04/01/2017/3/AndroidSDKVersion%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%99%8D%E4%BD%8EAPILevel/"/>
      <url>/2017/04/01/2017/3/AndroidSDKVersion%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%99%8D%E4%BD%8EAPILevel/</url>
      
        <content type="html"><![CDATA[<p>　抽空打开了Android Studio准备研究一下开源项目代码，没想到运行不了。总的来说还是自己对Android开发不是太熟，这里简单总结一下遇到的一些坑！</p><a id="more"></a><h2 id="SDK-Version简单介绍"><a href="#SDK-Version简单介绍" class="headerlink" title="SDK Version简单介绍"></a>SDK Version简单介绍</h2><p>一切源于向前兼容，用户在升级到新版 Android 的时候，用以前版本的 SDK 构建的应用不会出问题。这就是 compileSdkVersion, minSdkVersion 和 targetSdkVersion 的作用：他们分别控制可以使用哪些 API ，要求的 API 级别是什么，以及应用的兼容模式。</p><h3 id="Compile-Sdk-Version"><a href="#Compile-Sdk-Version" class="headerlink" title="Compile Sdk Version"></a>Compile Sdk Version</h3><p>compileSdkVersion 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。</p><p>修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。</p><p>在开发中最常见的就是总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。Android Stuido默认是用最新的，所以一般不怎么改compileSdkVersion。</p><h3 id="Min-Sdk-Version"><a href="#Min-Sdk-Version" class="headerlink" title="Min Sdk Version"></a>Min Sdk Version</h3><p>如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。minSdkVersion 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。</p><p>在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，<strong>它在你使用了高于 minSdkVersion  的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。</strong>如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。</p><p><strong>注意：当使用第三方库可能有他们自己的 minSdkVersion 。你的应用设置的 minSdkVersion 必需大于等于这些库的 minSdkVersion 。</strong></p><h3 id="Target-Sdk-Version"><a href="#Target-Sdk-Version" class="headerlink" title="Target Sdk Version"></a>Target Sdk Version</h3><p>targetSdkVersion 是 Android 提供向前兼容的主要依据，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的API变化。这允许你在适应新的API变化之前就可以使用新的 API。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>三者需要满足<code>minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</code>。但是最为理想的状态应该是<code>minSdkVersion (lowest possible) &lt;=  targetSdkVersion == compileSdkVersion (latest SDK)</code>用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。</p><h2 id="API-Level-与-Version"><a href="#API-Level-与-Version" class="headerlink" title="API Level  与 Version"></a>API Level  与 Version</h2><p>有了上面的基础知识，于是为了学习更为牛逼的代码，于是去GitHub上下载了几个项目的源码。一切都没问题，在连上真机的时候突然报错。提示：<img src="http://upload-images.jianshu.io/upload_images/664334-3cdba0423c0ef161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>。</p><p>于是瞎捣鼓了一下才明白，原来每一个Android版本对应一个API  level。报错的原因就是真机的系统版本低于项目设定的版本。</p><p>在官网上找到了一张图标，能够彻底说明这个问题。<a href="http://source.android.com/source/build-numbers.html" target="_blank" rel="noopener">Codenames, Tags, and Build Numbers</a></p><p><img src="http://upload-images.jianshu.io/upload_images/664334-c290eec12f54f4af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="降低API-Level"><a href="#降低API-Level" class="headerlink" title="降低API Level"></a>降低API Level</h3><p>为了让项目在真机上运行起来，不得不降低项目的API level。<strong>虽然我这里报错是minSDK,但我这里演示的是所有更改所有sdk，比如comiple,target,misdk的情况。具体更改根据报错信息修改对应的选项即可。</strong></p><p>这里有两种方式解决。</p><ol><li>图形化操作<ul><li>1.1 修改 compile Sdk Version<br>  <img src="http://upload-images.jianshu.io/upload_images/664334-7cb1d57138e8cf19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>1.2 修改Target Sdk Version<br>  <img src="http://upload-images.jianshu.io/upload_images/664334-f3332ccd2e6ba093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>1.3修改完之后，IDE会自动修改build.grade的内容。<br>  <img src="http://upload-images.jianshu.io/upload_images/664334-bcb9adf7bab225fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ol><ol start="2"><li>修改build.gradle：上面提到的这些sdk内容，全部在build.gradle文件里找到。我们可以直接修改相应的内容即可。比如：<br> <img src="http://upload-images.jianshu.io/upload_images/664334-3cd0cfd5755f9a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由较高的API Level转至较低的API Level，有时候会出现兼容上的问题。比如较低版本的API Level不支持某些特性。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://medium.com/google-developers/picking-your-compilesdkversion-minsdkversion-targetsdkversion-a098a0341ebd" target="_blank" rel="noopener">Picking your compileSdkVersion, minSdkVersion, and targetSdkVersion</a></p><p><a href="http://chinagdg.org/2016/01/picking-your-compilesdkversion-minsdkversion-targetsdkversion/" target="_blank" rel="noopener">如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog重头开始</title>
      <link href="/2017/03/31/2017/3/Blog%E9%87%8D%E5%A4%B4%E5%BC%80%E5%A7%8B/"/>
      <url>/2017/03/31/2017/3/Blog%E9%87%8D%E5%A4%B4%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>自从上次博客从hexo+github迁移到简书后，再也没有捣鼓相关的内容了。今天无意中看到了hexo的主题<a href="https://material.viosey.com/" target="_blank" rel="noopener">Material Theme</a>，再次燃起兴趣……</p><a id="more"></a><h2 id="重头开始"><a href="#重头开始" class="headerlink" title="重头开始"></a>重头开始</h2><p>这里完全重头搭建一个gitpage+Hexo的静态博客。所以看完这篇文章之后，你完全可以自己弄一个玩一玩。虽然这些内容完全可以通过官网全部找到，这里也就相当于一个总结吧！</p><h2 id="一切源头"><a href="#一切源头" class="headerlink" title="一切源头"></a>一切源头</h2><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></p><ul><li>Node.js<ul><li><a href="https://github.com/nodejs/node" target="_blank" rel="noopener">Node.js GitHub地址</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 文档</a></li></ul></li><li>Hexo<ul><li><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo GitHub 地址</a></li><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo 文档</a></li><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo 中文文档</a></li></ul></li><li>Git<ul><li><a href="https://github.com/git/git" target="_blank" rel="noopener">Git GitHub 地址</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git 使用教程- 这里推荐中版</a></li></ul></li><li>Hexo Theme<ul><li><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">hexo-theme-material GitHub 地址</a></li><li><a href="https://material.viosey.com/" target="_blank" rel="noopener">material 主题文档</a></li></ul></li></ul><p>一下操作步骤，其实在上面的文档中能够全部找到。目前网上流传所谓的教程其实最开始也是从这些官方文档获得的。<strong>所以如果时间充裕，最好从官方文档入手！</strong></p><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><p>直接打开官方地址<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node</a>，下载安装包即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/664334-450f0bf96d56c348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="解决国内NPM慢"><a href="#解决国内NPM慢" class="headerlink" title="解决国内NPM慢"></a>解决国内NPM慢</h3><p><a href="http://blog.csdn.net/rongbo_j/article/details/52106580" target="_blank" rel="noopener">解决国内NPM安装依赖速度慢问题</a></p><p>只生效一次：<code>npm install -gd express --registry=http://registry.npm.taobao.org</code><br>永久生效：<code>npm config set registry http://registry.npm.taobao.org</code></p><h4 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h4><p>由于npm插件在国外所有很慢，换成cnpm会快很多。详情可以看<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a></p><p>小白请看<a href="http://blog.csdn.net/zhangwenwu2/article/details/52778521" target="_blank" rel="noopener">npm用法以及更换到淘宝镜像的方法</a></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>同样打开官方地址<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a></p><p><img src="http://upload-images.jianshu.io/upload_images/664334-7906f95f92b239fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在终端执行其中的命令即可。</p><h2 id="登录GitHub创建项目"><a href="#登录GitHub创建项目" class="headerlink" title="登录GitHub创建项目"></a>登录GitHub创建项目</h2><p><img src="http://upload-images.jianshu.io/upload_images/664334-f50d3d356a202614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>填写项目名，<strong>这里一定要注意项目名称需要用用户名+github.io结尾</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/664334-41acbd8d7acb0b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>创建完成之后拖到下面会有关于gitpage的介绍。选择个主题再返回就启用了。<br><img src="http://upload-images.jianshu.io/upload_images/664334-6ff6d02ebe0a17ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>接下来的事情就是将Hexo生成的静态页面push到这个仓库中就可以了。然后访问提示的这个链接就可以看到内容。</p><h2 id="自动发布到GitHub"><a href="#自动发布到GitHub" class="headerlink" title="自动发布到GitHub"></a>自动发布到GitHub</h2><p>虽然经过上面的不走，勉勉强强能写点东西并且能够发布了。但是还有很多事情需要做，比如：</p><ol><li>主题的选择，一般情况下hexo的默认主题不会让你满意。</li><li>自动部署，每次写了新的文章都用git命令操作一遍，很费时间。</li><li>添加一些本地或者google搜索。</li><li>支持评论等</li><li>……</li></ol><p>上面的3、4、5在选用三方主题的时候基本上简单配置一下就可以的。所以不难。</p><p><strong>自动部署在官方文档中也用说明。<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">自动部署中文版</a></strong></p><ul><li>安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener"> hexo-deployer-git</a>：<ul><li>在当前hexo生成的目录下执行：<code>npm install hexo-deployer-git --save</code></li></ul></li><li>配置deploy内容：比如我这样设置的</li></ul><pre class="line-numbers language-yml"><code class="language-yml">deploy:  type: git  repo: git@github.com:****/***.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 这里repo后面的内容可以直接复制你仓库中的地址：<br><img src="http://upload-images.jianshu.io/upload_images/664334-3bc95bffac2f1955.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="给github账号添加ssh"><a href="#给github账号添加ssh" class="headerlink" title="给github账号添加ssh"></a>给github账号添加ssh</h3><p>经过上面的过程依然还不能push到仓库，还没设置ssh。如果你执行了<code>hexo  d</code>会报403的错误。</p><p>设置Github的用户名和邮箱</p><pre class="line-numbers language-git"><code class="language-git">git config --global user.name <span class="token string">"你在Github上的昵称"</span>git config --global user.email <span class="token string">"你在Github上的邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里是全局设置的用户账号，考虑到某些仓库不能用这个账号，可以具体的仓库中使用如下：</p><pre><code>git config user.name &quot;用户名&quot; git config user.email &quot;邮箱&quot;</code></pre><p>设置</p><h3 id="公钥私钥"><a href="#公钥私钥" class="headerlink" title="公钥私钥"></a>公钥私钥</h3><p>接下来就是生产公钥私钥：</p><pre><code>ssh-keygen -t rsa -C &quot;你在Github上的邮箱&quot;// 多账号情况下：（多个git使用）ssh-keygen -t rsa -f ~/.ssh/名称 -C &quot;邮箱&quot;</code></pre><ul><li>-t 指定密钥类型，默认是 rsa ，可以省略。</li><li>-f 指定密钥文件存储文件名。</li></ul><p>添加密钥</p><pre><code>ssh-add id_rsa</code></pre><p>执行后，会填写保存两种密钥的文件夹，和passphrase。这里是指的密码尽量简单点，因为后面会在添加私钥的时候用到。<strong>全部可以按enter。然后执行ls来查看生成后的文件。</strong></p><ul><li>id_rsa和id_rsa.pub分别是私有密钥和公有密钥。</li><li>我们指定的文件名就是id_rsa.github，这时~/.ssh目录下会多出id_rsa.github和id_rsa.github.pub两个文件，id_rsa.github里保存的就是我们要使用的key。</li></ul><h3 id="有多个git账号怎么办（常见问题）"><a href="#有多个git账号怎么办（常见问题）" class="headerlink" title="有多个git账号怎么办（常见问题）"></a>有多个git账号怎么办（常见问题）</h3><ul><li>创建：touch ~/.ssh/config</li><li>添加内容：例如</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#gitlab</span>Host <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>HostName <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>RSAAuthentication yesIdentityFile <span class="token operator">~</span><span class="token punctuation">.</span><span class="token operator">/</span>ssh<span class="token operator">/</span>id_rsa_gitlab<span class="token macro property">#github</span>Host<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>HostName <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>RSAAuthentication yesUser <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>IdentityFile <span class="token operator">~</span><span class="token punctuation">.</span><span class="token operator">/</span>ssh<span class="token operator">/</span>github_id_rsa<span class="token macro property">#github</span>Host githubHostName github<span class="token punctuation">.</span>comRSAAuthentication yesUser 你的登录邮箱IdentityFile <span class="token operator">~</span><span class="token punctuation">.</span><span class="token operator">/</span>ssh<span class="token operator">/</span>github_id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加公钥到github账号ssh"><a href="#添加公钥到github账号ssh" class="headerlink" title="添加公钥到github账号ssh"></a>添加公钥到github账号ssh</h3><ul><li>打开github账号的设置界面</li><li>新建一个SSH Key</li></ul><p>然后将打开公钥文件，把内容粘贴到<br><img src="http://upload-images.jianshu.io/upload_images/664334-cf6211149269298f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>测试是否成功<code>ssh -T git@github.com</code></p><p>如果显示：</p><pre><code>Are you sure you want to continue connecting (yes/no)?</code></pre><p>输入yes。<br>然后就可以看到</p><pre><code>Hi yourusername! You&#39;ve successfully authenticated, but GitHub does notprovide shell access.</code></pre><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>这部分看着文档走就可以了，没什么难度。当然第一次创建一个比较有感觉的博客还是需要花一些时间的。这里我大致弄了一个模板。如果嫌麻烦可以直接用这个项目生成。地址<a href="https://github.com/ZhiJianShuSheng/BlogRecord" target="_blank" rel="noopener">后期补上</a></p><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://www.jianshu.com/p/0d7038102cd6" target="_blank" rel="noopener">生成ssh公钥并连接到github</a><br><a href="http://blog.csdn.net/diamont1001/article/details/51822803" target="_blank" rel="noopener">Mac里添加多个git ssh</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
